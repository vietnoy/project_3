{
    "id": 62621,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 3422,
    "title": "[H-02] swapTokens does not account for SwapX router fees when the out token is native",
    "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n## Description\nWhen the out token is native, the `SwapX` router charges fees on the out amount of the swap in both `swapV2ExactIn` and `swapV3ExactIn`, sending the remainder to the recipient but still returning the original out amount to the caller.\n\n[SwapX@takeFee](https://github.com/acc8-labs/swapx-router-contracts/blob/main/src/SwapX.sol#L149-L165)\n```solidity\n    function takeFee(address tokenIn, uint256 amountIn) internal returns (uint256){\n        if (feeExcludeList[msg.sender])\n            return 0;\n\n        uint256 fee = amountIn.mul(feeRate).div(feeDenominator);\n\n        if ( tokenIn == address(0) || tokenIn == WETH ) {\n            require(address(this).balance > fee, \"insufficient funds\");\n            (bool success, ) = address(feeCollector).call{ value: fee }(\"\");\n            require(success, \"SwapX: take fee error\");\n        } else\n            IERC20Upgradeable(tokenIn).safeTransferFrom(msg.sender, feeCollector, fee);\n\n        emit FeeCollected(tokenIn, msg.sender, fee, amountIn, block.timestamp);\n\n        return fee; \n    }\n```\n\n[SwapX@swapV2ExactIn](https://github.com/acc8-labs/swapx-router-contracts/blob/main/src/SwapX.sol#L168-L236)\n```solidity\n    function swapV2ExactIn(\n        address tokenIn, \n        address tokenOut, \n        uint256 amountIn, \n        uint256 amountOutMin, \n        address poolAddress\n    ) payable public nonReentrant whenNotPaused returns (uint amountOut){\n        // ...\n\n        bool nativeOut = false;\n        if (tokenOut == address(0))\n            nativeOut = true; <@\n\n        // ...\n\n        if (nativeOut) {\n            amountOut = IERC20Upgradeable(WETH).balanceOf(address(this)).sub(balanceBefore); <@\n            IWETH(WETH).withdraw(amountOut);\n            uint256 fee = takeFee(address(0), amountOut); <@\n            (bool success, ) = address(msg.sender).call{value: amountOut-fee}(\"\"); <@\n            require(success, \"SwapX: send ETH out error\");\n        } else {\n            amountOut = IERC20Upgradeable(tokenOut).balanceOf(msg.sender).sub(balanceBefore);\n        }\n        require(\n            amountOut >= amountOutMin,\n            'SwapX: insufficient output amount'\n        );\n    }\n```\n\n[SwapX@swapV3ExactIn](https://github.com/acc8-labs/swapx-router-contracts/blob/main/src/SwapX.sol#L499-L540)\n```solidity\n    function swapV3ExactIn (\n            ExactInputSingleParams memory params\n    ) external payable nonReentrant whenNotPaused checkDeadline(params.deadline) returns (uint256 amountOut) {\n        // ...\n\n        bool nativeOut = false;\n        if (params.tokenOut == WETH) \n            nativeOut = true;\n\n        // ...\n\n        amountOut = exactInputInternal( <@\n            params.amountIn,\n            nativeOut ? address(0) : params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender, payerOrigin: msg.sender})\n        );\n\n        require(amountOut >= params.amountOutMinimum, \"SwapX: insufficient out amount\");\n\n        if (nativeOut) {\n            IWETH(WETH).withdraw(amountOut);\n            uint256 fee = takeFee(address(0), amountOut); <@\n            (bool success, ) = address(params.recipient).call{value: amountOut-fee}(\"\"); <@\n            require(success, \"SwapX: send ETH out error\");\n        }\n    }\n```\n\nThis leads to the `FunnelVault` accounting for more tokens than actually received from the swap.\n\n[FunnelVaultUpgradeable@swapTokens](https://github.com/acc8-labs/funnel-vault/blob/main/src/FunnelVaultUpgradeable.sol#L317C14-L398)\n```solidity\n    function swapTokens(SwapParams calldata swapParams, address swapRouter, bool isBurn) external onlyRole(EXECUTER_ROLE) nonReentrant returns (uint256 amountOut) {\n        // ...\n\n        if (swapParams.useV3) {\n            ISwapX.ExactInputSingleParams memory params = ISwapX.ExactInputSingleParams({\n                tokenIn: swapParams.tokenIn,\n                tokenOut: swapParams.tokenOut,\n                fee: swapParams.fee,\n                recipient: address(this),\n                deadline: swapParams.deadline,\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOutMin,\n                sqrtPriceLimitX96: 0\n            });\n\n            if (params.tokenIn == address(0)) {\n                amountOut = ISwapX(swapRouter).swapV3ExactIn{value: params.amountIn}(params);\n            } else {\n                amountOut = ISwapX(swapRouter).swapV3ExactIn(params); <@\n            }\n        } else {\n            if (swapParams.poolAddress == address(0)) {\n                revert ZeroAddress();\n            }\n\n            if (swapParams.tokenIn == address(0)) {\n                amountOut = ISwapX(swapRouter).swapV2ExactIn{value: swapParams.amountIn}(\n                    swapParams.tokenIn,\n                    swapParams.tokenOut,\n                    swapParams.amountIn,\n                    swapParams.amountOutMin,\n                    swapParams.poolAddress\n                );\n            } else {\n                amountOut = ISwapX(swapRouter).swapV2ExactIn( <@\n                    swapParams.tokenIn,\n                    swapParams.tokenOut,\n                    swapParams.amountIn,\n                    swapParams.amountOutMin,\n                    swapParams.poolAddress\n                );\n            }\n        }\n\n        if (amountOut == 0) {\n            revert SwapFailed();\n        }\n\n        if (swapParams.tokenOut == WETH && swapParams.useV3) {\n            if(isBurn){\n                addToPoolBurn(address(0), swapParams.payingPool, amountOut); <@\n            } else {\n                addToPoolHIP(address(0), swapParams.payingPool, amountOut); <@\n            }\n        } else {\n            if(isBurn){\n                addToPoolBurn(swapParams.tokenOut, swapParams.payingPool, amountOut); <@\n            } else {\n                addToPoolHIP(swapParams.tokenOut, swapParams.payingPool, amountOut); <@\n            }\n        }\n\n        emit TokenSwapped(swapParams.tokenIn, swapParams.tokenOut, swapParams.amountIn, amountOut, swapRouter);\n    }\n```\n\n## Recommendations\n* On Funnel controlled `SwapX` routers, add the `FunnelVault` to the `feeExcludeList` or set the `feeRate` to 0.\n* To handle both controlled and non controlled `SwapX` routers, do not rely on the returned out amount and instead compare balance before and after the swap (similar to Fee on Transfer tokens).\n\n\n\n",
    "summary": "\nThis bug report discusses an issue with the `SwapX` router charging fees on the out amount of a swap, even when the out token is native. This results in the `FunnelVault` accounting for more tokens than actually received from the swap. The severity of this bug is considered medium, with a high likelihood of occurrence. The report includes code snippets from the `SwapX` and `FunnelVaultUpgradeable` contracts, as well as recommendations for resolving the issue. These recommendations include adding the `FunnelVault` to the `feeExcludeList` or setting the `feeRate` to 0 on controlled `SwapX` routers, and not relying on the returned out amount when handling both controlled and non-controlled `SwapX` routers.",
    "report_date": "2025-09-12T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/Funnel-security-review_2025-08-27.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "h-02-swaptokens-does-not-account-for-swapx-router-fees-when-the-out-token-is-native-pashov-audit-group-none-funnel_2025-08-27-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "Funnel_2025-08-27",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "Funnel_2025-08-27",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}