{
    "id": 62869,
    "kind": "PDF",
    "auditfirm_id": 9,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3450,
    "title": "Unbounded group array growth causes gas limit exceeded",
    "content": "## Vulnerability Report\n\n## Difficulty\nHigh\n\n## Type\nDenial of Service\n\n## Description\nThe contract’s group array management system can cause gas limit issues when users have many token purchases with different expiration times. Each token purchase creates a new Group in the `_group[account][tokenId]` array, and functions that iterate through this array can exceed the block gas limit when the array becomes too large.\n\nThe contract maintains a `_group` array for each account and token ID combination to track token batches with different expiration times. When users make frequent token purchases (e.g., one token every second), this creates a large array that must be iterated through during operations like `balanceOf`, `_transferGroups`, and `_validGroups`. Additionally, the `_upsertGroup` function performs expensive array insertion operations that shift elements to maintain expiration order. As the array grows, these operations consume increasing amounts of gas, eventually exceeding the block gas limit and making the contract unusable for affected users.\n\n```solidity\nfunction _upsertGroup(address account, uint256 id, uint256 amount, uint256 expiresAt) internal {\n    Group[] storage groups = _group[account][id];\n    // Find the correct position to insert the group (ordered by expiration, oldest to newest)\n    uint256 insertIndex = groups.length;\n    for (uint256 i = 0; i < groups.length; i++) {\n        // Check if this is an insert or an update\n        if (groups[i].expiresAt > expiresAt) {\n            // Insert the new token group at this position\n            insertIndex = i;\n            break;\n        } else if (groups[i].expiresAt == expiresAt) {\n            // If a token group with same expiration exists, combine the balances and return\n            groups[i].balance += amount;\n            return;\n        }\n    }\n    // If the new token group expires later than all the others, add it to the end of the array and return\n    if (insertIndex == groups.length) {\n        groups.push(Group({balance: amount, expiresAt: expiresAt}));\n        return;\n    }\n    // Shift array elements to make room for the new token group\n    groups.push(Group({balance: 0, expiresAt: 0})); // Add space at the end\n    for (uint256 i = groups.length - 1; i > insertIndex; i--) {\n        groups[i] = groups[i - 1];\n    }\n    // Insert the new Group at the correct position\n    groups[insertIndex] = Group({balance: amount, expiresAt: expiresAt});\n}\n```\n\n*Figure 5.1: Gas-intensive array operations in `_upsertGroup` function*\n\n## Exploit Scenario\nBob intentionally transfers small amounts of tokens with different expiration times to Alice’s address 2,000 times, creating 2,000 additional groups in her `_group[alice][tokenId]` array. When Alice attempts to transfer her tokens, the `_transferGroups` function must iterate through all groups to find valid tokens, remove them from Alice’s group array, and add them to the recipient’s group array, consuming excessive gas. The transaction fails due to gas limit, preventing Alice from transferring, burning, or even checking her token balance. This effectively locks Alice’s tokens in the contract, making them unusable.\n\n## Recommendations\n- **Short term:** Implement a maximum group array size limit and add pagination or batching mechanisms for operations that iterate through large group arrays.\n- **Long term:** Redesign the token expiration management system to use more efficient data structures that avoid linear iteration and reduce gas consumption for large token holdings.",
    "summary": "\nThis report discusses a high difficulty vulnerability in a contract's group array management system. This can cause gas limit issues when users have many token purchases with different expiration times, leading to a denial of service. The contract maintains a group array for each account and token ID combination, but frequent token purchases can create a large array that exceeds the block gas limit. This makes the contract unusable for affected users and effectively locks their tokens in the contract. The report recommends implementing a maximum array size limit and using more efficient data structures to manage token expiration. ",
    "report_date": "2025-10-03T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/trailofbits/publications/blob/master/reviews/2025-10-radiustechnology-evmauth-securityreview.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2025-10-radiustechnology-evmauth-securityreview.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2025-10-radiustechnology-evmauth-securityreview.pdf",
    "pdf_page_from": 21,
    "contest_id": "",
    "slug": "unbounded-group-array-growth-causes-gas-limit-exceeded-trailofbits-none-radius-technology-evmauth-pdf",
    "firm_name": "TrailOfBits",
    "firm_logo_square": "trailofbits_square.png",
    "protocol_name": "Radius Technology EVMAuth",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Quan Nguyen Trail of Bits PUBLIC"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "TrailOfBits",
        "logo_square": "trailofbits_square.png"
    },
    "protocols_protocol": {
        "name": "Radius Technology EVMAuth",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}