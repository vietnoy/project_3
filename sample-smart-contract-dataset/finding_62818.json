{
    "id": 62818,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 6,
    "protocol_id": 3398,
    "title": "M-3: Integer Truncation in Incentive Rate Permanently Locks Unstreamed Rewards",
    "content": "\nSource: https://github.com/sherlock-audit/2025-09-bmx-deli-swap-judging/issues/141 \n\n## Found by \n0x73696d616f, ami, blockace, cergyk, cpsec, r1ver\n\n### Summary\n\nThe integer division in `_upsertIncentive` will cause unstreamable “dust” accumulation for reward tokens as every remainder from `total / WEEK` is truncated. This results in permanently locked tokens for the protocol as any caller who tops up incentives will repeatedly create dust that cannot be streamed. The issue is more severe for tokens with fewer decimals, since each truncated remainder represents a larger absolute value, making the amount of unstreamable dust proportionally greater.\n\n\n\n### Root Cause\n\n**Root Cause**\n\nIn `IncentiveGauge._upsertIncentive`, the incentive rate is computed with **integer division** against a 7-day window, so any fractional part is truncated and never streamed. With `uint256 TimeLibrary.WEEK = 7 days`, the code is:\nhttps://github.com/sherlock-audit/2025-09-bmx-deli-swap/blob/main/deli-swap-contracts/src/IncentiveGauge.sol#L483-L499\n```solidity\n// IncentiveGauge::_upsertIncentive\nuint256 total = amount; // (+ leftover if topping up an active stream)\nrate = SafeCast.toUint128(total / TimeLibrary.WEEK); // <-- integer truncation\ninfo.rewardRate = rate;\ninfo.periodFinish = uint64(block.timestamp + TimeLibrary.WEEK);\ninfo.lastUpdate = uint64(block.timestamp);\ninfo.remaining = SafeCast.toUint128(total);\n```\n\nStreaming later accounts as `dt * info.rewardRate`, and when the period ends `_updatePool` **zeros** any leftover instead of paying it out:\nhttps://github.com/sherlock-audit/2025-09-bmx-deli-swap/blob/main/deli-swap-contracts/src/IncentiveGauge.sol#L723-L727\n```solidity\n// IncentiveGauge::_updatePool\nif (nowTs >= info.periodFinish || info.remaining == 0) {\n    info.remaining = 0;            // <-- residual is discarded\n    info.rewardRate = 0;\n    emit IncentiveDeactivated(pid, tok);\n}\n```\n\nThis means `total % WEEK` (the remainder from `total / WEEK`) becomes **permanently locked** in the contract each time an incentive is created or topped up.\n\nThe effect worsens for tokens with **fewer decimals** (coarser granularity): the same truncated remainder represents a larger absolute token amount. \nBecause the remainder is truncated on every funding/top-up and later wiped, dust accumulates and remains unclaimable, The smaller the decimal places. The higher the loss.\n\n\n### Internal Pre-conditions\n\n1. **Any user** needs to call `createIncentive()` to set `amount` of reward tokens to be greater than `TimeLibrary.WEEK` (604,800 seconds).\n2. **Reward token** needs to have decimals less than 18 (e.g., 6 for USDT/USDC or 4 for some tokens).\n\n\n\n### External Pre-conditions\n\nNone\n\n### Attack Path\n\n1. **Any user** calls `createIncentive(key, USDC, 100e6)` (USDC has 6 decimals; `amount` not a multiple of `WEEK = 604,800` seconds).\n2. **Contract** pulls `amount` and calls `_upsertIncentive`, where it computes\n   `rate = uint128(total / WEEK)` using integer division (fraction truncated).\n3. **Contract** sets `info.rewardRate = rate`, `info.remaining = total`; streaming accrues later as `dt * rate`.\n4. **During the 7-day period**, `_updatePool` repeatedly credits rewards using `dt * rate`, leaving a **remainder**\n   `dust = total − rate * WEEK` unstreamed.\n5. **At/after period finish**, `_updatePool` deactivates the incentive and does:\n   `info.remaining = 0; info.rewardRate = 0;` — the **unstreamed remainder is discarded** (never paid).\n6. **Result:** The truncated remainder (e.g., for 6-decimals tokens like USDT/USDC this can be noticeable) stays **permanently locked** in the contract.\n7. **If topped up repeatedly**, steps 1–6 repeat; each new schedule creates additional truncation dust that cumulatively remains unclaimable.\n\n\n### Impact\n\nThe protocol suffers a guaranteed loss of the “fractional dust” whenever incentives are created. Since rewards are streamed per second over exactly 604,800 seconds (7 days), any amount that cannot be evenly divided is truncated. For tokens with 6 decimals like USDT/USDC, this means that each second up to 0.000001 can be discarded. Over a full week, the cumulative loss can approach 0.4 USDC for every 1 USDC allocated as rewards. Tokens with fewer decimals (e.g., 4) will suffer even larger dust losses.\n\n### PoC\n\nI write a poc in `deli-swap-contracts/test/unit/IncentiveGaugeRoundingDust.t.sol`\nrun this command to test`forge test --match-contract IncentiveGaugeRoundingDustTest -vvv `\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IncentiveGauge} from \"src/IncentiveGauge.sol\";\nimport {MockPoolManager} from \"test/mocks/MockPoolManager.sol\";\nimport {IPoolManager} from \"@uniswap/v4-core/src/interfaces/IPoolManager.sol\";\n\nimport {PoolKey} from \"@uniswap/v4-core/src/types/PoolKey.sol\";\nimport {PoolId, PoolIdLibrary} from \"@uniswap/v4-core/src/types/PoolId.sol\";\nimport {Currency} from \"@uniswap/v4-core/src/types/Currency.sol\";\nimport {IHooks} from \"@uniswap/v4-core/src/interfaces/IHooks.sol\";\n\nimport {EfficientHashLib} from \"solady/utils/EfficientHashLib.sol\";\nimport {IPositionManagerAdapter} from \"src/interfaces/IPositionManagerAdapter.sol\";\nimport {PositionInfo} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";\n\ncontract USDC6 is IERC20 {\n    string public name = \"Mock USDC\";\n    string public symbol = \"USDC\";\n    uint8 public constant decimals = 6;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n    uint256 public override totalSupply;\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[to] += amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function mint(address to, uint256 amount) external {\n        totalSupply += amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n}\n\ncontract IncentiveGaugeRoundingDustTest is Test {\n    using PoolIdLibrary for PoolKey;\n\n    MockPoolManager pm;\n    IncentiveGauge gauge;\n    USDC6 usdc;\n\n    address owner = address(this);\n    address hook = address(this);\n    address funder = address(0xF00D);\n    address lpOwner = address(0xDEADBEEF);\n\n    PoolKey key;\n    PoolId pid;\n\n    function setUp() public {\n        pm = new MockPoolManager();\n        // Adapter is not used in this PoC; pass this contract address\n        gauge = new IncentiveGauge(IPoolManager(address(pm)), IPositionManagerAdapter(address(this)), hook);\n        usdc = new USDC6();\n\n        // Build a minimal PoolKey\n        key = PoolKey({\n            currency0: Currency.wrap(address(0xC0)),\n            currency1: Currency.wrap(address(0xC1)),\n            fee: 0,\n            tickSpacing: 60,\n            hooks: IHooks(address(0))\n        });\n        pid = key.toId();\n\n        // Initialize pool via hook and set whitelist\n        gauge.initPool(key, 0);\n        gauge.setWhitelist(IERC20(address(usdc)), true);\n\n        // Prepare PoolManager slot0 for updates\n        pm.setPoolSlot0(PoolId.unwrap(pid), 79228162514264337593543950336, 0); // sqrtPriceX96=1, tick=0\n\n        // Fund depositor\n        usdc.mint(funder, 100_000_000); // 100 USDC with 6 decimals\n        vm.prank(funder);\n        usdc.approve(address(gauge), type(uint256).max);\n    }\n\n    function test_PoC_incentive_dust_is_discarded_and_locked() public {\n        uint256 amount = 100_000_000; // 100 USDC (6 decimals)\n\n        // Create incentive (pulls tokens)\n        vm.prank(funder);\n        gauge.createIncentive(key, IERC20(address(usdc)), amount);\n\n        // Verify integer division on rate\n        (uint256 rate,, uint256 remainingBefore) = gauge.incentiveData(pid, IERC20(address(usdc)));\n        assertEq(remainingBefore, amount, \"remaining should equal amount at start\");\n        uint256 expectedRate = amount / 604800; // WEEK seconds\n        assertEq(rate, expectedRate, \"rate should be floor(amount/WEEK)\");\n        uint256 dust = amount - expectedRate * 604800;\n        assertGt(dust, 0, \"dust must be > 0 for non-multiple amounts\");\n\n        // Advance to after finish and update once via hook\n        vm.warp(block.timestamp + 604800 + 1);\n        gauge.pokePool(key);\n\n        // After finish, incentive is deactivated and remaining is set to 0\n        (uint256 rateAfter,, uint256 remainingAfter) = gauge.incentiveData(pid, IERC20(address(usdc)));\n        assertEq(rateAfter, 0, \"rewardRate should be 0 after finish\");\n        assertEq(remainingAfter, 0, \"remaining set to 0 (dust discarded)\");\n\n        // Contract still holds the full amount (no positions to claim)\n        uint256 bal = usdc.balanceOf(address(gauge));\n        assertEq(bal, amount, \"all tokens remain in contract; dust is irrecoverable\");\n    }\n\n    function test_PoC_dust_persists_after_claiming_streamed_amount() public {\n        // Create incentive and a single LP position that will claim streamed amount\n        uint256 amount = 100_000_000; // 100 USDC\n        vm.prank(funder);\n        gauge.createIncentive(key, IERC20(address(usdc)), amount);\n\n        // Register one position directly via adapter-only path (adapter is this contract)\n        uint256 tokenId = 1;\n        bytes32 posKey = EfficientHashLib.hash(bytes32(tokenId), bytes32(PoolId.unwrap(pid)));\n        gauge.notifySubscribeWithContext(tokenId, posKey, PoolId.unwrap(pid), 0, -120, 120, 1_000_000, lpOwner);\n\n        // Advance to finish and update\n        vm.warp(block.timestamp + 604800 + 1);\n        gauge.pokePool(key);\n\n        // Claim to owner via admin force-unsubscribe\n        uint256 ownerBalBefore = usdc.balanceOf(lpOwner);\n        gauge.adminForceUnsubscribe(posKey, true);\n        uint256 ownerBalAfter = usdc.balanceOf(lpOwner);\n\n        // Owner received streamed ~= rate * WEEK (allow 1 unit rounding difference)\n        (uint256 rateAfter,,) = gauge.incentiveData(pid, IERC20(address(usdc)));\n        assertEq(rateAfter, 0, \"rate zero after finish\");\n        uint256 expectedRate = amount / 604800;\n        uint256 expectedStreamed = expectedRate * 604800;\n        uint256 claimed = ownerBalAfter - ownerBalBefore;\n        bool withinRounding = (claimed == expectedStreamed) || (claimed + 1 == expectedStreamed);\n        assertTrue(withinRounding, \"owner received streamed amount within rounding tolerance\");\n\n        // Gauge retains exactly the dust (plus any unclaimed streamed, but with one LP it should be zero)\n        uint256 gaugeBal = usdc.balanceOf(address(gauge));\n        assertEq(gaugeBal, amount - claimed, \"gauge holds unclaimed portion (dust + rounding)\");\n        assertGe(gaugeBal, amount - expectedStreamed, \"gauge holds at least theoretical dust\");\n    }\n\n    // Minimal adapter method used by adminForceUnsubscribe\n    function getPoolAndPositionInfo(uint256 /*tokenId*/ ) external view returns (PoolKey memory k, PositionInfo info) {\n        k = key; // return the pool key used in this test\n        // info left as default zeros; not used by the code path under test\n    }\n}\n```\n\n\n### Mitigation\n\nWhen funding an incentive, **round the deposit down to a full-week multiple** and handle the remainder immediately so no dust can ever form:\n\n1. Compute\n   `effective = (amount / WEEK) * WEEK;`\n   `remainder = amount - effective;`\n\n2. Use `effective` to derive `rate = effective / WEEK` and start the 7-day stream.\n\n3. **Return** `remainder` to the funder (or **carry it forward** into the next funding call via a per-pool `pendingRemainder` accumulator until it reaches at least one full `WEEK`).\n\nThis guarantees `rate * WEEK == effective` and the entire streamed budget is paid out exactly, while the remainder is never trapped as unstreamable dust.\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/morphex-labs/deli-swap-contracts/pull/22\n\n\n\n\n",
    "summary": "\nThis bug report discusses a problem found in the code for the bmx-deli-swap protocol. The issue is related to the way rewards are calculated and distributed, specifically with the use of integer division. This causes a small amount of tokens, referred to as \"dust,\" to become permanently locked in the contract and unable to be claimed by users. The severity of this issue is greater for tokens with fewer decimals, as the amount of dust accumulated is proportionally larger. The report provides details on the root cause of the issue, pre-conditions for the bug to occur, and a potential attack path. It also includes a Proof of Concept (PoC) to demonstrate the problem. The report recommends rounding down the deposit amount to a full-week multiple and handling the remainder immediately to prevent the accumulation of dust. The protocol team has already addressed this issue in a recent update. ",
    "report_date": "2025-09-16T15:00:00.000Z",
    "contest_prize_txt": "47000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1154",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-09-bmx-deli-swap-judging/issues/141",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1154",
    "slug": "m-3-integer-truncation-in-incentive-rate-permanently-locks-unstreamed-rewards-sherlock-bmx-deli-swap-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "BMX Deli Swap",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "cergyk"
            }
        },
        {
            "wardens_warden": {
                "handle": "cpsec"
            }
        },
        {
            "wardens_warden": {
                "handle": "r1ver"
            }
        },
        {
            "wardens_warden": {
                "handle": "blockace"
            }
        },
        {
            "wardens_warden": {
                "handle": "0x73696d616f"
            }
        },
        {
            "wardens_warden": {
                "handle": "ami"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "BMX Deli Swap",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}