{
    "id": 62422,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3406,
    "title": "[MNBD1-4] Tokens cannot graduate if an attacker transfers KAS to the BondingCurvePool contract",
    "content": "**Severity:** Medium\n\n**Path:** contracts/BondingCurvePool.sol#L247-L260 \n\n**Description:** The `BondingCurvePool::graduateToken()` function is responsible for creating a new `ZealousSwapPair` between the MoonBound token and KAS. It does this by using the KAS collected during the bonding curve phase and a reserve of MoonBound tokens (25% of `maxSupply`):\n```\nfunction graduateToken() internal {\n    ...\n    // Add liquidity to DEX\n    uint256 currentPrice = getPriceAtTokens(totalTokensSold);\n    uint256 kasCollected = address(this).balance;\n\n    uint256 tokenForLiquidity = (kasCollected * SCALING_FACTOR) / currentPrice;\n    ...\n}\n```\nThe function calculates `kasCollected` using `address(this).balance`, and determines the number of MoonBound tokens needed for liquidity by dividing `kasCollected` by `currentPrice`.\n\nUnder normal conditions, `tokenForLiquidity` should always be less than the reserved token amount, because:\n\n- When all curve tokens (75% of maxSupply) are sold:\n\n    - `currentPrice` equals `graduationPriceKAS`\n\n    - `kasCollected` is expected to be less than\n```(curveTokens / 3) * graduationPriceKAS\n= reservedTokens * graduationPriceKAS\n```\n(due to the deduction of `graduationFeeKAS`)\n\nThe issue arises when an attacker can artificially inflate `kasCollected` by forcefully transferring extra KAS to the contract. This causes `tokenForLiquidity` to exceed `reservedTokens`, which leads to a failure in the call to `IZealousSwapRouter02(zealousSwapRouter).addLiquidityKAS()` because of not enough token to transfer.\n\nThis can be exploited via a self-destruct technique, allowing the attacker to send `graduationFeeKAS + Îµ` KAS to the `BondingCurvePool` even though the contract lacks a `receive()` function.\n\n**Remediation:**  If `tokenForLiquidity` exceeds `reservedTokens`, cap `tokenForLiquidity` to `reservedTokens`.\n```\n   uint256 tokenForLiquidity = (kasCollected * SCALING_FACTOR) / currentPrice;\n++ if (tokenForLiquidity > reservedTokens) {\n++    tokenForLiquidity = reservedTokens;\n++ }\n```\n\n**Status:**  Fixed\n\n\n- - -",
    "summary": "\nThis bug report is about a function called `graduateToken()` in the `BondingCurvePool.sol` contract. This function creates a new `ZealousSwapPair` between two tokens, MoonBound and KAS. The problem is that an attacker can manipulate the amount of KAS collected during the bonding curve phase, causing the function to fail. This can be exploited using a self-destruct technique. The suggested solution is to cap the amount of tokens used for liquidity if it exceeds the reserved amount. This bug has been fixed.",
    "report_date": "2025-05-26T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2025-05-26-Moonbound.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "mnbd1-4-tokens-cannot-graduate-if-an-attacker-transfers-kas-to-the-bondingcurvepool-contract-hexens-none-moonbound-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Moonbound",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Moonbound",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}