{
    "id": 62884,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "HIGH",
    "finders_count": 4,
    "protocol_id": 3419,
    "title": "Mempool denial-of-service via MAX_ADDRESSES",
    "content": "## Severity: High Risk\n\n## Context\n(No context files were provided by the reviewer)\n\n## Description\nBelow is a rough diagram of the current transaction pool architecture implemented in Monad. Currently, there are two mempools in Monad: a tracked pool and a pending pool.\n\n- All addresses are by default untracked.\n- Any transaction for an untracked address will first fall into the pending pool, while transactions for tracked addresses will fall into the tracked pool.\n- During `create_proposal` or `updated_committed_block`, addresses are promoted to the tracked pool, up to the `MAX_ADDRESSES` capacity.\n- During `create_proposal`, only transactions from the tracked pool will be selected via standard priority fee mechanism.\n- Time-based expiration per transaction exists only for the tracked pool.\n- An address is evicted from the tracked pool when it no longer has any transactions in the `TrackedTxList`.\n\nThe way the transaction pool is architected allows for a denial-of-service vector by hogging the `MAX_ADDRESSES` limit via multiple spam accounts. There are two main issues here:\n\n1. In both the tracked and pending mempool, priority fee replacement only works for transactions of the same address. If `MAX_ADDRESSES` is reached, we simply drop the transaction. The pool lacks an eviction strategy to evict lower fee transactions across addresses, which allows consuming space in `MAX_ADDRESSES` to prevent others from submitting transactions to the mempool. This differs from Geth where, if the transaction limit is reached, the lowest fee transaction from any address, not just the address that submitted the transaction, is evicted. This implementation can be seen in `legacypool.go#L743`.\n   \n2. A tracked address can periodically submit nonce-gapped transactions to the tracked pool. Such transactions will never be executed in a committed block (as they are nonce-gapped). Consequently, this prevents the tracked address from being evicted from the `TrackedTxMap` since they always have a single nonce-gapped transaction in their `TrackedTxList`, thereby consuming space in the `MAX_ADDRESSES` and preventing untracked addresses from being promoted.\n\n## Recommendation\nIt is recommended to come up with better eviction strategies to handle transactions in the mempool. Here are some recommendations to take into account:\n\n- Lower fee transactions should be evicted from the mempool if a higher fee transaction comes in, and eviction should also take into account whether the transaction is currently executable with the correct account nonce and priority fee.\n- Addresses with ONLY non-executable transactions, such as nonce-gapped transactions, should not be allowed into the tracked mempool or should be demoted if they no longer have any executable transactions of the next nonce. This is to prevent hogging `MAX_ADDRESSES` for the tracked pool.\n\n## Category Labs\nWe are tracking it in the open issue 2329.\n\n## Spearbit\nAcknowledged.",
    "summary": "\nThis bug report discusses an issue with the current transaction pool architecture in Monad. The report explains that there are two mempools in Monad - a tracked pool and a pending pool. However, there are two main issues with this setup that could potentially lead to a denial-of-service attack. \n\nThe first issue is that the pool lacks an eviction strategy to handle transactions from different addresses. This means that if the maximum number of addresses is reached, the pool will simply drop new transactions instead of evicting lower fee transactions from different addresses. This can be seen as a vulnerability compared to other systems where the lowest fee transaction from any address is evicted in this scenario. \n\nThe second issue is that tracked addresses can submit nonce-gapped transactions, which will never be executed in a committed block. This prevents the tracked address from being evicted from the pool, as they always have a transaction in their list. This can also lead to the tracked pool hogging the maximum number of addresses, preventing untracked addresses from being promoted. \n\nTo address these issues, the report recommends implementing better eviction strategies that take into account the fee and executability of transactions. It also suggests not allowing addresses with only non-executable transactions in the tracked pool or demoting them if they no longer have any executable transactions. \n\nThe report concludes by acknowledging that this issue is being tracked in an open issue and that the team is aware of the problem.",
    "report_date": "2025-09-19T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Monad-Spearbit-Security-Review-September-2025.pdf",
    "pdf_page_from": 7,
    "contest_id": "",
    "slug": "mempool-denial-of-service-via-max_addresses-spearbit-none-monad-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Monad",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Haxatron"
            }
        },
        {
            "wardens_warden": {
                "handle": "Dtheo"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guido Vranken"
            }
        },
        {
            "wardens_warden": {
                "handle": "Rikard Hjort"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Monad",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}