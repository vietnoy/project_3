{
    "id": 62942,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "LOW",
    "finders_count": 2,
    "protocol_id": 3463,
    "title": "firstTotalAssets analysis",
    "content": "## Severity: Low Risk\n\n## Context\n- `VaultV2.sol#L30-L34`\n- `VaultV2.sol#L179`\n- `VaultV2.sol#L563-L571`\n- `VaultV2.sol#L578`\n\n## Description\nIn the NatSpec comments we have:\n```solidity\n/// FIRST TOTAL ASSETS\n/// @dev The variable firstTotalAssets tracks the total assets after the first interest accrual of the\n/// transaction.\n/// @dev Used to implement a mechanism that prevents bypassing relative caps with flashloans.\n/// @dev This mechanism can generate false positives on relative cap breach when such a cap is nearly\n/// reached, for big deposits that go through the liquidity adapter.\n```\nThe comment is not quite accurate. We have:\n\n```solidity\nfunction accrueInterest() public {\n    (uint256 newTotalAssets, ...) = accrueInterestView();\n    // ...\n    _totalAssets = newTotalAssets.toUint128();\n    if (firstTotalAssets == 0) firstTotalAssets = newTotalAssets;\n    // ...\n    lastUpdate = uint64(block.timestamp);\n}\n\nfunction accrueInterestView() {\n    if (firstTotalAssets != 0) return (_totalAssets, 0, 0);\n    //...\n    return (newTotalAssets, ...);\n}\n```\n\nAnd so the transient storage parameter `firstTotalAssets` at any specific point in the call frame tree of a root transaction is either 0 or the first non-zero `newTotalAssets` in the ordered call-tree frame. Thus it could be 0 for a few frames and then as soon as it becomes non-zero it would stay the same value and the calls to `accrueInterestView()` would return early from this point on.\n\n### Example 1\nAssume `A0` is a non-zero value. Initially in the beginning of the root tx `T`, one starts with `A0` as the `_totalAssets`, then maybe due to some losses, `newTotalAssets` becomes 0 and thus for all the following call frames if we enter back into `accrueInterestView()` and `accrueInterest()` both `_totalAssets` and `newTotalAssets` stay 0, except somehow we increase `_totalAssets` to a non-zero value. This would only be possible through mint or deposit at this point. After this `firstTotalAssets` would be set to a non-zero value:\n\n```\nAtot = A0 → 0 → · · · → 0 → A1 = A1st tot\n```\n\n### Example 2\nThis is like example 1 but at a state where there are no total assets in the vault due to perhaps using a vault that is freshly deployed or perhaps due to the fact that all previous shareholders have exited the vault.\n\nAs one can see in both examples, the value of `firstTotalAssets` is not the value new total assets calculated in the first visit of `accrueInterestView()` in the whole call-frame tree of a root transaction. Moreover, until this value is set to a non-zero value the flow in `accrueInterestView()` performs all the operations without exiting early.\n\n```solidity\nfunction allocateInternal(/*...*/) internal {\n    // ...\n    accrueInterest();\n    // ...\n    for (...) {\n        // ...\n        require(/*...*/ ||\n            _caps.allocation <= firstTotalAssets.mulDivDown(_caps.relativeCap, WAD),\n        // ...);\n    }\n}\n```\n\nThe value of `firstTotalAssets` is used to limit the relative cap during an allocation process. Thus due to the above, the correct value is not used in the above examples. The value that should have been used must have been 0.\nBut currently, the last non-zero value is used.\n\n## Recommendation\nOne can store a flag in `firstTotalAssets` to indicate that the call-tree flow has gone through the `accrueInterest()` process even though the new total assets could be 0. In all cases, we can set `firstTotalAssets` to store the returned value from `accrueInterestView()` in its [1:255] bits and the first bit would be a flag bit indicating that `accrueInterest()` was called. \n\nHere is a rough patch:\n\n```diff\ndiff --git a/src/VaultV2.sol b/src/VaultV2.sol\nindex c86ec7f..90e68a4 100644\n--- a/src/VaultV2.sol\n+++ b/src/VaultV2.sol\n@@ -518,8 +518,10 @@ contract VaultV2 is IVaultV2 {\n require(_caps.absoluteCap > 0, ErrorsLib.ZeroAbsoluteCap());\n require(_caps.allocation <= _caps.absoluteCap, ErrorsLib.AbsoluteCapExceeded());\n \n+ uint256 cleanedFirstTotalAssets = firstTotalAssets » 1;\n require(\n- _caps.relativeCap == WAD || _caps.allocation <=\n firstTotalAssets.mulDivDown(_caps.relativeCap, WAD),\n- _caps.relativeCap == WAD || _caps.allocation <=\n cleanedFirstTotalAssets.mulDivDown(_caps.relativeCap, WAD),\n ErrorsLib.RelativeCapExceeded()\n );\n }\n@@ -561,10 +563,11 @@ contract VaultV2 is IVaultV2 {\n/* EXCHANGE RATE FUNCTIONS */\n function accrueInterest() public {\n+ if (firstTotalAssets != 0) return;\n (uint256 newTotalAssets, uint256 performanceFeeShares, uint256 managementFeeShares) =\n accrueInterestView();\n emit EventsLib.AccrueInterest(_totalAssets, newTotalAssets, performanceFeeShares,\n managementFeeShares);\n _totalAssets = newTotalAssets.toUint128();\n- if (firstTotalAssets == 0) firstTotalAssets = newTotalAssets;\n+ if (firstTotalAssets == 0) firstTotalAssets = (newTotalAssets « 1) + 1;\n if (performanceFeeShares != 0) createShares(performanceFeeRecipient, performanceFeeShares);\n if (managementFeeShares != 0) createShares(managementFeeRecipient, managementFeeShares);\n lastUpdate = uint64(block.timestamp);\n```\n\nMoreover, one can modify the accrue interest flow even further by strategically returning early if the last timestamp has not changed:\n\n```diff\ndiff --git a/src/VaultV2.sol b/src/VaultV2.sol\nindex c86ec7f..12aefde 100644\n--- a/src/VaultV2.sol\n+++ b/src/VaultV2.sol\n@@ -518,8 +518,10 @@ contract VaultV2 is IVaultV2 {\n require(_caps.absoluteCap > 0, ErrorsLib.ZeroAbsoluteCap());\n require(_caps.allocation <= _caps.absoluteCap, ErrorsLib.AbsoluteCapExceeded());\n \n+ uint256 cleanedFirstTotalAssets = firstTotalAssets » 1;\n require(\n- _caps.relativeCap == WAD || _caps.allocation <=\n firstTotalAssets.mulDivDown(_caps.relativeCap, WAD),\n- _caps.relativeCap == WAD || _caps.allocation <=\n cleanedFirstTotalAssets.mulDivDown(_caps.relativeCap, WAD),\n ErrorsLib.RelativeCapExceeded()\n );\n }\n@@ -561,10 +563,15 @@ contract VaultV2 is IVaultV2 {\n/* EXCHANGE RATE FUNCTIONS */\n function accrueInterest() public {\n+ if (firstTotalAssets != 0) return;\n+ if (lastUpdate == block.timestamp) {\n+ firstTotalAssets = (_totalAssets « 1) + 1;\n+ return;\n+ }\n (uint256 newTotalAssets, uint256 performanceFeeShares, uint256 managementFeeShares) =\n accrueInterestView();\n emit EventsLib.AccrueInterest(_totalAssets, newTotalAssets, performanceFeeShares,\n managementFeeShares);\n _totalAssets = newTotalAssets.toUint128();\n- if (firstTotalAssets == 0) firstTotalAssets = newTotalAssets;\n+ if (firstTotalAssets == 0) firstTotalAssets = (newTotalAssets « 1) + 1;\n if (performanceFeeShares != 0) createShares(performanceFeeRecipient, performanceFeeShares);\n if (managementFeeShares != 0) createShares(managementFeeRecipient, managementFeeShares);\n lastUpdate = uint64(block.timestamp);\n @@ -575,8 +582,12 @@ contract VaultV2 is IVaultV2 {\n /// @dev The performance and management fees are taken even if the vault incurs some losses.\n /// @dev Both fees are rounded down, so fee recipients could receive less than expected.\n function accrueInterestView() public view returns (uint256, uint256, uint256) {\n- if (firstTotalAssets != 0) return (_totalAssets, 0, 0);\n uint256 elapsed = block.timestamp - lastUpdate;\n+\n+ if (elapsed == 0 || firstTotalAssets != 0) {\n+ return (_totalAssets, 0, 0);\n+ }\n+ \n uint256 realAssets = IERC20(asset).balanceOf(address(this));\n for (uint256 i = 0; i < adapters.length; i++) {\n realAssets += IAdapter(adapters[i]).realAssets();\n```\n\n## Related Competition Findings:\n| Finding # | Title | Notes |\n|-----------|-------|-------|\n| #770 | Allocators can bypass the relative cap check |  |\n| #53 | Malicious allocator can manipulate firstTotalAssets to bypass relative cap policies | and many other dups |\n| #817 | Batch deposit calls will fail on a Vaults with Liquidity Adapter |  |\n| #855 | FirstTotalAssets Stale Value Enables Relative Cap Bypass in Same-Transaction Deposits |  |\n| #847 | Fund Loss via Relative Cap Validation Bypass in allocate() Function of VaultV2 Contract. Concern regarding the specs for relative caps being at WAD | X |\n| #803 | Morpho Vault V2: Missing accrueInterest() in deallocateInternal Leads to Potential Accounting Inconsistencies | X |\n| #790 | Relative Cap Bypass Through Rounding Error in VaultV2 | Incorrect, should be rejected |\n|  | And a few other ones that are not completely related. Search is based on looking for firstTotalAssets when on the finding page and pressing CMD + K. |  |\n\n### Related Test\n- `testRelativeCapManipulationProtection`",
    "summary": "",
    "report_date": "2025-10-13T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-fixes-Spearbit-Security-Review-August-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 5,
    "general_score": 5,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-fixes-Spearbit-Security-Review-August-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Morpho-Vaults-v2-fixes-Spearbit-Security-Review-August-2025.pdf",
    "pdf_page_from": 8,
    "contest_id": "",
    "slug": "firsttotalassets-analysis-spearbit-none-morpho-vaults-v2-fix-review-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Morpho Vaults v2 Fix Review",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "MiloTruck"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Morpho Vaults v2 Fix Review",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}