{
    "id": 62173,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3389,
    "title": "[M-01] Share tracking issue between `PublicAllocator` and `EulerEarn` affects reallocations",
    "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe `PublicAllocator::reallocateTo()` function uses real strategy share balances via `id.maxWithdraw(vault)` to calculate available assets, while `EulerEarn::reallocate()` uses internal share tracking via `config[id].balance` for actual operations. This discrepancy creates a serious issue when real share balances differ from the internal tracking of `EulerEarn` (which can happen due to direct share transfers of strategies to the vault).\n\n```solidity\n  // PublicAllocator.sol -> uses REAL strategy shares\n  uint256 assets = id.maxWithdraw(vault); // Real shares from strategy contract\n  allocations[i].assets = assets - withdrawnAssets; // Target allocation based on real shares\n  \n  // EulerEarn.sol -> uses INTERNAL share tracking  \n  uint256 supplyShares = config[id].balance; // Internal tracking\n  uint256 supplyAssets = id.previewRedeem(supplyShares); // Based on internal shares\n  uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets); // Actual withdrawal calculation\n```\n\nAs shown better in the PoC below, this vulnerability causes flow caps to be updated based on requested withdrawal amounts, while actual operations process different amounts. Apart from that, allocators in `PublicAllocator` may intend to withdraw a certain amount `x`, but ultimately, the withdrawn amount will be **different**. For this vulnerability to exist, strategy shares must have been transferred directly to the vault. If this happens, all calls to `reallocate()` in `PublicAllocator` will misbehave.\n\nIn order to reproduce this vulnerability, paste the following function in `PublicAllocatorTest.sol` and run `forge test --mt testRellocateToBug -vv` :\n\n```solidity\n    function testRellocateToBug() public {\n        flowCaps.push(FlowCapsConfig(idleVault, FlowCaps(100e18, 100e18)));\n        flowCaps.push(FlowCapsConfig(allMarkets[0], FlowCaps(100e18, 100e18)));\n        vm.prank(OWNER);\n        publicAllocator.setFlowCaps(address(vault), flowCaps);\n        \n        // Initial deposit through PublicAllocator (tracked internally)\n        withdrawals.push(Withdrawal(idleVault, 50e18));\n        publicAllocator.reallocateTo(address(vault), withdrawals, allMarkets[0]);\n        \n        console.log(\"=== After normal deposit ===\");\n        uint256 internalShares1 = vault.config(allMarkets[0]).balance;\n        uint256 realShares1 = allMarkets[0].balanceOf(address(vault));\n        console.log(\"Internal shares:                   \", internalShares1);\n        console.log(\"Real shares:                       \", realShares1);\n        \n        // Mint strategy shares directly and transfer to vault\n        // This creates the discrepancy between internal tracking and real balance\n        loanToken.setBalance(address(this), 20e18);\n        loanToken.approve(address(allMarkets[0]), 20e18);\n        uint256 directShares = allMarkets[0].deposit(20e18, address(vault)); // Mint shares directly to vault\n        \n        console.log(\"\\n=== After direct share transfer ===\");\n        uint256 internalShares2 = vault.config(allMarkets[0]).balance;\n        uint256 realShares2 = allMarkets[0].balanceOf(address(vault));\n        uint256 realAssets = allMarkets[0].maxWithdraw(address(vault));\n        uint256 internalAssets = allMarkets[0].previewRedeem(internalShares2);\n        console.log(\"Internal shares:                   \", internalShares2);\n        console.log(\"Real shares:                       \", realShares2);\n        \n        // At this point, we have a share disparency, which seems to not be a problem since EulerEarn is tracking its shares internally and only this is supposed to be the source of truth in its calculations. However, if we try to perform a reallocate, we will see the problem.\n\n        // Record flow caps before reallocation to show the issue.\n        FlowCaps memory withdrawFlowCapsBefore = publicAllocator.flowCaps(address(vault), allMarkets[0]);\n        FlowCaps memory supplyFlowCapsBefore = publicAllocator.flowCaps(address(vault), idleVault);\n        \n        console.log(\"\\n=== Flow caps BEFORE reallocation ===\");\n        console.log(\"Withdraw strategy maxIn:            \", withdrawFlowCapsBefore.maxIn);\n        console.log(\"Withdraw strategy maxOut:          \", withdrawFlowCapsBefore.maxOut);\n        console.log(\"Supply strategy maxIn:             \", supplyFlowCapsBefore.maxIn);\n        console.log(\"Supply strategy maxOut:             \", supplyFlowCapsBefore.maxOut);\n\n        delete withdrawals;\n        uint256 requestedWithdraw = 30e18;\n        withdrawals.push(Withdrawal(allMarkets[0], uint128(requestedWithdraw)));\n        \n        uint256 beforeAssets = allMarkets[0].maxWithdraw(address(vault));\n\n        console.log(\"\\n=== Reallocation ===\");\n        console.log(\"Requested withdrawal:              \", requestedWithdraw);\n        publicAllocator.reallocateTo(address(vault), withdrawals, idleVault);\n        \n        uint256 afterAssets = allMarkets[0].maxWithdraw(address(vault));\n        uint256 actualWithdrawn = beforeAssets - afterAssets;\n        console.log(\"Actual withdrawn:                  \", actualWithdrawn);\n        \n        // BUG: Allocator wanted to withdraw and deposit `requestedWithdraw` amount, but eventually `actualWithdrawn` were withdrawn and deposited.\n        assertNotEq(actualWithdrawn, requestedWithdraw);\n\n        // Show flow caps corruption\n        FlowCaps memory withdrawFlowCapsAfter = publicAllocator.flowCaps(address(vault), allMarkets[0]);\n        FlowCaps memory supplyFlowCapsAfter = publicAllocator.flowCaps(address(vault), idleVault);\n        \n        console.log(\"\\n=== Flow caps AFTER reallocation ===\");\n        console.log(\"Withdraw strategy maxIn:           \", withdrawFlowCapsAfter.maxIn);\n        console.log(\"Withdraw strategy maxOut:          \", withdrawFlowCapsAfter.maxOut);\n        console.log(\"Supply strategy maxIn:             \", supplyFlowCapsAfter.maxIn);\n        console.log(\"Supply strategy maxOut:            \", supplyFlowCapsAfter.maxOut);\n        \n        console.log(\"\\n=== Flow caps CHANGES (should match actual withdrawal, but matches requested) ===\");\n        console.log(\"Withdraw maxIn increase:           \", withdrawFlowCapsAfter.maxIn - withdrawFlowCapsBefore.maxIn);\n        console.log(\"Withdraw maxOut decrease:          \", withdrawFlowCapsBefore.maxOut - withdrawFlowCapsAfter.maxOut);\n        console.log(\"Supply maxIn decrease:             \", supplyFlowCapsBefore.maxIn - supplyFlowCapsAfter.maxIn);\n        console.log(\"Supply maxOut increase:            \", supplyFlowCapsAfter.maxOut - supplyFlowCapsBefore.maxOut);\n\n        uint256 flowCapChange = withdrawFlowCapsAfter.maxIn - withdrawFlowCapsBefore.maxIn;\n        console.log(\"\\n=== Bug Demonstration ===\");\n        console.log(\"Flow caps updated by:              \", flowCapChange);\n        console.log(\"But actual operation was:          \", actualWithdrawn);\n    }\n```\n\n## Recommendations\n\nIn order for this issue to be mitigated, `reallocateTo()` would need to calculate the supplied assets of a vault to a strategy using the `EulerEarn::_expectedSupplyAssets()`. This function, however, is internal, so consider exposing it publicly. Alternatively, retrieve the `config[id].balance` from `EulerEarn` and use it instead of `id.maxWithdraw`.\n\nOption 1: Expose internal function in `EulerEarn.sol`\n```solidity\n// In EulerEarn.sol -> make internal function public\nfunction expectedSupplyAssets(IERC4626 id) external view returns (uint256) {\n    return _expectedSupplyAssets(id);\n}\n\n// In PublicAllocator.sol -> use internal tracking instead of real shares\nuint256 assets = IEulerEarn(eulerEarn).expectedSupplyAssets(id);\n```\n\nOption 2: Use config balance directly in `PublicAllocator.sol`\n```solidity\n// In PublicAllocator.sol -> use internal balance\nuint256 internalShares = IEulerEarn(eulerEarn).config(id).balance;\nuint256 assets = id.previewRedeem(internalShares);\n```\n\n\n\n",
    "summary": "\nThe bug report describes an issue with the `PublicAllocator::reallocateTo()` function and `EulerEarn::reallocate()` function, which are used to manage assets in a smart contract. The problem arises when there is a discrepancy between the real share balances and the internal tracking of shares. This can happen when strategy shares are transferred directly to the smart contract. As a result, the flow caps, which control the amount of assets that can be withdrawn or deposited, are not updated correctly. To reproduce this issue, a specific function needs to be added and run with a specific command. To fix this problem, the report suggests two options: expose an internal function or use a different method to calculate the assets.",
    "report_date": "2025-08-27T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/EulerEarn-security-review_2025-07-25.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "m-01-share-tracking-issue-between-publicallocator-and-eulerearn-affects-reallocations-pashov-audit-group-none-eulerearn_2025-07-25-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "EulerEarn_2025-07-25",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "EulerEarn_2025-07-25",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}