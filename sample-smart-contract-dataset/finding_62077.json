{
    "id": 62077,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 2,
    "protocol_id": 2159,
    "title": "[M-14] Attackers can maliciously inflate `total_supply` temporarily to exceed utilization rate limit and push the pool towards 100% util rate, potentially causing a loss of lender funds",
    "content": "\n\n<https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/pool/src/pool/actions.rs# L382>\n\n### Summary\n\nBlend pools have a utilisation rate limit that borrowers are not allowed to cross. Lenders deposit into the pool because they agree with the utilization limit set that cannot be crossed to protect them from bad debt losses.\n\nHowever, a malicious user can bypass it with the following attack vector and push the pool illegally towards a 100% util rate (past the limit), causing potential loss for lenders during volatile market conditions\n\nCurrently during a borrow action, the only part where the utilization rate is checked is in `apply_borrow`, which checks it by calling the function `reserve.require_utilization_below_max(e)`.\n\nHowever, there is a way where users can build transactions to simply bypass the utilization rate. Consider the following transaction order.\n\nIn the build actions, the user can build as (assuming the malicious user already has collateral to make a borrow):\n\n1. `apply_supply`\n2. `apply_borrow`\n3. `apply_withdraw`\n\n(This is done in the same build transaction).\n\nThis works because `reserve.require_utilization_below_max(e)` is `total_liabilities` / `total_supply`. You can see that the transaction **temporarily inflates `total_supply` before withdrawing it**.\n\n**Important note:** Even though, `apply_borrow` sets `check_health` to `true`, check health **does not** check the utilization rate. It checks whether the individual user has sufficient collateral.\n\n### Impact\n\nThis allows the agreed upon utilization rate to be bypassed, putting the pool at a higher risk at baddebt than the lenders have agreed upon when they deposited their funds.\n\nMalicious users can do this during volatile market conditions, **to bring utilisation rate to 100%**, which is almost guaranteed to cause a loss of lender funds from baddebt in volatile market conditions. Hence, this is a high impact by Code4rena rules.\n\n### Likelihood\n\nThere isn’t much precondition to carry out this attack to bypass util rate. In fact, the attacker doesn’t even need to have the funds that they use to temporarily inflate `total_supply`. This is because funds are net-off and pulled in at the end, so the withdraw will net-off away from the supply.\n\nThe attacker will be able to continue having the loan, even though the loan may be causing the pool to reach **100% utilization rate**.\n\n### Proof Of Concept (POC)\n\nGo to `actions.rs` in the V2 repo. (I’m using the repo provided by the C4 audit page).\n\nThere is currently a function called `test_build_actions_from_request_borrow_errors_over_max_util()` already coded by the sponsor. It has a `#[should_panic....]` which is meant to catch the panic when the user borrows over util rate.\n\nFirst, lets remove the `#[should_panic....]` line as I will now prove the malicious user can avoid the panic by doing this hack.\n\nChange the test function to the following:\n```\n\n#[test]\nfn test_build_actions_from_request_borrow_errors_over_max_util() {\n    let e = Env::default();\n    e.mock_all_auths();\n\n    let bombadil = Address::generate(&e);\n    let samwise = Address::generate(&e);\n    let pool = testutils::create_pool(&e);\n\n    let (underlying, _) = testutils::create_token_contract(&e, &bombadil);\n    let (mut reserve_config, mut reserve_data) = testutils::default_reserve_meta();\n    reserve_config.max_util = 0_9000000;\n    reserve_data.b_supply = 100_0000000;\n    reserve_data.d_supply = 89_0000000;\n    testutils::create_reserve(&e, &pool, &underlying, &reserve_config, &reserve_data);\n\n    e.ledger().set(LedgerInfo {\n        timestamp: 600,\n        protocol_version: 22,\n        sequence_number: 1234,\n        network_id: Default::default(),\n        base_reserve: 10,\n        min_temp_entry_ttl: 10,\n        min_persistent_entry_ttl: 10,\n        max_entry_ttl: 3110400,\n    });\n    let pool_config = PoolConfig {\n        oracle: Address::generate(&e),\n        min_collateral: 1_0000000,\n        bstop_rate: 0_2000000,\n        status: 0,\n        max_positions: 2,\n    };\n\n    let user_positions = Positions {\n        liabilities: map![&e],\n        collateral: map![&e, (0, 20_0000000)],\n        supply: map![&e],\n    };\n    e.as_contract(&pool, || {\n        storage::set_pool_config(&e, &pool_config);\n        storage::set_user_positions(&e, &samwise, &user_positions);\n\n        let mut pool = Pool::load(&e);\n\n        let requests = vec![\n            &e,\n            Request {\n                request_type: RequestType::Supply as u32,\n                address: underlying.clone(),\n                amount: 10_1234567,\n            },\n            Request {\n                request_type: RequestType::Borrow as u32,\n                address: underlying.clone(),\n                amount: 2_0000000,\n            },\n            Request {\n                request_type: RequestType::Withdraw as u32,\n                address: underlying.clone(),\n                amount: 10_1234567,\n            }\n        ];\n        let mut user = User::load(&e, &samwise);\n        build_actions_from_request(&e, &mut pool, &mut user, requests);\n    });\n}\n```\n\nRun `cargo test test_build_actions_from_request_borrow_errors_over_max_util` and we can see that it passes even with the `#[should_panic..]` removed, meaning the attacker has successfully taken a loan passed the util rate.\n\n### Recommended mitigation steps\n\nMove `reserve.require_utilization_below_max(e)` from `apply_borrow` to `validate_submit` which is the function that is called when the built transaction ends.\n\nThat way, malicious users cannot bypass this by constructing a malicious `execute_submit` transaction list.\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[DadeKuma (validator) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-62?commentParent=2x8HmXeGKQv):**\n\n> Bypassing max util is possible with withdraw, and it’s intended to be that way. The issue seems to be that this is possible for user, even if they don’t provide funds.\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-62?commentParent=gxZc3tEqJkY):**\n\n> Validated this is an issue.\n>\n> The root of the issue is that user’s can borrow past `max_util` without actually having the funds to perform the actual `supply` invocation, or maintain the supplied position, to reduce the utilization below max util.\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-62?commentParent=v2YZSyR6YiD):**\n\n> Fixed to check max util during validation portion and check 100% util during `apply_action`.\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [Commit f35271b](https://github.com/blend-capital/blend-contracts-v2/commit/f35271bd660470e1d3037ed03302e612821c4add) to clean up utilization checks.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-28), [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-6), [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-64) and [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-77).\n\n---\n\n",
    "summary": "\nThe report discusses a bug in the Blend pools contract that allows malicious users to bypass the utilization rate limit and potentially cause losses for lenders during volatile market conditions. This can be done by inflating the total supply temporarily through a series of transactions, which is not properly checked for utilization rate. The impact of this bug is high and the likelihood of it being exploited is also high. A proof of concept is provided and a recommended mitigation step is to move the utilization rate check to a different function. The bug has been confirmed and mitigated by the Blend team. ",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-62",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-14-attackers-can-maliciously-inflate-total_supply-temporarily-to-exceed-utilization-rate-limit-and-push-the-pool-towards-100-util-rate-potentially-causing-a-loss-of-lender-funds-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "rscodes"
            }
        },
        {
            "wardens_warden": {
                "handle": "0x37"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}