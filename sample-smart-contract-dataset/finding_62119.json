{
    "id": 62119,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 9,
    "protocol_id": 3135,
    "title": "M-8: Malicious Users Can Perpetually Lock `feeRecipient` Shares via Targeted Lockup Reset",
    "content": "\nSource: https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults-judging/issues/711 \n\n## Found by \n0x23r0, 0xc0ffEE, 7, Arav, dan\\_\\_vinci, dimulski, klaus, lazyrams352, sakibcy\n\n### Summary\n\nThe protocol mints fee shares to the `feeRecipient` during deposits, redemptions, and protocol fee collection. However, the `ShareManager.mint()` function applies the `targetLockup` to **all recipients**, including the `feeRecipient`. Since this lock resets on every mint, a malicious user can repeatedly trigger minting operation and redeeming minimal amounts to **continually reset the lock timer**. As a result, the `feeRecipient`'s shares remain perpetually locked and unusable, leading to a DOS where protocol fees become inaccessible.\n\n\n### Root Cause\n\n\nThe protocol mints shares to the `feeRecipient` address in three cases: deposit fees, redeem fees, and protocol fees. Each of these cases calls the `mint` function in the `shareManager` contract, which directly mints tokens to the `feeRecipient` address based on calculations from the `FeeManager` contract.\n\n**1. `calculateDepositFee`**: Calculates the deposit fee in shares based on the amount.\n**2. `calculateRedeemFee`**: Calculates the redeem fee in shares based on the amount.\n**3. `calculateFee`**: Calculates the combined performance and protocol fee in shares.\n\n\n[DepositQueue](https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults/blob/main/flexible-vaults/src/queues/DepositQueue.sol#L176-L186)\n```solidity\n        {\n            IShareManager shareManager_ = vault_.shareManager();\n            uint256 shares = Math.mulDiv(assets, reducedPriceD18, 1 ether);\n            if (shares > 0) {\n                shareManager_.allocateShares(shares);\n            }\n            uint256 fees = Math.mulDiv(assets, priceD18, 1 ether) - shares;\n            if (fees > 0) {\n@>>                shareManager_.mint(feeManager.feeRecipient(), fees);\n            }\n        }\n```\n\n[RedeemQueue](https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults/blob/main/flexible-vaults/src/queues/RedeemQueue.sol#L99-L106)\n```solidity\n        {\n            IFeeManager feeManager = IShareModule(vault_).feeManager();\n            uint256 fees = feeManager.calculateRedeemFee(shares);\n            if (fees > 0) {\n@>>                shareManager_.mint(feeManager.feeRecipient(), fees);\n                shares -= fees;\n            }\n        }\n```\n\n\n\n[Vault](https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults/blob/main/flexible-vaults/src/modules/ShareModule.sol#L281-L284)\n\n```solidity\n        uint256 fees = feeManager_.calculateFee(address(this), asset, priceD18, shareManager_.totalShares());\n        if (fees != 0) {\n@>>            shareManager_.mint(feeManager_.feeRecipient(), fees);\n        }\n```\n\n\nHowever, the `ShareManager` contract includes a `targetLockup()` time flag that applies to each user individually after every `mint`. When shares are minted, the contract updates `$.accounts[account].lockedUntil = lockedUntil`, meaning the newly minted shares are locked for the `targetLockup` duration.\n\n\n```solidity\n    function mint(address account, uint256 value) public onlyVaultOrQueue {\n        if (value == 0) {\n            revert ZeroValue();\n        }\n        _mintShares(account, value);\n        ShareManagerStorage storage $ = _shareManagerStorage();\n        uint32 targetLockup = $.flags.getTargetedLockup();\n        if (targetLockup != 0) {\n            uint32 lockedUntil = uint32(block.timestamp) + targetLockup;\n            $.accounts[account].lockedUntil = lockedUntil;\n            emit Mint(account, value, lockedUntil);\n        } else {\n            emit Mint(account, value, 0);\n        }\n    }\n```\n\n\nIf a user attempts an action (e.g., transfer or withdraw) before the `lockedUntil` time has passed, the transaction will revert with `TargetedLockupNotExpired`.\n\n```solidity\n    function updateChecks(address from, address to) public view {\n        ShareManagerStorage storage $ = _shareManagerStorage();\n        uint256 flags_ = $.flags;\n        AccountInfo memory info;\n            //..\n\n\n            if (block.timestamp < info.lockedUntil) {\n                revert TargetedLockupNotExpired(block.timestamp, info.lockedUntil);\n            }\n\n            //...\n```\n\n\nThe result of this behavior is that **all shares minted to the `feeRecipient` including protocol, deposit, and redeem fees are automatically subjected to the `targetLockup` time restriction** defined in the `ShareManager`.\n\nBecause the `mint()` function enforces a lock on every recipient, **the `feeRecipient`'s newly minted shares become non-transferable and unusable until the lockup expires**.\n\n\n\n\n\n### Internal Pre-conditions\n\nN/A\n\n### External Pre-conditions\n\nN/A\n\n### Attack Path\n\n\n1. **Attacker deposits assets** into the vault, receiving some amount of shares.\n2. The attacker waits until the `feeRecipient`'s lockup period is about to expire.\n3. Just before it expires, the attacker redeems a small amount of shares.\n4. This redemption causes a small fee to be calculated and minted to the `feeRecipient`, which **resets its lock timer**.\n5. The attacker **repeats steps 2â€“4**, front-running any legitimate action from the `feeRecipient` and indefinitely extending its lock period.\n6. As a result, **any attempt by the `feeRecipient` to transfer, use, or withdraw funds will revert** with `TargetedLockupNotExpired`.\n\n### Impact\n\n\nA malicious user can perform a DoS attack on the `feeRecipient` by continuously resetting its lock timer.\n\nSince the `ShareManager.mint()` function applies the `targetLockup` duration to **every mint**, including those for the `feeRecipient`, an attacker can repeatedly:\n\n* Mint some amount of shares,\n* Redeem small amounts each time the lockup duration expires,\n* Cause the `ShareManager` to mint a fee to the `feeRecipient`,\n* Which in turn **resets the `lockedUntil` timestamp** on the `feeRecipient`.\n\nThis means that even after the lockup expires, the attacker can front-run any transaction involving the `feeRecipient` (e.g., transfer, withdraw, or claim) and extend its lock indefinitely.\n\nAs a result, the `feeRecipient` can be **permanently prevented from using or moving its funds**, effectively locking protocol fees forever.\n\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nSkip applying the `targetLockup` when minting shares to the `feeRecipient` address.\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/mellow-finance/flexible-vaults/pull/19\n\n\n\n\n",
    "summary": "\nThis bug report discusses a vulnerability found in the protocol mellow-flexible-vaults. The issue arises when the protocol mints fee shares to the `feeRecipient` during deposits, redemptions, and protocol fee collection. The `ShareManager.mint()` function applies a lockup period to all recipients, including the `feeRecipient`, which can be exploited by a malicious user to continually reset the lock timer and prevent the `feeRecipient` from accessing their shares. This can lead to a denial of service (DoS) attack where protocol fees become inaccessible. The root cause of this issue is traced back to the `ShareManager` contract which applies the lockup duration to every mint, including those for the `feeRecipient`. The impact of this vulnerability is that the `feeRecipient` can be permanently locked out of their shares, preventing them from using or moving their funds. The protocol team has fixed this issue by skipping the lockup period when minting shares to the `feeRecipient` address. ",
    "report_date": "2025-07-28T15:00:00.000Z",
    "contest_prize_txt": "70000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/964",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults-judging/issues/711",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "964",
    "slug": "m-8-malicious-users-can-perpetually-lock-feerecipient-shares-via-targeted-lockup-reset-sherlock-mellow-flexible-vaults-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Mellow Flexible Vaults",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "0x23r0"
            }
        },
        {
            "wardens_warden": {
                "handle": "dan\\_\\_vinci"
            }
        },
        {
            "wardens_warden": {
                "handle": "dimulski"
            }
        },
        {
            "wardens_warden": {
                "handle": "klaus"
            }
        },
        {
            "wardens_warden": {
                "handle": "dan\\_\\_vinci"
            }
        },
        {
            "wardens_warden": {
                "handle": "Arav"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xc0ffEE"
            }
        },
        {
            "wardens_warden": {
                "handle": "lazyrams352"
            }
        },
        {
            "wardens_warden": {
                "handle": "7"
            }
        },
        {
            "wardens_warden": {
                "handle": "sakibcy"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Mellow Flexible Vaults",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}