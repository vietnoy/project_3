{
    "id": 62877,
    "kind": "MARKDOWN",
    "auditfirm_id": 30,
    "impact": "LOW",
    "finders_count": 1,
    "protocol_id": 3454,
    "title": "[L-03] Re-minting Same `tokenId` After Burn Is Currently Possible",
    "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `burn()` marks `stakes[tokenId].burned = true` and sets `burnedAt`. ERC-721 `_burn()` sets owner to `address(0)`, and standard `_mint()` allows minting tokenId again. That means the NFT collection may later re-mint the same `tokenId` to someone else.\n\nThe staking contract retains a `stake()` record with `burned = true` and `owner = original staker`. A new owner of a re-minted `tokenId` has no stake record. The original staker will continue to collect burn-phase rewards even though the token was re-minted to someone else. This creates a state inconsistency/design mismatch that you should document and decide on.\n\n## Location of Affected Code\n\nFile: [src/NFTStaking.sol#L232](https://github.com/Honeypot-Finance/new_nft_staking/blob/02d5afe0b5327642f48fffe29ec2cb4607a078e7/src/NFTStaking.sol#L232)\n\n```solidity\n// Burn staked NFT and start earning burn bonus\nfunction burn(uint256 tokenId) external nonReentrant {\n    StakeData storage s = stakes[tokenId];\n    require(s.owner == msg.sender, \"NOT_OWNER\");\n    require(!s.burned, \"ALREADY_BURNED\");\n    require(s.stakedAt != 0, \"NOT_STAKED\");\n\n    // IMPORTANT: Claim all pending normal rewards before burning\n    _claim(tokenId);\n\n    // Burn the NFT\n    IERC721Burnable(address(nft)).burn(tokenId);\n\n    // Mark as burned and set burn timestamp\n    s.burned = true;\n    s.burnedAt = uint64(block.timestamp);\n\n    emit Burned(msg.sender, tokenId);\n}\n```\n\n## Recommendation\n\nDocument that staking assumes tokenIds are unique forever and must never be re-minted or add detection/guard:\n\n- block `mint()` of any `tokenId` that previously had a stake record (requires coordination with NFT contract) or\n- on burn, delete the stake and emit a one-time burn reward instead of leaving a perpetual burn-state, or cap burn reward time.\n\n## Team Response\n\nAcknowledged.\n\n## [I-01] Integer Division Dust - Small WEI Truncation in Reward Math\n\n## Severity\n\nInformational Risk\n\n## Description\n\nReward math uses integer division and floors results. Small per-claim “dust” (wei) is lost. Example: `1e18 / 86400` truncates, costing ~6,400 wei/day for a 1 token/day rate (1 token/day rate is set in the tests). This affects accounting precision.\n\n## Location of Affected Code\n\nFile: [src/NFTStaking.sol#L174](https://github.com/Honeypot-Finance/new_nft_staking/blob/02d5afe0b5327642f48fffe29ec2cb4607a078e7/src/NFTStaking.sol#L174)\n\n```solidity\n// rewardRatePerSecond set in initialize:\nrewardRatePerSecond = _ratePerSecond; // e.g., 1e18 / 86400\n\n// claim math:\nuint256 amount = (rewardRatePerSecond * delta * m) / ONE;\n\n// burn math:\namount = (rewardRatePerSecond * sinceBurn * mBurn * burnBonusBps) / (ONE * MAX_BPS);\n```\n\n## Recommendation\n\nMinimize dust by doing multiplication first with safe `mulDiv` and performing division as late as possible:\n\n```solidity\n// compute t = rate * delta safely\nuint256 t = FullMath.mulDiv(rewardRatePerSecond, delta, 1);\n// amount = (t * m) / ONE safely\nuint256 amount = FullMath.mulDiv(t, m, ONE);\n```\n\n## Team Response\n\nAcknowledged.\n\n## [I-02] Deduplicate Reward Calculation Logic to Prevent Drift\n\n## Severity\n\nInformational Risk\n\n## Description\n\nReward and multiplier computations are duplicated across preview and claim paths for both normal and burn modes. Duplicate logic raises the risk of future divergence between previews and actual payouts during upgrades.\n\n## Location of Affected Code\n\nFile: [src/NFTStaking.sol#L96](https://github.com/Honeypot-Finance/new_nft_staking/blob/02d5afe0b5327642f48fffe29ec2cb4607a078e7/src/NFTStaking.sol#L96)\n\n```solidity\n// Preview pending rewards for a token\nfunction previewPayout(uint256 tokenId) external view returns (uint256) {\n    StakeData memory s = stakes[tokenId];\n    if (s.owner == address(0)) return 0;\n\n    if (s.burned) {\n        // Calculate burn bonus accrual since last burn claim\n        if (s.burnedAt == 0) return 0;\n        uint256 sinceBurn = block.timestamp - uint256(s.burnedAt);\n        if (sinceBurn == 0) return 0;\n        uint256 mBurn = _multiplier(sinceBurn);\n        // reward = rate * sinceBurn * mBurn scaled by burnBonusBps\n        return\n            (rewardRatePerSecond * sinceBurn * mBurn * burnBonusBps) /\n            (ONE * MAX_BPS);\n    }\n\n    // Calculate normal staking rewards\n    uint256 nowTs = block.timestamp;\n    if (nowTs <= s.lastClaimAt) return 0;\n\n    uint256 delta = nowTs - uint256(s.lastClaimAt);\n    uint256 elapsed = nowTs - uint256(s.stakedAt);\n    uint256 m = _multiplier(elapsed);\n\n    return (rewardRatePerSecond * delta * m) / ONE;\n}\n```\n\nFile: [src/NFTStaking.sol#L161](https://github.com/Honeypot-Finance/new_nft_staking/blob/02d5afe0b5327642f48fffe29ec2cb4607a078e7/src/NFTStaking.sol#L161)\n\n```solidity\n// Handle normal staking claim\nfunction _claim(uint256 tokenId) internal returns (uint256 amount) {\n    StakeData storage s = stakes[tokenId];\n    require(s.owner == msg.sender, \"NOT_OWNER\");\n    require(s.stakedAt != 0, \"NOT_STAKED\");\n\n    if (s.burned) {\n        // Handle burn bonus claim\n        require(s.burnedAt != 0, \"INVALID_BURN_STATE\");\n\n        uint256 sinceBurn = block.timestamp - uint256(s.burnedAt);\n        if (sinceBurn == 0) return 0;\n\n        uint256 mBurn = _multiplier(sinceBurn);\n        amount =\n            (rewardRatePerSecond * sinceBurn * mBurn * burnBonusBps) /\n            (ONE * MAX_BPS);\n\n        if (amount == 0) return 0;\n\n        // Update last burn claim time\n        s.burnedAt = uint64(block.timestamp);\n\n        // Mint burn bonus rewards\n        rewards.mint(msg.sender, amount);\n        emit BurnRewardClaimed(msg.sender, tokenId, amount);\n\n        return amount;\n    }\n\n    // Handle normal staking claim\n    uint256 nowTs = block.timestamp;\n    if (nowTs <= s.lastClaimAt) return 0;\n\n    uint256 delta = nowTs - uint256(s.lastClaimAt);\n    uint256 elapsed = nowTs - uint256(s.stakedAt);\n    uint256 m = _multiplier(elapsed);\n\n    amount = (rewardRatePerSecond * delta * m) / ONE;\n\n    if (amount == 0) return 0;\n\n    // Update last claim time\n    s.lastClaimAt = uint64(nowTs);\n\n    // Mint rewards\n    rewards.mint(s.owner, amount);\n    emit RewardClaimed(s.owner, tokenId, amount);\n\n    return amount;\n}\n```\n\n## Impact\n\nInconsistent or incorrect rewards between preview and actual minting, undermining user expectations and potentially causing over-/under-payments.\n\n## Recommendation\n\nReuse `previewPayout()` in the claim path.\n\n## Team Response\n\nFixed.\n\n## [I-03] Inconsistent Mint Recipient in Burn Claims Risks Future Misdirection\n\n## Severity\n\nInformational Risk\n\n## Description\n\nNormal claims mint to the recorded stake owner, while burn claims mint to `msg.sender`. Although currently gated by `require(s.owner == msg.sender)`, future changes (e.g., permissionless claims) could direct rewards to an arbitrary caller instead of the rightful owner. Because the protocol is UUPS-upgradeable, any future implementation that relaxes claim access (permissionless/delegated/batch/relayed claims) can turn this inconsistency into a concrete payout-redirection bug.\n\n## Location of Affected Code\n\nFile: [src/NFTStaking.sol#L206](https://github.com/Honeypot-Finance/new_nft_staking/blob/02d5afe0b5327642f48fffe29ec2cb4607a078e7/src/NFTStaking.sol#L206)\n\n```solidity\nfunction _claim(uint256 tokenId) internal returns (uint256 amount) {\n  // code\n  if (s.burned) {\n    // code\n    // Mint burn bonus rewards\n    rewards.mint(msg.sender, amount);\n    emit BurnRewardClaimed(msg.sender, tokenId, amount);\n  }\n  // Mint rewards\n  rewards.mint(s.owner, amount);\n  emit RewardClaimed(s.owner, tokenId, amount);\n}\n```\n\n## Impact\n\nRewards could be stolen or misdirected if a future UUPS upgrade enables permissionless, delegated, automated, or relayed claiming without aligning payout recipient semantics. Specifically, the burn-claim path paying `msg.sender` would let any caller siphon rewards that should go to the recorded stake owner.\n\n## Recommendation\n\nStandardize on minting to `s.owner` in all claim paths.\n\n## Team Response\n\nFixed.\n\n",
    "summary": "",
    "report_date": "2025-10-08T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/HoneypotFinance-NFTStaking-Security-Review.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "l-03-re-minting-same-tokenid-after-burn-is-currently-possible-shieldify-none-honeypotfinance-nftstaking-markdown",
    "firm_name": "Shieldify",
    "firm_logo_square": "Shieldify_square.png",
    "protocol_name": "Honeypotfinance Nftstaking",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Shieldify Security"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Shieldify",
        "logo_square": "Shieldify_square.png"
    },
    "protocols_protocol": {
        "name": "Honeypotfinance Nftstaking",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}