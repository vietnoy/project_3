{
    "id": 62906,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3419,
    "title": "event_ring_util.c is_writer_fdout-of-bounds memory access",
    "content": "## Severity: Medium Risk\n\n## Context\n`event_ring_util.c#L62`\n\n## Description\nCommit `fca3deaa` introduces the function `is_writer_fd`. This function is reproduced below:\n\n```c\nstatic bool is_writer_fd(ino_t ring_ino, int fdinfo_entry) {\n    char const FDINFO_DELIM[] = \"\\t :\";\n    char read_buf[256];\n    char *scan = read_buf;\n    char *line;\n\n    if (read(fdinfo_entry, read_buf, sizeof read_buf) == -1) {\n        return false;\n    }\n    bool is_write = false;\n    bool is_ino = false;\n    \n    while ((line = strsep(&scan, \"\\n\"))) {\n        char *key, *value = nullptr;\n        key = strsep(&line, FDINFO_DELIM);\n        \n        while (line != nullptr) {\n            value = strsep(&line, FDINFO_DELIM);\n        }\n        if (key != nullptr && strcmp(key, \"flags\") == 0 && value != nullptr) {\n            unsigned long const flags = strtoul(value, nullptr, 0);\n            is_write = flags & O_WRONLY || flags & O_RDWR;\n        }\n        if (key != nullptr && strcmp(key, \"ino\") == 0 && value != nullptr) {\n            unsigned long const ino = strtoul(value, nullptr, 10);\n            is_ino = ino == ring_ino;\n        }\n    }\n    return is_write && is_ino;\n}\n```\n\nThe file is read into `char read_buf[256]` using `read()`. `read()` will only return `-1` if it fails to read at all. If the file is larger than `char read_buf[256]`, `read()` will simply return `256`, and `is_writer_fd` will proceed to parse the buffer contents, which in this case is not guaranteed to be well-formed due to truncation. In seeking the next delimiter, and not encountering a terminating `NULL`, `strsep` may read beyond buffer bounds. Additionally, if the delimiter is found in the memory region after `read_buf`, `strsep` will write a zero at this location, incurring stack corruption. This can lead to stability issues. This is a reasonable possibility since some files in `/proc/<pid>/fdinfo/` have fields with long values.\n\nAdditionally, there is a risk that `read()` will not read the entire file. Given its declaration `ssize_t read(int fd, void buf[.count], size_t count)`, it is allowed to read `0..count` bytes (including less than `count` bytes). Although unlikely, the function's logic should account for this possibility to prevent truncation even if the read buffer is sufficiently large.\n\n## Proof of Concept\n```c\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n/* Verbatim copy of is_writer_fd in\nhttps://github.com/category-labs/monad/commit/fca3deaa078ed0a0084a7c264807f22fd867273a */\nstatic bool is_writer_fd(ino_t ring_ino, int fdinfo_entry) {\n    char const FDINFO_DELIM[] = \"\\t :\";\n    char read_buf[256];\n    char *scan = read_buf;\n    char *line;\n\n    if (read(fdinfo_entry, read_buf, sizeof read_buf) == -1) {\n        return false;\n    }\n    bool is_write = false;\n    bool is_ino = false;\n    \n    while ((line = strsep(&scan, \"\\n\"))) {\n        char *key, *value = nullptr;\n        key = strsep(&line, FDINFO_DELIM);\n        \n        while (line != nullptr) {\n            value = strsep(&line, FDINFO_DELIM);\n        }\n        if (key != nullptr && strcmp(key, \"flags\") == 0 && value != nullptr) {\n            unsigned long const flags = strtoul(value, nullptr, 0);\n            is_write = flags & O_WRONLY || flags & O_RDWR;\n        }\n        if (key != nullptr && strcmp(key, \"ino\") == 0 && value != nullptr) {\n            unsigned long const ino = strtoul(value, nullptr, 10);\n            is_ino = ino == ring_ino;\n        }\n    }\n    return is_write && is_ino;\n}\n\nint main(int argc, char** argv) {\n    int fd = open(argv[1], O_RDONLY);\n    if (fd != -1) {\n        is_writer_fd(0, fd);\n        close(fd);\n    }\n    return 0;\n}\n```\n\nValgrind indicates branching on uninitialized memory occurs even with small (< 256 bytes), well-formed files, presumably because the `strsep` assumes arguments passed to it are NULL-terminated strings; these warnings disappear if `read_buf` is memset to `0` prior to reading.\n\n## Recommendation\nEnsure the entire file is read into a sufficiently large NULL-terminated buffer before parsing.\n\n**Category Labs**: Fixed in PR 1613.  \n**Spearbit**: Fix verified.",
    "summary": "\nThe bug report discusses a medium-risk bug in the function `is_writer_fd` in the file `event_ring_util.c`. This function was introduced in commit `fca3deaa` and is used to check if a file descriptor is a writer. However, there are two main issues with the function that can lead to instability and potential crashes. \n\nFirstly, the function uses the `read()` function to read the file into a buffer of size 256. However, if the file is larger than 256 bytes, `read()` will only return 256 and the function will proceed to parse the buffer contents. This can cause issues as the buffer may not be well-formed due to truncation. Additionally, if the delimiter is found in the memory region after the buffer, it can cause stack corruption. This is a common occurrence as some files in `/proc/<pid>/fdinfo/` have fields with long values. \n\nSecondly, the function does not account for the possibility of `read()` not reading the entire file. This can happen if the file is large and `read()` is allowed to read `0..count` bytes. The function should be modified to account for this possibility to prevent truncation even if the buffer is large enough. \n\nThe bug can be reproduced using the provided proof of concept code, which also shows that branching on uninitialized memory can occur. The recommendation is to ensure that the entire file is read into a large enough buffer before parsing to prevent these issues. The bug has been fixed in PR 1613 by Category Labs and has been verified by Spearbit.",
    "report_date": "2025-09-19T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Monad-Spearbit-Security-Review-September-2025.pdf",
    "pdf_page_from": 38,
    "contest_id": "",
    "slug": "event_ring_utilc-is_writer_fdout-of-bounds-memory-access-spearbit-none-monad-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Monad",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Haxatron"
            }
        },
        {
            "wardens_warden": {
                "handle": "Dtheo"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guido Vranken"
            }
        },
        {
            "wardens_warden": {
                "handle": "Rikard Hjort"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Monad",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}