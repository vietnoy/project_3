{
    "id": 62291,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 3,
    "protocol_id": 3396,
    "title": "vars.availableLiquidity is not capped by the reserve's total managed assets",
    "content": "## Severity: Medium Risk\n\n## Context\n- MiniPoolDefaultReserveInterestRate.sol#L147-L149\n- MiniPoolPiReserveInterestRateStrategy.sol#L106-L108\n\n## Description\nThe following formula assumes there is enough liquidity in the corresponding tranched reserve in the lending pool to cover the unused flow (which might not be the case).\n\n```solidity\nvars.availableLiquidity = IERC20(asset).balanceOf(aToken) \n                        + IAToken(asset).convertToShares(flowLimiter.getFlowLimit(vars.underlying, minipool)) \n                        - IAToken(asset).convertToShares(vars.currentFlow);\n```\n\nLet's define `vars.flowLiquidity` as:\n\n```solidity\nvars.flowLiquidity = IAToken(asset).convertToShares(flowLimiter.getFlowLimit(vars.underlying, minipool)) \n                    - IAToken(asset).convertToShares(vars.currentFlow);\n```\n\nThen this `vars.flowLiquidity` needs to be capped by the liquidity available in the corresponding reserve in the lending pool:\n\n```solidity\nvars.flowLiquidity = min(\n    vars.flowLiquidity,\n    IAToken(asset).convertToShares(\n        IAToken(asset).ATOKEN_ADDRESS().getTotalManagedAssets()\n    )\n);\n```\n\n## Recommendation\nBased on the above, one should put a cap on the available flow and modify the formula used for `vars.availableLiquidity` as follows:\n\n```solidity\nvars.flowLiquidity = IAToken(asset).convertToShares(flowLimiter.getFlowLimit(vars.underlying, minipool)) \n                    - IAToken(asset).convertToShares(vars.currentFlow);\n\nvars.flowLiquidity = min(\n    vars.flowLiquidity,\n    IAToken(asset).convertToShares(\n        IAToken(asset).ATOKEN_ADDRESS().getTotalManagedAssets()\n    )\n);\n\nvars.availableLiquidity = IERC20(asset).balanceOf(aToken) + vars.flowLiquidity;\n```\n\n## Astera\nThe unused flow has been removed from `vars.availableLiquidity` in commit `6c7bf89e`, and thus this issue does not apply anymore.\n\n## Spearbit\nVerified.",
    "summary": "\nThis bug report discusses an issue related to the calculation of available liquidity in the MiniPoolDefaultReserveInterestRate and MiniPoolPiReserveInterestRateStrategy contracts. The formula used to calculate available liquidity assumes that there is enough liquidity in the lending pool reserve to cover the unused flow, which may not always be the case. To fix this, a cap should be placed on the available flow and the formula for calculating available liquidity should be modified. However, this issue has been resolved in a recent commit and is no longer applicable. ",
    "report_date": "2025-08-29T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astera-Spearbit-Security-Review-December-2024.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astera-Spearbit-Security-Review-December-2024.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astera-Spearbit-Security-Review-December-2024.pdf",
    "pdf_page_from": 26,
    "contest_id": "",
    "slug": "varsavailableliquidity-is-not-capped-by-the-reserves-total-managed-assets-spearbit-none-astera-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Astera",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Cergyk"
            }
        },
        {
            "wardens_warden": {
                "handle": "Jonatas Martins"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Astera",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}