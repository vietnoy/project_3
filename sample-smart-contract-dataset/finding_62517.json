{
    "id": 62517,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3104,
    "title": "M-25: Revert in `getWithdrawRequestValue()` function will brick the account",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/779 \n\n## Found by \nxiaoming90\n\n### Summary\n\n-\n\n### Root Cause\n\n- Revert can occur in `getWithdrawRequestValue()` function, which the critical `price()` function depends on, due to a lack of proper error handling.\n- Incorrect assumption that the exit balance will never be zero under any circumstances.\n\n### Internal Pre-conditions\n\n-\n\n### External Pre-conditions\n\n-\n\n### Attack Path\n\n**Main Issue**\n\nIt was found that when computing the value of the withdraw request, it will attempt to loop through all Cruve's pool tokens and check if there is a withdraw request for the current token. If not, the transaction will revert in Line 332 below.\n\nThe issue is that if it is ever possible to cause a revert in Line 332, it will be a serious issue because Morpho can no longer fetch the price. The Notional's `price()` relies on the `getWithdrawRequestValue()` function. If the `price()` reverts when Morpho is reading it, the affected account's position will be stuck forever, as none of the operations (exit position, repay debt, withdraw collateral, liquidation) can be performed.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L332\n\n```solidity\nFile: AbstractSingleSidedLP.sol\n319:     function getWithdrawRequestValue(\n320:         address account,\n321:         address asset,\n322:         uint256 shares\n323:     ) external view returns (uint256 totalValue) {\n324:         ERC20[] memory tokens = TOKENS();\n325: \n326:         for (uint256 i; i < tokens.length; i++) {\n327:             IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n328:             // This is called as a view function, not a delegate call so use the msg.sender to get\n329:             // the correct vault address\n330:             (bool hasRequest, uint256 value) = manager.getWithdrawRequestValue(msg.sender, account, asset, shares);\n331:             // Ensure that this is true so that we do not lose any value.\n332:             require(hasRequest);\n333:             totalValue += value;\n334:         }\n335:     }\n```\n\nLet's review if there is a possibility where the revert in Line 332 can be triggered.\n\nIt was found that it is possible under certain conditions. If the exit balance of one of the tokens is zero, no withdraw request will be created for that specific token, as shown in Line 362. Creation of the withdraw request will be skipped.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L363\n\n```solidity\nFile: AbstractSingleSidedLP.sol\n353:     function initiateWithdraw(\n354:         address account,\n355:         uint256 sharesHeld,\n356:         uint256[] calldata exitBalances,\n357:         bytes[] calldata withdrawData\n358:     ) external override returns (uint256[] memory requestIds) {\n359:         ERC20[] memory tokens = TOKENS();\n360: \n361:         requestIds = new uint256[](exitBalances.length);\n362:         for (uint256 i; i < exitBalances.length; i++) {\n363:             if (exitBalances[i] == 0) continue;\n364:             IWithdrawRequestManager manager = ADDRESS_REGISTRY.getWithdrawRequestManager(address(tokens[i]));\n365: \n366:             tokens[i].checkApprove(address(manager), exitBalances[i]);\n367:             // Will revert if there is already a pending withdraw\n368:             requestIds[i] = manager.initiateWithdraw({\n369:                 account: account,\n370:                 yieldTokenAmount: exitBalances[i],\n371:                 sharesAmount: sharesHeld,\n372:                 data: withdrawData[i]\n373:             });\n374:         }\n375:     }\n```\n\nThus, the current implementation will only work if there is an assumption or invariant that the exit balance of any tokens can never be zero under any circumstances.\n\nHowever, this assumption and the invariant do not hold at all times due to the following reasons:\n\n1. If users have almost entirely swapped out one token, leaving its balance nearly or exactly zero, then proportional withdrawal will result in zero for that token. If it is near zero or an extremely small amount, the returned token amount might round down to zero.\n2. Notional does not enforce a minimum position size. Thus, if the position is tiny, the LP token to be exited will be tiny, and withdrawal for a given token can round down to zero. Tokens with small decimal precision (e.g, USDC=6, WBTC=8) are more susceptible to this rounding problem.\n3. After a major “depeg event” or manipulation, one token could be totally depleted\n\n### Impact\n\nFunds are being stuck as shown in the scenario above.\n\n### PoC\n\n_No response_\n\n### Mitigation\n\n_No response_\n\n",
    "summary": "\nThe bug report discusses a critical issue found by a user named xiaoming90 in the Notional Exponent Judging code. The issue is related to a lack of proper error handling in the `getWithdrawRequestValue()` function, which is used by the `price()` function. This can cause a revert, or a cancellation of the transaction, which can lead to a user's position being stuck and unable to perform any operations. The root cause of this issue is the incorrect assumption that the exit balance of a token will never be zero under any circumstances. This can happen due to various reasons such as users swapping out a token, not enforcing a minimum position size, or a major event causing a token to be depleted. The impact of this bug is that funds can be stuck and unable to be accessed. The report also mentions that there is no response or mitigation plan from the developers yet. ",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/779",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "m-25-revert-in-getwithdrawrequestvalue-function-will-brick-the-account-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "xiaoming90"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}