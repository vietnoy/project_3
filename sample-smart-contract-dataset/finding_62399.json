{
    "id": 62399,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 3405,
    "title": "[LOGLAB-15] Last withdrawer could give next depositor 0 shares",
    "content": "**Severity:** High\n\n**Path:** src/vault/LogarithmVault.sol#L510-L513\n\n**Description:** The `claim` function has a different workflow for the last redeem, this requires `totalSupply` = 0 and `utilizedAssets` = 0 (meaning the last withdraw was executed).\n\nTo be able to claim, a user must first make a withdrawal request. This causes their tokens to be burned, which can make the total supply go to 0 if they are the last person to withdraw.\n\nThis is important because it triggers the `isLast` case in the `claim` function. This allows an attacker to receive all idle assets from the vault, since they would be the last person to withdraw. \n\nHowever before claiming, an attacker can do a token transfer of for example `TEN_THOUSANDS_USDC` to the `vault` and `deposit` 1 wei, to receive 1 `share` since the `totalSupply` is 0. This would give the next depositor 0 shares when they deposit an amount under that.\n\nThe attacker can make another withdrawal request for this 1 wei, to make the `totalSupply` 0.\n\nNow, the attacker can claim the first withdraw request (because total supply is 0 again) and receive all the remaining assets in the vault, including the tokens that were transferred. This allows the attacker to take all of the second depositor's assets, while the second depositor loses all funds.\n\n\n1. User has 10,000 USDC of assets and the corresponding shares in the vault\n\n2. The user creates a withdrawal request,  withdrawRequestID = 1\n\n3. The user transfers 10,000 USDC to the vault \n\n4. The user deposits 1 wei and receives 1 share in return\n\n5. A victim deposits 5,000 USDC into the vault but receives 0 shares\n\n6. The user initiates a second withdrawal request, creating withdrawRequestID = 2\n\n7. The user then claims the withdrawal with withdrawRequestID = 1 and receives a profit of 5,000 USDC\n```\n  function claim(bytes32 withdrawRequestKey) public virtual returns (uint256) {\n    -- Snip -- \n        if (isLast) {\n            -- Snip -- \n            if (shortfall > 0) {\n               -- Snip -- \n            } else {\n                uint256 _idleAssets = idleAssets(); <= transfer transfered funds back to user       \n                executedAssets = withdrawRequest.requestedAssets + _idleAssets;\n                $.assetsToClaim += _idleAssets;\n            }\n        } else {\n            executedAssets = withdrawRequest.requestedAssets;\n        }\n        \n        $.assetsToClaim -= executedAssets;\n        IERC20(asset()).safeTransfer(withdrawRequest.receiver, executedAssets);\n        emit Claimed(withdrawRequest.receiver, withdrawRequestKey, executedAssets);\n        return executedAssets;\n    }\n```\n\n\n**Remediation:**  Possible remediation for this issue:\n\n- Revert Deposits with Zero Shares\n\n- Slippage Protection: Allow users to set a minimum share amount they wish to receive on deposit\n\n**Status:**   \n\n\n- - -",
    "summary": "\nThis bug report discusses a problem in the `claim` function of the `LogarithmVault` smart contract. The issue occurs when a user makes a withdrawal request and then transfers their tokens back to the vault, causing the total supply to go to zero. This allows an attacker to claim all of the remaining assets in the vault, including those that were transferred by the user. The report suggests two possible solutions to fix this issue: reverting deposits with zero shares and implementing slippage protection. The status of the issue is currently unknown.",
    "report_date": "2024-11-25T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2024-11-25-BasisOS.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "loglab-15-last-withdrawer-could-give-next-depositor-0-shares-hexens-none-basisos-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Basisos",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Basisos",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}