{
    "id": 62078,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 2159,
    "title": "[M-15] Edge case breaks APR cap calculation and leads to excessive fee extraction from the pool",
    "content": "\n\nIn the fee vault’s `update_rate` function, there’s an edge case that affects the calculation of target growth rate when the product of `100_000 * target_apr * time_elapsed` is less than `SECONDS_PER_YEAR` (31,536,000). Due to integer division, this calculation results in 0, making the target growth rate exactly equal to `SCALAR_12` (1.0).\n\nThis issue occurs under several conditions:\n\n* When `time_elapsed` is small (frequent updates)\n* When `target_apr` is low\n* Or when both conditions combine\n\nWhen this happens, the target growth rate becomes 1.0 (no growth), which effectively means the protocol will take 100% of any growth as fees, contrary to the expected behavior of only taking growth above the APR cap.\n\n### Impact\n\nThe protocol wouldn’t function as intended, considering we now have the vault extracting 100% of the interest as fees, despite having a non-zero APR cap configured which directly contradicts the intended economic model and also means leak of value for the depositors since more funds are extracted from the pool (`total_b_tokens`).\n\nAlso this tends more to active reserves which would have frequent interaction with `get_reserve_vault_updated()` (which happens during deposits, withdrawals, or position queries) will trigger an update with small time intervals, causing the protocol to take all interest.\n\n### Proof of Concept\n\nIn `fee-vault/src/reserve_vault.rs`, the problematic calculation occurs in the `update_rate` method:\n\n[`reserve_vault.rs# update_rate()`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/fee-vault/src/reserve_vault.rs# L86-L97)\n```\n\n// Target growth rate scaled in 12 decimals =\n// SCALAR_12 * (target_apr / SCALAR_7) * (time_elapsed / SECONDS_PER_YEAR) + SCALAR_12\nlet target_growth_rate =\n    100_000 * target_apr * (time_elapsed as i128) / SECONDS_PER_YEAR + SCALAR_12;\n\nlet target_b_rate = self\n    .b_rate\n    .fixed_mul_ceil(target_growth_rate, SCALAR_12)\n    .unwrap();\n\n// If the target APR wasn't reached, no fees are accrued\nif target_b_rate >= new_rate {\n    0\n} else {\n    // calculate fees\n}\n```\n\nFor example, with a 1% APR cap (`target_apr = 0_0100000`) and a X-second interval between updates, we get:\n```\n\n100_000 * target_apr * X = 100_000Xtarget_apr... here `100_000Xtarget_apr` < `SECONDS_PER_YEAR`\n100_000Xtarget_apr / 31,536,000 = 0 (integer division)\ntarget_growth_rate = 0 + SCALAR_12 = SCALAR_12 (1.0)\n```\n\nThis means the target growth rate becomes exactly 1.0 **(no growth)**, and when calculating `target_b_rate`:\n```\n\ntarget_b_rate = self.b_rate * SCALAR_12 / SCALAR_12 = self.b_rate\n```\n\nTherefore, `target_b_rate` equals the old rate with no allowed growth.\n\nThe consequence is seen in the fee calculation. Since `target_b_rate = self.b_rate`, whenever `new_rate > self.b_rate` (i.e., any positive growth), the protocol will take 100% of the growth as fees, contrary to the expected behavior of only taking growth above the APR cap:\n\n[`src/reserve_vault.rs# L96-L104`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/fee-vault/src/reserve_vault.rs# L96-L104):\n```\n\n            // If the target APR wasn't reached, no fees are accrued\n            if target_b_rate >= new_rate {\n                0\n            } else {\n                self.total_b_tokens\n                    .fixed_mul_floor(new_rate - target_b_rate, new_rate)\n                    .unwrap()\n            }\n```\n\nWould also be key to note that any function that calls [`get_reserve_vault_updated()`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/fee-vault/src/reserve_vault.rs# L139) which in turn calls [`update_rate()`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/fee-vault/src/reserve_vault.rs# L70) will trigger this issue under the right conditions.\n\n### Coded POC\n```\n\n#[cfg(test)]\nmod apr_capped_tests {\n    use super::*;\n    use crate::{\n        storage::FeeMode,\n        testutils::{assert_approx_eq_rel, mockpool, register_fee_vault, EnvTestUtils},\n    };\n-    use soroban_sdk::{testutils::{Address as _, , Address};\n+    use soroban_sdk::{testutils::{Address as _, LedgerInfo, Ledger}, Address};\n\n### ..snip\n\nfn test_update_rate_broken() {\n        let e = Env::default();\n        e.mock_all_auths();\n\n        let init_b_rate = 1_000_000_000_000; // 1.0 with 12 decimals\n        let bombadil = Address::generate(&e);\n\n        let mock_client = &mockpool::register_mock_pool_with_b_rate(&e, init_b_rate);\n\n        // Set up vault with APR capped mode and a 1% APR cap\n        let vault_address = register_fee_vault(\n            &e,\n            Some((\n                bombadil.clone(),\n                mock_client.address.clone(),\n                true, // APR capped mode\n                0_0100000, // 1% APR cap (0.01 with 7 decimals)\n            )),\n        );\n\n        e.as_contract(&vault_address, || {\n            // PART 1: Demonstrate the bug with a small time interval\n            let mut reserve_vault = ReserveVault {\n                address: Address::generate(&e),\n                total_b_tokens: 1000_0000000,\n                last_update_timestamp: e.ledger().timestamp(),\n                total_shares: 1000_0000000,\n                b_rate: init_b_rate,\n                accrued_fees: 0,\n            };\n\n            // Let's set a small time interval (30 seconds)\n            let initial_timestamp = e.ledger().timestamp();\n            let small_time_interval = 30; // 30 seconds\n\n            // Update the timestamp to be 30 seconds later\n            e.ledger().set(LedgerInfo {\n                timestamp: initial_timestamp + small_time_interval,\n                protocol_version: 22,\n                sequence_number: 100,\n                network_id: [0; 32],\n                base_reserve: 10,\n                min_temp_entry_ttl: 10,\n                min_persistent_entry_ttl: 10,\n                max_entry_ttl: 3110400,\n            });\n\n            // CRITICAL: Set new b_rate showing 0.005% growth (annualized to ~0.53% APR)\n            // This is BELOW the 1% APR cap, so NO fees should be taken\n            let new_b_rate = 1_000_050_000_000; // 1.00005 with 12 decimals (0.005% growth)\n            mockpool::set_b_rate(&e, mock_client, new_b_rate);\n\n            // Calculate what growth should be allowed by the APR cap\n            // 1% APR for 30 seconds = 1% * (30 / 31536000) = 0.0000095... which is very small\n            // This is approximately 0.00095% growth allowed\n            // Our actual growth is 0.005%, which is well UNDER the allowed growth\n            // Therefore NO fees should be taken\n\n            // But due to integer division in the target_growth_rate calculation:\n            // target_growth_rate = target_apr * time_elapsed / seconds_in_year + 1e12\n            // = 100_000 * 30 / 31_536_000 + 1e12\n            // = 0 (due to integer division) + 1e12 = 1e12\n            // target_b_rate = old_b_rate, meaning no growth is allowed\n\n            // Before the update\n            let before_total_b_tokens = reserve_vault.total_b_tokens;\n\n            // Perform the update\n            reserve_vault.update_rate(&e);\n\n            // After the update\n            let after_total_b_tokens = reserve_vault.total_b_tokens;\n            let fees_taken = before_total_b_tokens - after_total_b_tokens;\n\n            // Calculate what the fee would be if ALL growth is taken\n            // 0.005% growth on 1000_0000000 tokens = 0.05 * 1_0000000 = 0_0500000 tokens\n            // With properly working APR cap, the fees should be ZERO (since growth < APR cap)\n            // But due to the precision loss, ALL growth is taken as fees\n\n            // Assert that growth is taken as fees (bug case)\n            // This is wrong because growth is under the APR cap\n            assert!(fees_taken > 0);\n            assert!(reserve_vault.accrued_fees > 0);\n        });\n    }\n```\n\n\n```\n\ntest reserve_vault::apr_capped_tests::test_update_rate_broken ... ok\n\nsuccesses:\n\n---- reserve_vault::apr_capped_tests::test_update_rate_broken stdout ----\nWriting test snapshot file for test \"reserve_vault::apr_capped_tests::test_update_rate_broken\" to \"test_snapshots/reserve_vault/apr_capped_tests/test_update_rate_broken.1.json\".\n\nsuccesses:\n    reserve_vault::apr_capped_tests::test_update_rate_broken\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 43 filtered out; finished in 0.02s\n```\n\n### Recommended mitigation steps\n\nRevamp the fee accrual logic to take into account lower fee rates and/or frequent updates, since we can’t add a minimum time threshold for updates to prevent excessive fee extraction from very frequent small updates cause this then breaks the contracts as multiple transactions would fail on the call to `get_reserve_vault_updated()`\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-70?commentParent=PktoTT87mij):**\n\n> Validated this is a finding. This is separate from [S-353](https://code4rena.com/evaluate/2025-02-blend-v2-audit-certora-formal-verification/submissions/S-353).\n>\n> The interest math is likely not precise enough to handle small APRs / target APRs / and the minimum 5s update period, causing admin fees to not be withheld properly.\n>\n> Note that this does appear to work for typical higher interest assets (USDC/EURC/etc).\n\n**[LSDan (judge) decreased severity to Medium and commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-70?commentParent=PktoTT87mij&commentChild=NrQScgAvFHE):**\n\n> Agree that it is distinct from S-353, primarily due to impact and origin of the issue. This tracks as a valid medium to me.\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-70?commentParent=TNL96oUy2uP):**\n\n> <https://github.com/script3/fee-vault/pull/5/commits/a63d9a0c04fd7165ad7f49344faa0d60e0f85177>\n>\n> This won’t be fixed. Unit tests were added to ensure the edge cases behaved as expected. Essentially, there always can be cases where, due to rounding, the admin gets 0 fees.\n>\n> This gets more likely the less `b_tokens` that are being held by the vault, with low interest rate / low IR cases being able to scrape admin fees within a 5s interval at 1,000 `b_tokens`.\n>\n> Thus, this isn’t an exploitable issue, given spamming this does not cause any fund loss, only less fees get taken from the users pool of funds. If a user wants to deny an admin fees, they will be paying significantly more in TX fees than the total rounding loss for the admin, which they would only be eligible for part of.\n\n---\n\n",
    "summary": "\nThe fee vault's `update_rate` function has an issue where the target growth rate becomes 1.0 (no growth) when the product of `100_000 * target_apr * time_elapsed` is less than `SECONDS_PER_YEAR` (31,536,000). This happens when `time_elapsed` is small, `target_apr` is low, or both. This means the protocol will take 100% of any growth as fees, instead of only taking growth above the APR cap. This affects the intended economic model and can result in a loss of value for depositors. A proof of concept and recommended mitigation steps are provided in the report. The severity of this issue has been marked as Medium.",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-70",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-15-edge-case-breaks-apr-cap-calculation-and-leads-to-excessive-fee-extraction-from-the-pool-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Sparrow"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}