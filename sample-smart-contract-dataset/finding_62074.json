{
    "id": 62074,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 2159,
    "title": "[M-11] Fee-vault can be made insolvent in case of defaults",
    "content": "\n\n<https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/fee-vault/src/contract.rs# L310-L311>\n\n<https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/fee-vault/src/reserve_vault.rs# L72-L74>\n\n### Finding description and impact\n\nIn case of a loan default, the backstop funds are insufficient to cover the liability. In this case, the hit is taken by the collateral providers, and the `b_rate` drops.\n```\n\npub fn default_liabilities(&mut self, e: &Env, reserve: &mut Reserve, amount: i128) {\n    self.remove_liabilities(e, reserve, amount);\n    // determine amount of funds in underlying that have defaulted\n    // and deduct them from the b_rate\n    let default_amount = reserve.to_asset_from_d_token(e, amount);\n    let b_rate_loss = default_amount.fixed_div_ceil(&e, &reserve.data.b_supply, &SCALAR_12);\n    reserve.data.b_rate -= b_rate_loss;\n```\n\nIn this scenario, the `b_rate` of the token is reduced. This creates a situation in the fee vault which can lead to insolvency.\n\nThe fee-vault, during deposits and withdrawals, calls `update_rate` to make sure it has the latest `b_rate` from the pool.\n```\n\nlet now = e.ledger().timestamp();\nif now == self.last_update_timestamp {\n    return;\n}\n\nlet new_rate = pool::reserve_b_rate(e, &self.address);\nif new_rate == self.b_rate {\n    self.last_update_timestamp = now;\n    return;\n}\n```\n\nHowever, as can be seen above, there is an escape condition where the `b_rate` is not updated if the timestamp is the same. This can trigger when there are two transactions that are executed in the same block. In that case, the `b_rate` is not updated and the older value is used.\n\nThis is not an issue in general operations, because `b_rate` cannot change within the same block. However, in the case of a default, the `b_rate` can change within the same block. So the `fee_vault` can be made to use an outdated `b_rate`.\n\nImagine a situation where 3 transactions are bundled together in the same block:\n\n1. tx 1 - a simple deposit to the fee vault\n2. tx 2 - a liquidation causing a default\n3. tx 3 - a withdrawal from the fee vault\n\nTx 1 updates the `b_rate` of the vault to the one in the pool. Tx 2 drops the `b_rate` in the pool, but the one in the vault remains the same. Tx 3 uses the outdated higher `b_rate` to calculate withdrawal amounts, since tx1 was in the same block so `now == self.last_update_timestamp` check passes. Since a higher `b_rate` is used, the fee vault ends up burning more b\\_tokens than it expects, leading to insolvency.\n\nLets assume the `b_rate` drops from 1.1 to 1.05. In tx 3, the vault still uses 1.1, but the pool uses `1.05`. Say a user wants to withdraw 1000 amount from the vault. The `pool::withdraw(&e, &reserve, &user, amount);` call will burn `1000/1.05=953` `b_tokens` from the vault. But in the vaults `withdraw` function, the `b_tokens_amount` will be calculated as `1000/1.1=910`. So the `vault.total_b_tokens` will be reduced by 910, but the pool will burn 953 btokens from the vault. So no there is a deficit of 43 `b_tokens` in the vault, which leads to the insolvency for the user who exits last.\n```\n\nlet b_tokens_amount = vault.underlying_to_b_tokens_up(amount); //@audit older b_rate used\n\nlet mut user_shares = storage::get_reserve_vault_shares(e, &vault.address, user);\nlet share_amount = vault.b_tokens_to_shares_up(b_tokens_amount);\nrequire_positive(e, share_amount, FeeVaultError::InvalidBTokensBurnt);\n\nif vault.total_shares < share_amount || vault.total_b_tokens < b_tokens_amount {\n    panic_with_error!(e, FeeVaultError::InsufficientReserves);\n}\n\nif share_amount > user_shares {\n    panic_with_error!(e, FeeVaultError::BalanceError);\n}\nvault.total_shares -= share_amount;\nvault.total_b_tokens -= b_tokens_amount; //@audit reducing by incorrect amount\n```\n\nAll three transactions above can be sent by the same person, bundled together, removing the MEV necessity.\n\n### Proof of Concept\n\nSay the default reduces the `b_rate` from 1.1 to 1.05. During withdrawal, the pool has a `b_rate` of 1.05, but the vault has a `b_rate` of 1.1.\n\nThus, when withdrawing 1000, the pool will burn `1000/1.05=953` `b_tokens`, but the vault will burn `1000/1.1=910` `b_tokens`. This leads to a deficit of 43 `b_tokens` in the vault, which leads to insolvency for the user who exits last.\n\n### Recommended mitigation steps\n\nUpdate the rate even if the timestamp matches.\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-50?commentParent=WCdtPKYQ2h5):**\n\n> Validated this is a finding. The execution of this is extremely edge case, as A (the backstop needs to hit the doomsday scenario of running out of funds), and B, you have to win the bad debt auction to bundle the exploit pathway correctly in one contract call.\n>\n> However, it doesnâ€™t seem like there is a way to extract funds here. An attacker would need to already be using the fee vault, and use the exploit to avoid losing funds, at the expense of the last withdrawer.\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-50?commentParent=sqFsjGGyfxE):**\n\n> Fixed to load `b_rate` from chain every time, and update the internal vault every time.\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [Commit a63d9a0](https://github.com/script3/fee-vault/commit/a63d9a0c04fd7165ad7f49344faa0d60e0f85177) to patch `b_rate` loss sandwhich issue.\n\n**Status:** Mitigation confirmed. Full details in reports from [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-55), [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-27), [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-4) and [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-73).\n\n---\n\n",
    "summary": "\nThis bug report discusses an issue with the fee vault in a blockchain project. The problem occurs when there is a loan default and the backstop funds are not enough to cover the liability. This leads to a decrease in the token's b_rate, which can cause insolvency in the fee vault. The issue is caused by an escape condition in the fee vault's code, which prevents the b_rate from being updated if there are multiple transactions in the same block. This can result in the fee vault using an outdated b_rate and burning more tokens than expected, leading to insolvency. The report includes a proof of concept and recommends updating the code to fix the issue. The project team has confirmed and fixed the issue in their code. ",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-50",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-11-fee-vault-can-be-made-insolvent-in-case-of-defaults-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "0x007"
            }
        },
        {
            "wardens_warden": {
                "handle": "carrotsmuggler"
            }
        },
        {
            "wardens_warden": {
                "handle": "YouCrossTheLineAlfie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Tigerfrake"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}