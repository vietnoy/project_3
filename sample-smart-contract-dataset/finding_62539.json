{
    "id": 62539,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 3420,
    "title": "[H-02] Insufficient restrictions in `instantOpenPacket()` risk DOS",
    "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n## Description\n\nIn `Packet.sol` a user can call `initiateBurn` with `params.BurnType` set to `BurnType.INSTANT_OPEN_PACKET`.\n```solidity\n        if (params.burnType == BurnType.INSTANT_OPEN_PACKET) {\n            randomAllocationPool.instantOpenPacket(params.packetId, _packetTypeIds[params.packetId], msg.sender);\n        }\n```\nThis will result in the function calling `instantOpenPacket` on the `CardAllocationPool` contract. \n\n```solidity\n    function instantOpenPacket(uint256 packetId, uint256 packetType, address owner) external {\n        if (msg.sender != packetNFTAddress) revert UnauthorizedCaller();\n\n        if (packetTypeToCardBundles[packetType].length == 0) revert InsufficientCardBundles();\n\n        // Request randomness from Chainlink VRF\n        uint256 requestId = requestRandomWords(packetType);\n\n        requestIdToPacketOpen[requestId] =\n            PacketOpenRequest({packetId: packetId, packetType: packetType, owner: owner, fulfilled: false});\n```\nThe function will first check  that the msg.sender is in fact the `packetNFTAdress` next the logic ensures there is enough cardBundles of the specific type to fulfill the request otherwise the function will revert with `insufficientCardBundles`.\nFinally a call to `requestRandomWords` is made and the `requestId` assigned. \n\nWhen the chainlink VRF finally delivers the random values, it will call `selectRandomCards` using the random values. \n```solidity\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal {\n        PacketOpenRequest storage request = requestIdToPacketOpen[requestId];\n        if (request.fulfilled) revert(\"Already fulfilled\");\n\n        // fetch the available card bundles\n        CardBundle[] storage cardBundles = packetTypeToCardBundles[request.packetType];\n\n        // Select random cards using the provided randomness\n        uint256[] memory selectedCards = selectRandomCards(cardBundles, randomWords[0]);\n```\n\nThis is where the issue begins...\n\n```solidity\n    function selectRandomCards(CardBundle[] storage availableCardBundles, uint256 randomSeed)\n        private\n        returns (uint256[] memory selectedCardBundle)\n    {\n        if (availableCardBundles.length == 0) {\n            revert NoAvailableCardBundles();\n        }\n```\nIf `availableCardBundles.length` == 0 we will revert, this a problem, let me explain below.\n\n1. 2 users call `initiateBurn` on `Packet.sol` with `BurnType` == `INSTANT_OPEN_PACKET` in the same block, both requests are of the same `packetType`.\n2. Assume there is only 1 bundle left of the specific `packetType`, the checks in `instantOpenPacket` will pass for both users even if there is only 1 bundle left for the specific `packetType`.\n3. Next both users will be assigned a `requestId` and will be waiting for chainlink to `fulfillRandomWords`\n4. When `fulfillRandomWords` is called there is an internal call to `selectRandomCards` this function will pop the only value from `availableCardBundles`, user 1 will receive his cards as intended.\n5. when `fulfillRandomWords` is called for user 2, there will be a revert in `fulfillRandomWords` subcall to `selectRandomCards` because `availableCardsBundles.length` will == 0 and thus revert the entire tx.\n6. Since `fulfillRandomWords` reverts, this will cause the request to be dosed according to chainlink docs\n> If your fulfillRandomWords() implementation reverts, the VRF service will not attempt to call it a second time. Make sure your contract logic does not revert. Consider simply storing the randomness and taking more complex follow-on actions in separate contract calls made by you, your users, or an Automation Node.\n\n## Recommendations\n\nConsider adding checks in `instantOpenPacket` to ensure more requests cannot be made than the amount of `cardBundles` available for a specific `packetType`.\n\n\n\n",
    "summary": "\nThis bug report discusses an issue with the `initiateBurn` function in the `Packet.sol` contract. When a user calls this function with `BurnType` set to `INSTANT_OPEN_PACKET`, it will call the `instantOpenPacket` function on the `CardAllocationPool` contract. However, there is a problem with the `selectRandomCards` function within this contract. If there is only one bundle left for a specific `packetType`, and two users call `initiateBurn` at the same time, the first user will receive their cards as intended but the second user will encounter a revert error and not receive their cards. This is because the `selectRandomCards` function will pop the only value from `availableCardBundles` and cause the transaction to fail. The report recommends adding checks in the `instantOpenPacket` function to prevent more requests from being made than the available bundles for a specific `packetType`. ",
    "report_date": "2025-09-11T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/RipIt-security-review_2025-04-25.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "h-02-insufficient-restrictions-in-instantopenpacket-risk-dos-pashov-audit-group-none-ripit_2025-04-25-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "RipIt_2025-04-25",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "RipIt_2025-04-25",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}