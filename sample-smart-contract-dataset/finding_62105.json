{
    "id": 62105,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3050,
    "title": "M-7: A malicious operator will control consensus without risking stake (stake-exit lag exploit)",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-symbiotic-relay-judging/issues/446 \n\nThis issue has been acknowledged by the team but won't be fixed at this time.\n\n## Found by \n0x73696d616f, hunt1, montecristo\n\n### Summary\n\nThe non-atomic nature of `setSigVerifier` and `commitValSetHeader` will cause a potential loss of security guarantees for networks as a malicious operator can manipulate validator sets after unstaking their funds, avoiding slashing penalties.\n\n### Root Cause\n\nIn `Settlement` contract the design choice to separate `setSigVerifier` and `commitValSetHeader` functions (latter being public) is a mistake as it allows for a time gap between validator selection and header commitment. This creates a window where an operator can withdraw their stake while still maintaining their voting power.\n\nSpecifically, `commitValSetHeader` in `Settlement` is marked as public:\n\nhttps://github.com/sherlock-audit/2025-06-symbiotic-relay/blob/main/middleware-sdk/src/contracts/modules/settlement/Settlement.sol#L292-L324\n\nWhile `setSigVerifier` is a separate function:\n\nhttps://github.com/sherlock-audit/2025-06-symbiotic-relay/blob/main/middleware-sdk/src/contracts/modules/settlement/Settlement.sol#L267-L275\n\n### Attack Path\n\nEpoch 1:\n\n1. A malicious operator deposits a large amount of stake to their vault, ensuring it exceeds the `quorumThreshold` for voting power.\n2. The off-chain relay calculates voting powers, creates a `sigVerifier` using validators belonging to the malicious operator, and calls `setSigVerifier` to assign these validators for the next epoch.\n3. Near the end of Epoch, the operator calls `withdraw` on their vault to initiate the withdrawal of their stake.\n\nEpoch 2:\n\n1. The operator immediately calls `claim` on their vault to retrieve all their withdrawn stake, effectively removing their financial exposure.\n2. Despite having withdrawn their stake, their voting power is active in the system's state for a short time-span.\n3. The operator can craft their own proof using their validators' private keys, which will pass verification since they had enough voting power.\n4. When the operator submits this crafted proof to `commitValSetHeader`, it will be accepted by the system, allowing the operator to control consensus without any stake at risk.\n\n### Impact\n\nThe network suffers a complete compromise of its security model. The malicious operator can perform any validator action (such as approving invalid transactions or censoring valid ones) without having any stake at risk of being slashed. This fundamentally breaks the economic security assumptions of the protocol, which relies on validators having skin in the game to behave honestly.\n\n### Mitigation\n\nRedesign the `commitValSetHeader` function to be internal (`_commitValSetHeader`), and create a new public function that handles both setting the signature verifier (optional) and committing the header in a single atomic transaction.\n\nAlternatively apply `checkPermission` to `commitValSetHeader` so it can only be executed by the Network's relay service.\n\n\n\nSource: https://github.com/sherlock-audit/2025-06-symbiotic-relay-judging/issues/452 \n\n## Found by \n0x73696d616f, vinica\\_boy\n\n### Summary\n\nA malicious operator with any voting power (considering a minimum inclusion voting power if present) smaller than the quorum can forge a proof and bypass verification, setting the next epoch header to any value, taking over the network.\nFirstly, in `circuit.go`, operators with keys X, Y equal to 0 are not part of the validator set hash and are [skipped](https://github.com/sherlock-audit/2025-06-symbiotic-relay/blob/main/middleware-sdk/pkg/proof/circuit.go#L94-L98) whenever they are last.\n```go\n\t\tvalsetHash = api.Select(\n\t\t\tapi.And(fieldFpApi.IsZero(&circuit.ValidatorData[i].Key.X), fieldFpApi.IsZero(&circuit.ValidatorData[i].Key.Y)),\n\t\t\tvalsetHash,\n\t\t\tvalsetHashTemp,\n\t\t)\n```\nThe reason the X = 0, Y = 0 operators need to be last to be skipped, is because the `valsetHash` takes the temp value when the key is not null. Hence, if we have an empty key (0,0), followed by a non empty key,  valsetHash will take the value of valsetHashTemp again, which includes the full mimc hash, which is cumulative:\n```go\n\t\thashAffineG1(&mimcApi, &circuit.ValidatorData[i].Key)\n\t\tmimcApi.Write(circuit.ValidatorData[i].VotingPower)\n\t\tvalsetHashTemp := mimcApi.Sum()\n```\nHence, for this to work, the operators must be sent as [OP1, ..., OPn, (0,0)], so `valsetHash` takes the hash of the set up until OPn. It needs to exclude the (0,0) key from the validator set because the MIMC hash is checked against the real hash, which doesn't contain this (0,0) key.\n\nNow, the (0,0) key is not a real operator, so their voting power contribution must be 0. However, it's actually possible to set any voting power (up until var size constraints), exceeding the quorum, of this fake (0,0) validator, and the proof still goes through.\n\nThe `IsNonSigner` flag is set to false of this (0,0) validator, so the voting power counts. As a result, their (0,0) key is also added to the signing aggregated key. However, the null (0,0) key point property is that its addition to the aggregate key has no effect, which means that effectively no signature is required from the null (0,0) key. Thus, having validators [OP1, ..., OPn, (0,0)], with an aggregated signature of validators 1 to n, will pass the signature verification.\n\nThis effectively means that any operator with any minimal voting power can add this (0,0) operator with a voting power that exceeds the quorum and lets the message go through. As a result, they can manipulate whatever data they want and take full control of the network, more precisely the valSetHeader for the next epoch in `Settlement.sol`, fully compromising the network.\n\n### Root Cause\n\nIn `circuit.go:101`, the voting power of an operator with null key must be null.\n\n### Internal Pre-conditions\n\nNone\n\n### External Pre-conditions\n\nNone\n\n### Attack Path\n\n1. Operator with 1 voting power (or any minimal amount) calls `Settlement::commitValSetHeader()` with a malicious header for next epoch to compromise the network. They send a proof with only them as signer, all other operators are non signers and add at the end a null operator (0,0) with voting power bigger than the quorum.\n\n### Impact\n\nNetwork is compromised and attacker can do whatever they want. Operator role is permissionless for some networks (depending on extensions) and even if it wasn't, they would still be able to completely bypass the quorum which is high severity.\n\n### PoC\n\nChange `proof_test.go` to:\n```go\nfunc genValset(numValidators int, nonSigners []int) []ValidatorData {\n\tvalset := make([]ValidatorData, numValidators)\n\tfor i := 0; i < numValidators; i++ {\n\t\tpk := big.NewInt(int64(i + 1000000000000000000))\n\t\tvalset[i].PrivateKey = pk\n\t\tvalset[i].Key = getPubkeyG1(pk)\n\t\tvalset[i].KeyG2 = getPubkeyG2(pk)\n\t\tvalset[i].VotingPower = big.NewInt(1) // this has to be the real voting power of the rest of the set but it doesn't really matter for this poc as they won't sign. Only validator i == 0 is signing.\n\t\tvalset[i].IsNonSigner = false\n\t\tif i != 0 {\n\t\t\tvalset[i].IsNonSigner = true\n\t\t}\n\t}\n\n\tfor _, nonSigner := range nonSigners {\n\t\tvalset[nonSigner].IsNonSigner = true\n\t}\n\n\treturn valset\n}\n```\n\nChange `helpers.go` to the following. Note that n is 11 (set has length 10) to add the null key (0,0).\n```go\nfunc NormalizeValset(valset []ValidatorData) []ValidatorData {\n\t// Sort validators by key in ascending order\n\tsort.Slice(valset, func(i, j int) bool {\n\t\t// Compare keys (lower first)\n\t\treturn valset[i].Key.X.Cmp(&valset[j].Key.X) < 0 || valset[i].Key.Y.Cmp(&valset[j].Key.Y) < 0\n\t})\n\tn := 11 //getOptimalN(len(valset))\n\tnormalizedValset := make([]ValidatorData, n)\n\tfor i := range n {\n\t\tif i < len(valset) {\n\t\t\tnormalizedValset[i] = valset[i]\n\t\t} else {\n\t\t\tzeroPoint := new(bn254.G1Affine)\n\t\t\tzeroPoint.SetInfinity()\n\t\t\tzeroPointG2 := new(bn254.G2Affine)\n\t\t\tzeroPointG2.SetInfinity()\n\t\t\tnormalizedValset[i] = ValidatorData{PrivateKey: big.NewInt(0), Key: *zeroPoint, KeyG2: *zeroPointG2, VotingPower: big.NewInt(30000000000000 * 10), IsNonSigner: false}\n\t\t}\n\t}\n\treturn normalizedValset\n}\n```\n\nIn `proof.go` set `MaxValidators = []int{11}`. If the 3 verifiers 10, 100, 1000 were used this wouldn't be needed but the current commit defaults to 10 only and it's easier to allow 11 for this POC.\n\nGo to `pkg/proof` and run `go test .`, it passes with 1 real voting power.\n\n### Mitigation\n\nIf the key is null, voting power must be null.\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/symbioticfi/relay-contracts/pull/33/commits/8d0d70bd47afa5029a0cf72ef82c49754fd2201c\n\n\n\n\n\n",
    "summary": "\nThis bug report discusses a potential vulnerability in the `Settlement` contract of the Symbiotic Relay protocol. The issue was identified by three individuals and has been acknowledged by the team, but will not be fixed at this time. \n\nThe root cause of the vulnerability is the non-atomic nature of the `setSigVerifier` and `commitValSetHeader` functions, which allows for a time gap between validator selection and header commitment. This creates a window where a malicious operator can withdraw their stake while still maintaining their voting power, and manipulate the validator set without risking any penalties. \n\nThe attack path involves a malicious operator depositing a large amount of stake and using their voting power to manipulate the validator set. They can then withdraw their stake and still have their voting power active in the system for a short time. By crafting their own proof and submitting it to the `commitValSetHeader` function, they can take control of the network without having any stake at risk. \n\nThe impact of this vulnerability is a complete compromise of the network's security model, as the malicious operator can perform any validator action without risking any penalties. This goes against the economic security assumptions of the protocol, which relies on validators having skin in the game to behave honestly. \n\nTo mitigate this issue, the team suggests redesigning the `commitValSetHeader` function to be internal and creating a new public function that handles both setting the signature verifier and committing the header in a single atomic transaction. Alternatively, they recommend applying `checkPermission` to `commitValSetHeader` so it can only be executed by the network's relay service. \n\nThe team has fixed this issue in the protocol's code base, and the bug has been discussed and tested by the community. ",
    "report_date": "2025-07-10T15:00:00.000Z",
    "contest_prize_txt": "100000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/967",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-symbiotic-relay-judging/issues/452",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "967",
    "slug": "m-7-a-malicious-operator-will-control-consensus-without-risking-stake-stake-exit-lag-exploit-sherlock-symbiotic-relay-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Symbiotic Relay",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "0x73696d616f"
            }
        },
        {
            "wardens_warden": {
                "handle": "hunt1"
            }
        },
        {
            "wardens_warden": {
                "handle": "vinica\\_boy"
            }
        },
        {
            "wardens_warden": {
                "handle": "montecristo"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Symbiotic Relay",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}