{
    "id": 62532,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3373,
    "title": "[M-04] Yield withdrawal blocked by zero reward early return",
    "content": "\n\n<https://github.com/code-423n4/2025-08-morpheus/blob/a65c254e4c3133c32c05b80bf2bd6ff9eced68e2/contracts/capital-protocol/Distributor.sol# L346>\n\n<https://github.com/code-423n4/2025-08-morpheus/blob/a65c254e4c3133c32c05b80bf2bd6ff9eced68e2/contracts/capital-protocol/Distributor.sol# L482-L483>\n\n### Finding Description and Impact\n\nWhen withdrawing yield, it is calculated as the [difference](https://github.com/code-423n4/2025-08-morpheus/blob/a65c254e4c3133c32c05b80bf2bd6ff9eced68e2/contracts/capital-protocol/Distributor.sol# L482-L483) between `lastUnderlyingBalance` and `deposited` for the given `depositPool`. The `lastUnderlyingBalance` is [updated](https://github.com/code-423n4/2025-08-morpheus/blob/a65c254e4c3133c32c05b80bf2bd6ff9eced68e2/contracts/capital-protocol/Distributor.sol# L384-L389) in `distributeRewards()` to reflect the current token balance, which includes accumulated yield. However, this function returns early when the calculated `rewards_` amount for the period between `lastCalculatedTimestamp_` and `block.timestamp` is zero:\n```\n\nuint256 rewards_ = IRewardPool(rewardPool).getPeriodRewards(\n    rewardPoolIndex_,\n    lastCalculatedTimestamp_,\n    uint128(block.timestamp)\n);\nif (rewards_ == 0) return;\n```\n\n<https://github.com/code-423n4/2025-08-morpheus/blob/a65c254e4c3133c32c05b80bf2bd6ff9eced68e2/contracts/capital-protocol/Distributor.sol# L340-L346>\n\nThis prevents `lastUnderlyingBalance` from being updated when `rewards_` is zero, causing the accounting system to fail to recognize newly accumulated yield and making it impossible to withdraw.\n\nRewards are only calculated up to the [maxEndTime](https://github.com/code-423n4/2025-08-morpheus/blob/a65c254e4c3133c32c05b80bf2bd6ff9eced68e2/contracts/libs/LinearDistributionIntervalDecrease.sol# L36-L40), which represents when reward distribution for a given pool ends completely. After this point, no more rewards are distributed from that pool.\n\nWhen `getPeriodRewards()` returns zero for any period after `maxEndTime`, it will permanently return zero for all future periods. This means `distributeRewards()` will always return early without updating `lastUnderlyingBalance`, creating a permanent lock on any yield that accumulated since `lastCalculatedTimestamp_` and any yield that accumulates after the reward distribution period ends.\n\nThe problem is particularly severe because:\n\n1. Users can remain staked after `maxEndTime` and their tokens continue generating yield\n2. The yield accounting becomes permanently broken once rewards end\n3. All yield generated after `maxEndTime` becomes permanently inaccessible\n4. This affects the entire deposit pool, not just individual users\n\nIf `lastCalculatedTimestamp_ == maxEndTime - 100`, `getPeriodRewards(rewardPoolIndex_, lastCalculatedTimestamp_, maxEndTime) == 0`, and `yield == 10e18` during that time, this yield amount will be permanently stuck. Any continuing yield accumulation after `maxEndTime` will also become unwithdrawable.\n\n### Recommended Mitigation Steps\n\nImplement functionality that allows withdrawing yield even when no rewards accrue. For example:\n\n1. Add a mechanism to update `lastUnderlyingBalance` independent of reward calculations\n2. Implement a fallback method for yield withdrawal after reward distribution ends\n\n### Proof of Concept\n\nAdd the following file to `./test/` and run `npx hardhat test --grep \"should show yield stuck\"`\n```\n\nimport { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers';\nimport { expect } from 'chai';\nimport { ethers } from 'hardhat';\n\nimport {\n  AavePoolDataProviderMock,\n  AavePoolMock,\n  ArbitrumBridgeGatewayRouterMock, // Mock contracts\n  ChainLinkAggregatorV3Mock,\n  ChainLinkDataConsumer,\n  DepositPool,\n  Distributor,\n  ERC20Token,\n  IDepositPool,\n  IL1SenderV2,\n  IL2TokenReceiverV2, // Interfaces\n  IRewardPool,\n  L1SenderV2,\n  L2MessageReceiver,\n  L2TokenReceiverV2,\n  LayerZeroEndpointV2Mock,\n  MOR,\n  MOROFT,\n  NonfungiblePositionManagerMock,\n  RewardPool,\n  StETHMock,\n  UniswapSwapRouterMock,\n  WStETHMock,\n} from '@/generated-types/ethers';\nimport { PRECISION, ZERO_ADDR } from '@/scripts/utils/constants';\nimport { wei } from '@/scripts/utils/utils';\nimport { getCurrentBlockTime, setNextTime, setTime } from '@/test/helpers/block-helper';\nimport { Reverter } from '@/test/helpers/reverter';\n\ndescribe('Morpheus Capital Protocol - POC Test Suite', function () {\n  // Signers\n  let owner: SignerWithAddress;\n  let alice: SignerWithAddress;\n  let bob: SignerWithAddress;\n  let charlie: SignerWithAddress;\n  let treasury: SignerWithAddress;\n  let referrer1: SignerWithAddress;\n  let referrer2: SignerWithAddress;\n\n  // Core Capital Protocol Contracts\n  let chainLinkDataConsumer: ChainLinkDataConsumer;\n  let depositPool: DepositPool;\n  let distributor: Distributor;\n  let l1Sender: L1SenderV2;\n  let l2TokenReceiver: L2TokenReceiverV2;\n  let rewardPool: RewardPool;\n\n  // Mock Contracts and Dependencies\n  let aavePool: AavePoolMock;\n  let aavePoolDataProvider: AavePoolDataProviderMock;\n  let stETH: StETHMock;\n  let wstETH: WStETHMock;\n  let depositToken: ERC20Token;\n  let rewardToken: ERC20Token;\n  let mor: MOR;\n  let morOft: MOROFT;\n  let swapRouter: UniswapSwapRouterMock;\n  let nonfungiblePositionManager: NonfungiblePositionManagerMock;\n  let arbitrumBridge: ArbitrumBridgeGatewayRouterMock;\n  let lzEndpointL1: LayerZeroEndpointV2Mock;\n  let lzEndpointL2: LayerZeroEndpointV2Mock;\n  let l2MessageReceiver: L2MessageReceiver;\n\n  // Price Feed Mocks\n  let ethUsdFeed: ChainLinkAggregatorV3Mock;\n  let btcUsdFeed: ChainLinkAggregatorV3Mock;\n  let wbtcBtcFeed: ChainLinkAggregatorV3Mock;\n\n  // Test Constants\n  const oneDay = 86400;\n  const oneHour = 3600;\n  const publicRewardPoolId = 0;\n  const privateRewardPoolId = 1;\n  const l1ChainId = 101;\n  const l2ChainId = 110;\n\n  // Reverter for test isolation\n  const reverter = new Reverter();\n\n  // Enums\n  enum Strategy {\n    NONE, // Direct deposit, no yield\n    NO_YIELD, // No yield strategy (private pools)\n    AAVE, // Aave yield strategy\n  }\n\n  // Helper Functions\n  async function deployERC20Token(): Promise<ERC20Token> {\n    const factory = await ethers.getContractFactory('ERC20Token');\n    return await factory.deploy();\n  }\n\n  async function deployMocks() {\n    // Deploy price feed mocks\n    const aggregatorFactory = await ethers.getContractFactory('ChainLinkAggregatorV3Mock');\n    ethUsdFeed = await aggregatorFactory.deploy(18);\n    btcUsdFeed = await aggregatorFactory.deploy(8);\n    wbtcBtcFeed = await aggregatorFactory.deploy(8);\n\n    // Set initial prices\n    await ethUsdFeed.setAnswerResult(wei(2000, 18)); // $2000/ETH\n    await btcUsdFeed.setAnswerResult(wei(40000, 8)); // $40000/BTC\n    await wbtcBtcFeed.setAnswerResult(wei(1, 8)); // 1:1 WBTC/BTC\n\n    // Deploy Aave mocks\n    const aaveDataProviderFactory = await ethers.getContractFactory('AavePoolDataProviderMock');\n    aavePoolDataProvider = await aaveDataProviderFactory.deploy();\n\n    const aavePoolFactory = await ethers.getContractFactory('AavePoolMock');\n    aavePool = await aavePoolFactory.deploy(aavePoolDataProvider);\n\n    // Deploy token mocks\n    const stETHFactory = await ethers.getContractFactory('StETHMock');\n    stETH = await stETHFactory.deploy();\n\n    const wstETHFactory = await ethers.getContractFactory('WStETHMock');\n    wstETH = await wstETHFactory.deploy(stETH);\n\n    depositToken = await deployERC20Token();\n    rewardToken = await deployERC20Token();\n\n    const morFactory = await ethers.getContractFactory('MOR');\n    mor = await morFactory.deploy(wei(1000000)); // 1M initial supply\n\n    // Deploy swap router mocks\n    const swapRouterFactory = await ethers.getContractFactory('UniswapSwapRouterMock');\n    swapRouter = await swapRouterFactory.deploy();\n\n    const nftManagerFactory = await ethers.getContractFactory('NonfungiblePositionManagerMock');\n    nonfungiblePositionManager = await nftManagerFactory.deploy();\n\n    // Deploy bridge mocks\n    const bridgeFactory = await ethers.getContractFactory('ArbitrumBridgeGatewayRouterMock');\n    arbitrumBridge = await bridgeFactory.deploy();\n\n    // Deploy LayerZero mocks\n    const lzFactory = await ethers.getContractFactory('LayerZeroEndpointV2Mock');\n    lzEndpointL1 = await lzFactory.deploy(l1ChainId, owner.address);\n    lzEndpointL2 = await lzFactory.deploy(l2ChainId, owner.address);\n\n    // Deploy L2MessageReceiver mock (if needed for L1Sender tests)\n    const l2MessageReceiverFactory = await ethers.getContractFactory('L2MessageReceiver');\n    const l2MessageReceiverImpl = await l2MessageReceiverFactory.deploy();\n    const proxyFactory = await ethers.getContractFactory('ERC1967Proxy');\n    const l2MessageReceiverProxy = await proxyFactory.deploy(l2MessageReceiverImpl, '0x');\n    l2MessageReceiver = l2MessageReceiverFactory.attach(l2MessageReceiverProxy) as L2MessageReceiver;\n    await l2MessageReceiver.L2MessageReceiver__init();\n  }\n\n  async function deployCapitalProtocol() {\n    // 1. Deploy ChainLinkDataConsumer\n    const chainLinkFactory = await ethers.getContractFactory('ChainLinkDataConsumer');\n    const chainLinkImpl = await chainLinkFactory.deploy();\n    const proxyFactory = await ethers.getContractFactory('ERC1967Proxy');\n    const chainLinkProxy = await proxyFactory.deploy(await chainLinkImpl.getAddress(), '0x');\n    chainLinkDataConsumer = chainLinkFactory.attach(await chainLinkProxy.getAddress()) as ChainLinkDataConsumer;\n    await chainLinkDataConsumer.ChainLinkDataConsumer_init();\n\n    // Setup price feeds\n    await chainLinkDataConsumer.updateDataFeeds(\n      ['ETH/USD', 'wBTC/BTC,BTC/USD'],\n      [[await ethUsdFeed.getAddress()], [await wbtcBtcFeed.getAddress(), await btcUsdFeed.getAddress()]],\n    );\n\n    // 2. Deploy RewardPool (with library linking)\n    const linearDistributionLib = await (\n      await ethers.getContractFactory('LinearDistributionIntervalDecrease')\n    ).deploy();\n    const rewardPoolFactory = await ethers.getContractFactory('RewardPool', {\n      libraries: {\n        LinearDistributionIntervalDecrease: await linearDistributionLib.getAddress(),\n      },\n    });\n    const rewardPoolImpl = await rewardPoolFactory.deploy();\n    const rewardPoolProxy = await proxyFactory.deploy(await rewardPoolImpl.getAddress(), '0x');\n    rewardPool = rewardPoolFactory.attach(await rewardPoolProxy.getAddress()) as RewardPool;\n\n    const pools: IRewardPool.RewardPoolStruct[] = [\n      {\n        payoutStart: oneDay,\n        decreaseInterval: oneDay,\n        initialReward: 10000000,\n        rewardDecrease: 1000000,\n        isPublic: true,\n      },\n      {\n        payoutStart: oneDay * 20,\n        decreaseInterval: oneDay * 2,\n        initialReward: wei(200),\n        rewardDecrease: wei(1),\n        isPublic: false,\n      },\n    ];\n    await rewardPool.RewardPool_init(pools);\n\n    // 3. Deploy L1SenderV2\n    const l1SenderFactory = await ethers.getContractFactory('L1SenderV2');\n    const l1SenderImpl = await l1SenderFactory.deploy();\n    const l1SenderProxy = await proxyFactory.deploy(await l1SenderImpl.getAddress(), '0x');\n    l1Sender = l1SenderFactory.attach(await l1SenderProxy.getAddress()) as L1SenderV2;\n    await l1Sender.L1SenderV2__init();\n\n    // Configure L1Sender\n    await l1Sender.setStETh(await stETH.getAddress());\n    await l1Sender.setArbitrumBridgeConfig({\n      wstETH: await wstETH.getAddress(),\n      gateway: await arbitrumBridge.getAddress(),\n      receiver: treasury.address,\n    });\n    await l1Sender.setUniswapSwapRouter(await swapRouter.getAddress());\n\n    // 4. Deploy Distributor\n    const distributorFactory = await ethers.getContractFactory('Distributor');\n    const distributorImpl = await distributorFactory.deploy();\n    const distributorProxy = await proxyFactory.deploy(await distributorImpl.getAddress(), '0x');\n    distributor = distributorFactory.attach(await distributorProxy.getAddress()) as Distributor;\n    await distributor.Distributor_init(\n      await chainLinkDataConsumer.getAddress(),\n      await aavePool.getAddress(),\n      await aavePoolDataProvider.getAddress(),\n      await rewardPool.getAddress(),\n      await l1Sender.getAddress(),\n    );\n\n    // 5. Deploy DepositPool\n    const lib1 = await (await ethers.getContractFactory('ReferrerLib')).deploy();\n    const lib2 = await (await ethers.getContractFactory('LockMultiplierMath')).deploy();\n    const depositPoolFactory = await ethers.getContractFactory('DepositPool', {\n      libraries: {\n        ReferrerLib: await lib1.getAddress(),\n        LockMultiplierMath: await lib2.getAddress(),\n      },\n    });\n    const depositPoolImpl = await depositPoolFactory.deploy();\n    const depositPoolProxy = await proxyFactory.deploy(await depositPoolImpl.getAddress(), '0x');\n    depositPool = depositPoolFactory.attach(await depositPoolProxy.getAddress()) as DepositPool;\n    await depositPool.DepositPool_init(await depositToken.getAddress(), await distributor.getAddress());\n\n    // 6. Deploy L2TokenReceiverV2\n    const l2ReceiverFactory = await ethers.getContractFactory('L2TokenReceiverV2');\n    const l2ReceiverImpl = await l2ReceiverFactory.deploy();\n    const l2ReceiverProxy = await proxyFactory.deploy(await l2ReceiverImpl.getAddress(), '0x');\n    l2TokenReceiver = l2ReceiverFactory.attach(await l2ReceiverProxy.getAddress()) as L2TokenReceiverV2;\n    await l2TokenReceiver.L2TokenReceiver__init(\n      await swapRouter.getAddress(),\n      await nonfungiblePositionManager.getAddress(),\n      {\n        tokenIn: await stETH.getAddress(),\n        tokenOut: await mor.getAddress(),\n        fee: 500,\n        sqrtPriceLimitX96: 0,\n      },\n    );\n\n    // 7. Setup connections\n    await l1Sender.setDistributor(await distributor.getAddress());\n\n    // Add deposit pool to distributor\n    await distributor.addDepositPool(\n      publicRewardPoolId,\n      await depositPool.getAddress(),\n      await depositToken.getAddress(),\n      'ETH/USD',\n      Strategy.NONE,\n    );\n\n    // Complete migration\n    await depositPool.migrate(publicRewardPoolId);\n  }\n\n  async function mintTokensToUsers() {\n    const amount = wei(1000);\n\n    // Mint deposit tokens\n    await depositToken.mint(alice.address, amount);\n    await depositToken.mint(bob.address, amount);\n    await depositToken.mint(charlie.address, amount);\n\n    // Mint stETH\n    await stETH.mint(alice.address, amount);\n    await stETH.mint(bob.address, amount);\n    await stETH.mint(charlie.address, amount);\n\n    // Setup approvals\n    await depositToken.connect(alice).approve(await depositPool.getAddress(), ethers.MaxUint256);\n    await depositToken.connect(bob).approve(await depositPool.getAddress(), ethers.MaxUint256);\n    await depositToken.connect(charlie).approve(await depositPool.getAddress(), ethers.MaxUint256);\n\n    await stETH.connect(alice).approve(await l1Sender.getAddress(), ethers.MaxUint256);\n    await stETH.connect(bob).approve(await l1Sender.getAddress(), ethers.MaxUint256);\n  }\n\n  // Test Setup\n  before(async function () {\n    // Get signers\n    [owner, alice, bob, charlie, treasury, referrer1, referrer2] = await ethers.getSigners();\n\n    // Deploy all contracts\n    await deployMocks();\n    await deployCapitalProtocol();\n    await mintTokensToUsers();\n\n    // Take snapshot for reverting\n    await reverter.snapshot();\n  });\n\n  afterEach(async function () {\n    await reverter.revert();\n  });\n\n  describe('POC yield not withdrawable', function () {\n    it('should show yield stuck', async function () {\n      await setTime(oneDay * 9);\n\n      // Setup reward pool timestamp (required before any staking)\n      await distributor.setRewardPoolLastCalculatedTimestamp(publicRewardPoolId, oneDay * 7);\n\n      // Set minimum rewards distribute period to 1 day\n      await distributor.setMinRewardsDistributePeriod(1);\n\n      const timestamp = await distributor.rewardPoolLastCalculatedTimestamp(publicRewardPoolId);\n      expect(timestamp).to.eq(604800);\n\n      const dp0Before = await distributor.depositPools(publicRewardPoolId, depositPool);\n      expect(dp0Before.deposited).to.eq(wei(0));\n      expect(dp0Before.lastUnderlyingBalance).to.eq(wei(0));\n\n      // Alice stakes tokens\n      await depositPool.connect(alice).stake(publicRewardPoolId, wei(100), 0, ZERO_ADDR);\n\n      const dp0 = await distributor.depositPools(publicRewardPoolId, depositPool);\n      expect(dp0.deposited).to.eq(wei(100));\n      expect(dp0.lastUnderlyingBalance).to.eq(wei(100));\n\n      const currentUserRewards = await depositPool.connect(alice).getLatestUserReward(publicRewardPoolId, alice);\n      expect(currentUserRewards).to.eq(0);\n\n      // imitate yield\n      await depositToken.mint(distributor, wei(100));\n\n      expect(await depositToken.balanceOf(distributor)).to.eq(wei(200));\n\n      const rewards = await rewardPool.getPeriodRewards(0, oneDay * 9, oneDay * 11);\n      expect(rewards).to.eq(3000000);\n\n      // Fast forward time to maxEndTime\n      await setTime(oneDay * 11);\n\n      // rewards are distributed at that time and yield withdrawn\n      await distributor.distributeRewards(publicRewardPoolId);\n\n      // lastUnderlyingBalance updated\n      const dp1 = await distributor.depositPools(publicRewardPoolId, depositPool);\n      expect(dp1.deposited).to.eq(wei(100));\n      expect(dp1.lastUnderlyingBalance).to.eq(wei(200));\n\n      // yield is withdrawn\n      await distributor.withdrawYield(publicRewardPoolId, depositPool);\n      expect(await depositToken.balanceOf(distributor)).to.eq(wei(100));\n      expect(await depositToken.balanceOf(l1Sender)).to.eq(wei(100));\n\n      // lastUnderlyingBalance updated\n      const dp2 = await distributor.depositPools(publicRewardPoolId, depositPool);\n      expect(dp2.deposited).to.eq(wei(100));\n      expect(dp2.lastUnderlyingBalance).to.eq(wei(100));\n\n      // alice receives rewards\n      const currentUserRewardsFinal = await depositPool.connect(alice).getLatestUserReward(publicRewardPoolId, alice);\n      expect(currentUserRewardsFinal).to.be.gt(0);\n\n      // Alice withdraws at oneDay * 14\n      await setTime(oneDay * 14);\n\n      // imitate yield that accrues after all reward distributed, they will never be tracked\n      await depositToken.mint(distributor, wei(100));\n\n      // rewards for this period are 0\n      const rewardsFinal = await rewardPool.getPeriodRewards(0, oneDay * 11, oneDay * 14);\n      expect(rewardsFinal).to.eq(0);\n\n      // lastUnderlyingBalance still the same\n      const dp3 = await distributor.depositPools(publicRewardPoolId, depositPool);\n      expect(dp3.deposited).to.eq(wei(100));\n      expect(dp3.lastUnderlyingBalance).to.eq(wei(100));\n\n      await depositPool.connect(alice).withdraw(publicRewardPoolId, wei(100));\n      expect(await depositToken.balanceOf(distributor)).to.eq(wei(100));\n\n      // lastUnderlyingBalance not updated, does not track yield\n      const dp4 = await distributor.depositPools(publicRewardPoolId, depositPool);\n      expect(dp4.deposited).to.eq(wei(0));\n      expect(dp4.lastUnderlyingBalance).to.eq(wei(0));\n\n      // yield cannot be withdrawn\n      await distributor.withdrawYield(publicRewardPoolId, depositPool);\n      expect(await depositToken.balanceOf(distributor)).to.eq(wei(100));\n\n      // l1Sender balance still the same -> no yield withdrawn\n      expect(await depositToken.balanceOf(l1Sender)).to.eq(wei(100));\n    });\n  });\n});\n```\n\n---\n\n",
    "summary": "\nThe bug report discusses an issue with the code in the Morpheus project on Github. The code is related to withdrawing yield, which is the profit earned from staking tokens. The problem is that the code does not properly update the yield amount when rewards end, causing it to become permanently stuck and inaccessible. This affects all users of the deposit pool and can result in a loss of profits. The report recommends implementing a solution to allow for withdrawal of yield even after rewards have ended. A proof of concept is also provided to demonstrate the issue. ",
    "report_date": "2025-09-11T00:00:00.000Z",
    "contest_prize_txt": "20000",
    "contest_link": "https://code4rena.com/reports/2025-08-morpheus",
    "sponsor_name": "Morpheus",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-08-morpheus",
    "github_link": "https://code4rena.com/audits/2025-08-morpheus/submissions/F-357",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "520",
    "slug": "m-04-yield-withdrawal-blocked-by-zero-reward-early-return-code4rena-morpheus-morpheus-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Morpheus",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "KlosMitSoss"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Morpheus",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}