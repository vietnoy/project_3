{
    "id": 62895,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "HIGH",
    "finders_count": 4,
    "protocol_id": 3419,
    "title": "DELEGATECALL and CALLCODE loses the EVMC_DELEGATED ï¬‚ag",
    "content": "## Severity: High Risk\n\n## Context \n(No context files were provided by the reviewer)\n\n## Description \n(Issue found in commit hash `fc820c9ee9ab310c4fdd5e1888f72164c0b871c8`)\n\nThe EIP-7702 spec notes the following:\n\nA related issue is that an EOA's nonce may be incremented more than once per transaction. Because clients already need to be robust in a worse scenario (described above), it isn't a major concern. However, clients should be aware this behavior is possible and design their transaction propagation accordingly. \n\nFor Monad, this is a more serious concern because of delayed execution. A preceding transaction can invalidate other transactions in a proposal by bumping the delegated EOA's nonce via `CREATE` / `CREATE2`. This invalid transaction will thus not be charged any gas as a result but will take up space in the proposal enabling virtually free block stuffing attacks.\n\nMonad attempts to solve this by disabling `CREATE` and `CREATE2` opcodes when executing delegated code in `evmc_host.cpp`.\n\n```cpp\n// evmc_host.hpp#L129-L132\nif (msg.kind == EVMC_CREATE || msg.kind == EVMC_CREATE2) {\n    if (!create_inside_delegated_ && (msg.flags & EVMC_DELEGATED)) {\n        return evmc::Result{EVMC_UNDEFINED_INSTRUCTION, msg.gas};\n    }\n}\n```\n\nThere is already a bug with the implementation in \"CREATE/CREATE2 is not disabled during a delegated EOA call allowing delegated EOA transactions to be invalidated mid-block,\" but this report will showcase another way to bypass the check.\n\nThe `EVMC_DELEGATED` flag is used to track whether the current call frame is currently within the context of a delegated EOA account. The problem is that for `DELEGATECALL` and `CALLCODE` opcodes, the `EVMC_DELEGATED` flag will be lost when entering the `DELEGATECALL` and `CALLCODE` call frames.\n\nWhen a `DELEGATECALL` and `CALLCODE` occurs, `dest_address == code_address` as `DELEGATECALL` or `CALLCODE` affects the `msg.recipient`; as such, the `EVMC_DELEGATED` flag will be removed from the `DELEGATECALL` or `CALLCODE` call frame.\n\n```cpp\n// call.hpp#L92-L167\nauto recipient = (call_kind == EVMC_CALL || static_call)\n    ? dest_address\n    : ctx->env.recipient;\n// ...\nauto message = evmc_message{\n// ...\n.flags = message_flags(\n    ctx->env.evmc_flags, static_call, dest_address != code_address),\n// ...\n};\n```\n\n```cpp\n// call.hpp#L26-L41\ninline std::uint32_t message_flags(\n    std::uint32_t env_flags, bool static_call, bool delegation_indicator)\n{\n    if (static_call) {\n        env_flags = static_cast<std::uint32_t>(EVMC_STATIC);\n    }\n    if (delegation_indicator) {\n        env_flags |= static_cast<std::uint32_t>(EVMC_DELEGATED);\n    } else {\n        env_flags &= ~static_cast<std::uint32_t>(EVMC_DELEGATED);\n    }\n    return env_flags;\n}\n```\n\nSince the call frame no longer contains the `EVMC_DELEGATED` flag, the call frame can execute a `CREATE` / `CREATE2` opcode to bump its nonce. The `msg.sender` of the `CREATE` / `CREATE2` call frame will have its nonce bumped. Working backwards, the `msg.sender` of the `CREATE` / `CREATE2` call frame is the `msg.recipient` of the `DELEGATECALL` and `CALLCODE` call frame, which equals the EOA delegated code that executed the `DELEGATECALL` / `CALLCODE`, and thus the delegated EOA will have its nonce bumped.\n\n```cpp\n// create.hpp#L62-L78\nauto message = evmc_message{\n// ...\n.sender = ctx->env.recipient,\n// ...\n};\nauto result = ctx->host->call(ctx->context, &message);\n```\n\n```cpp\n// evm.cpp#L202-L209\nauto const nonce = state.get_nonce(msg.sender);\nif (nonce == std::numeric_limits<decltype(nonce)>::max()) {\n    // overflow\n    evmc::Result result{EVMC_ARGUMENT_OUT_OF_RANGE, msg.gas};\n    call_tracer.on_exit(result);\n    return result;\n}\nstate.set_nonce(msg.sender, nonce + 1);\n```\n\n## Recommendation \n`DELEGATECALL` and `CALLCODE` should always retain the `EVMC_DELEGATED` flag if it does contain it.\n\n## Addendum \nIn the following discussion with evmone maintainers, it was confirmed that this flag was only meant for the no-op precompile logic when an EOA is delegated to the precompile. Hence, we recommend resolving the delegation instead of relying on the `EVMC_DELEGATED` flag.\n\n## Category \nLabs: Fixed in PR 1601.\n\n## Spearbit \nFix verified.",
    "summary": "\nThe report is about a high-risk bug found in a code called EIP-7702. The bug allows for a transaction to be invalidated mid-block, which can lead to attacks that stuff blocks with invalid transactions. The bug is caused by the EVMC_DELEGATED flag being lost when entering the DELEGATECALL and CALLCODE call frames, which allows for the nonce to be bumped and the transaction to be invalidated. The recommendation is to always retain the EVMC_DELEGATED flag in these call frames. The bug has been fixed in PR 1601.",
    "report_date": "2025-09-19T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Monad-Spearbit-Security-Review-September-2025.pdf",
    "pdf_page_from": 21,
    "contest_id": "",
    "slug": "delegatecall-and-callcode-loses-the-evmc_delegated-flag-spearbit-none-monad-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Monad",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Haxatron"
            }
        },
        {
            "wardens_warden": {
                "handle": "Dtheo"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guido Vranken"
            }
        },
        {
            "wardens_warden": {
                "handle": "Rikard Hjort"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Monad",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}