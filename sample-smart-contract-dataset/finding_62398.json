{
    "id": 62398,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 3405,
    "title": "[LOGLAB-17] pendingDecreaseCollateral variable isn't excluded from the positionNetBalance() value in the leverage and rebalance calculations, which may lead to incorrect rebalance actions for the strategy",
    "content": "**Severity:** High\n\n**Path:** src/strategy/BasisStrategy.sol#L779-L884\n\n**Description:** During a partial deutilizing action, the `BasisStrategy::spotSellCallback()` function will assign the `collateralDeltaToDecrease` value to the `$.pendingDecreaseCollateral` storage variable when `collateralDeltaToDecrease` is lower than the `limitDecreaseCollateral` value from the hedge manager.\n```\ncollateralDeltaToDecrease += _pendingDecreaseCollateral;\nuint256 limitDecreaseCollateral = _hedgeManager.limitDecreaseCollateral();\nif (collateralDeltaToDecrease < limitDecreaseCollateral) {\n    $.pendingDecreaseCollateral = collateralDeltaToDecrease;\n} else {\n    collateralDeltaAmount = collateralDeltaToDecrease;\n}\n```\nAfter that, the `collateralDeltaAmount` requested for the deutilization will be 0, as `pendingDecreaseCollateral` will be stacked and considered in the next deutilization.\n\nAn important point is that `pendingDecreaseCollateral` shouldnâ€™t be counted toward the net balance of the hedge position because that collateral amount should have already been decreased from the hedge position during the earlier size reduction.\nTherefore, in the calculation of `collateralDeltaToDecrease` in the `spotSellCallback()` and `_pendingDeutilization()` functions, the `pendingDecreaseCollateral` variable is subtracted from the net balance of the hedge manager.\n```\nfunction spotSellCallback(uint256 assetDelta, uint256 productDelta) external authCaller(spotManager()) {\n    [...]\n    // when partial deutilizing\n    IHedgeManager _hedgeManager = $.hedgeManager;\n    uint256 positionNetBalance = _hedgeManager.positionNetBalance();\n    uint256 _pendingDecreaseCollateral = $.pendingDecreaseCollateral;\n    if (_pendingDecreaseCollateral > 0) {\n        (, positionNetBalance) = positionNetBalance.trySub(_pendingDecreaseCollateral);\n    }\n    uint256 positionSizeInTokens = _hedgeManager.positionSizeInTokens();\n    uint256 collateralDeltaToDecrease =\n        positionNetBalance.mulDiv(productDelta, positionSizeInTokens);\n```\n```\nfunction _pendingDeutilization(InternalPendingDeutilization memory params) private view returns (uint256) {\n    [...]\n    deutilization = positionSizeInTokens.mulDiv(\n        totalPendingWithdraw - _pendingDecreaseCollateral,\n        positionSizeInAssets + positionNetBalance - _pendingDecreaseCollateral\n    );\n```\nHowever, in the `_checkUpkeep()` function, the leverage is calculated using the `OffChainPositionManager::currentLeverage()` function, which relies on the original `positionNetBalance` and does not exclude the `pendingDecreaseCollateral` variable. Additionally, the delta collateral amounts for rebalance up and rebalance down are still calculated based on the original `positionNetBalance`.\n```\nfunction _checkUpkeep() private view returns (InternalCheckUpkeepResult memory result) {\n    [...]\n    uint256 currentLeverage = _hedgeManager.currentLeverage();\n    bool _processingRebalanceDown = $.processingRebalanceDown;\n    uint256 _maxLeverage = $.maxLeverage;\n    uint256 _targetLeverage = $.targetLeverage;\n\n    (bool rebalanceUpNeeded, bool rebalanceDownNeeded, bool deleverageNeeded) =\n        _checkRebalance(currentLeverage, $.minLeverage, _maxLeverage, $.safeMarginLeverage);\n      \n    [...]\n    \n    if (rebalanceDownNeeded) {\n        uint256 idleAssets = _vault.idleAssets();\n        (uint256 minIncreaseCollateral,) = _hedgeManager.increaseCollateralMinMax();\n        result.deltaCollateralToIncrease = _calculateDeltaCollateralForRebalance(\n            _hedgeManager.positionNetBalance(), currentLeverage, _targetLeverage\n        );\n    \n    [...]\n    \n    if (rebalanceUpNeeded) {\n      result.deltaCollateralToDecrease = _calculateDeltaCollateralForRebalance(\n          _hedgeManager.positionNetBalance(), currentLeverage, _targetLeverage\n      );\n      \n    [...]  \n```\nThe impact of not excluding `pendingDecreaseCollateral` from `positionNetBalance` in these actions is that incorrect leverage and rebalance amount will be considered, potentially leading to improper rebalancing for the strategy. Furthermore, when `pendingDecreaseCollateral` is executed after a larger request in subsequent deutilizations, it causes the leverage to deviate in the opposite direction, resulting in an imbalanced state for the strategy.\n\nScenario:\n\n1. In the first deutilization, if `collateralDeltaToDecrease` is lower than the limit, it will be stacked to `pendingDecreaseCollateral`, and no collateral will be requested to decrease from the agent. However, the size of the hedge position is still requested to decrease.\n\n2. The agent reduces the size of the hedge position corresponding to the first deutilization off-chain and calls `reportStateAndExecuteRequest()` with 0 collateral to decrease. This still succeeds because the previous request was 0.\n\n3. Now, in the `_checkUpkeep()` function, the leverage will decrease because the size of the hedge position was reduced, but it still considers the original `positionNetBalance` without excluding `pendingDecreaseCollateral`. Since `pendingDecreaseCollateral` should have been removed from the hedge position, this leverage may lead to an incorrect state, where `rebalanceUpNeeded` is true, causing the strategy to rebalance incorrectly.\n\n4. The operator executes the second deutilization, and `collateralDeltaToDecrease` (which already includes the `pendingDecreaseCollateral`) is now larger than the limit, so it requests the total collateralDeltaAmount from both deutilizations.\n\n5. The agent reduces the size of the hedge position corresponding to the second deutilization off-chain and calls `reportStateAndExecuteRequest()` with the total collateral to decrease from both deutilizations.\n\n6. Now, in the `_checkUpkeep()` function, the calculated leverage will increase because the size of the hedge position was reduced only by the spot size of the second deutilization, but it removed the total `collateralDeltaToDecrease` from both deutilizations from the positio`nNetBalance. This leverage may lead to an incorrect state, where `rebalanceDownNeeded` is true, causing the strategy to rebalance incorrectly.\n\n**Remediation:**  Always excluding the `pendingDecreaseCollateral` of the strategy in the calculation of `positionNetBalance` and `currentLeverage` of the hedge manager.So, it should be handled in the functions of `OffChainPositionManager` instead of being excluded in the strategy contract within the `spotSellCallback()` and `_pendingDeutilization()` functions. Additionally, note that in the `_afterDecreaseCollateral` function, the calculation of rebalance down `processingRebalanceDown` should be placed after transferring collateral and updating `$.pendingDecreaseCollateral`.\n\n**Status:**  Fixed\n\n\n- - -",
    "summary": "\nThis bug report describes a problem in the `BasisStrategy` contract, specifically in the `spotSellCallback()` and `_pendingDeutilization()` functions. During a partial deutilizing action, the `pendingDecreaseCollateral` variable is not properly excluded from the calculation of `collateralDeltaToDecrease`, which can lead to incorrect leverage and rebalance amounts for the strategy. This can result in improper rebalancing and an imbalanced state for the strategy. To fix this, the `pendingDecreaseCollateral` variable should be excluded from the calculation of `positionNetBalance` and `currentLeverage` in the `OffChainPositionManager` functions instead of being handled within the strategy contract. This bug has been fixed.",
    "report_date": "2024-11-25T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2024-11-25-BasisOS.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "loglab-17-pendingdecreasecollateral-variable-isnt-excluded-from-the-positionnetbalance-value-in-the-leverage-and-rebalance-calculations-which-may-lead-to-incorrect-rebalance-actions-for-the-strategy-hexens-none-basisos-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Basisos",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Basisos",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}