{
    "id": 62514,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3104,
    "title": "M-22: Setup with `asset = WETH` and a Curve pool that contains Native ETH will lead to a loss for the users",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/708 \n\n## Found by \nxiaoming90\n\n### Summary\n\n-\n\n### Root Cause\n\n-\n\n### Internal Pre-conditions\n\n-\n\n### External Pre-conditions\n\n-\n\n### Attack Path\n\nAssume a Yield Strategy vault where its asset is WETH and the Curve Pool is Native ETH/wstETH.  In this case, calling the `TOKENS()` function will return:\n\n- tokens[0] = Curve's `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` = Converted to `0x0000` (Native ETH) during initialization\n- tokens[1] = 0xB82381A3fBD3FaFA77B3a7bE693342618240067b (wstETH)\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L162\n\n```solidity\nFile: CurveConvex2Token.sol\n162:     function TOKENS() internal view override returns (ERC20[] memory) {\n163:         ERC20[] memory tokens = new ERC20[](_NUM_TOKENS);\n164:         tokens[0] = ERC20(TOKEN_1);\n165:         tokens[1] = ERC20(TOKEN_2);\n166:         return tokens;\n167:     }\n```\n\nThe `_PRIMARY_INDEX` will be set to 0, which is the first token of the Curve pool. The condition at Line 59 will evaluate to `True`.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L59\n\n```solidity\nFile: CurveConvex2Token.sol\n57:         // Assets may be WETH, so we need to unwrap it in this case.\n58:         _PRIMARY_INDEX =\n59:             (TOKEN_1 == _asset || (TOKEN_1 == ETH_ADDRESS && _asset == address(WETH))) ? 0 :\n60:             (TOKEN_2 == _asset || (TOKEN_2 == ETH_ADDRESS && _asset == address(WETH))) ? 1 :\n61:             // Otherwise the primary index is not set and we will not be able to enter or exit\n62:             // single sided.\n63:             type(uint8).max;\n```\n\nDuring the exiting the position, liquidation, or initiating withdrawal, the LP tokens will be unstaked/redeemed from Curve or Convex. Let's review these three (3) operations.\n\n**Initiating withdrawal**\n\nInitiating withdrawal will eventually call the `unstakeAndExitPool` function below. After calling the `_unstakeLpTokens()` and `_exitPool()` functions in Lines 201 and 203 below, the vault will receive back 100 Native ETH and 100 wstETH (as an example). \n\n\n> [!NOTE]\n>\n> Note that when initiating a withdrawal, it will always exit proportionally, and not single-sided as per [here](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L276). Users do not have the option to choose whether they want to exit proportionally or single-sidedly during the initiation of a withdrawal.\n\nSubsequently, the 100 Native ETH will be wrapped to 100 WETH in Line 207 below with the `WETH.deposit()` function. So, there is zero Native ETH left in the vault. At this point, the balance of the vault is: 100 WETH + 100 wstETH.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L207\n\n```solidity\nFile: CurveConvex2Token.sol\n198:     function unstakeAndExitPool(\n199:         uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n200:     ) external returns (uint256[] memory exitBalances) {\n201:         _unstakeLpTokens(poolClaim);\n202: \n203:         exitBalances = _exitPool(poolClaim, _minAmounts, isSingleSided);\n204: \n205:         if (ASSET == address(WETH)) {\n206:             if (TOKEN_1 == ETH_ADDRESS) {\n207:                 WETH.deposit{value: exitBalances[0]}();\n208:             } else if (TOKEN_2 == ETH_ADDRESS) {\n209:                 WETH.deposit{value: exitBalances[1]}();\n210:             }\n211:         }\n212:     }\n```\n\nSince two tokens (Native ETH and wstETH) are being returned, this is not a single-sided exit. Thus, the `_executeRedemptionTrades` function in Line 176 will be executed.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L176\n\n```solidity\nFile: AbstractSingleSidedLP.sol\n145:     function _redeemShares(\n146:         uint256 sharesToRedeem,\n147:         address sharesOwner,\n148:         bool isEscrowed, // @audit-info True if there is pending withdraw request\n149:         bytes memory redeemData\n150:     ) internal override {\n151:         RedeemParams memory params = abi.decode(redeemData, (RedeemParams));\n152: \n153:         // Stores the amount of each token that has been withdrawn from the pool.\n154:         uint256[] memory exitBalances;\n155:         bool isSingleSided;\n156:         ERC20[] memory tokens;\n157:         if (isEscrowed) {\n158:             // Attempt to withdraw all pending requests, tokens may be different if there\n159:             // is a withdraw request.\n160:             (exitBalances, tokens) = _withdrawPendingRequests(sharesOwner, sharesToRedeem);\n161:             // If there are pending requests, then we are not single sided by definition\n162:             isSingleSided = false;\n163:         } else {\n164:             isSingleSided = params.redemptionTrades.length == 0;\n165:             uint256 yieldTokensBurned = convertSharesToYieldToken(sharesToRedeem);\n166:             exitBalances = _unstakeAndExitPool(yieldTokensBurned, params.minAmounts, isSingleSided);\n167:             tokens = TOKENS();\n168:         }\n169: \n170:         if (!isSingleSided) {\n171:             // If not a single sided trade, will execute trades back to the primary token on\n172:             // external exchanges. This method will execute EXACT_IN trades to ensure that\n173:             // all of the balance in the other tokens is sold for primary.\n174:             // Redemption trades are not automatically enabled on vaults since the trading module\n175:             // requires explicit permission for every token that can be sold by an address.\n176:             _executeRedemptionTrades(tokens, exitBalances, params.redemptionTrades);\n177:         }\n178:     }\n```\n\nRecall that:\n\n- tokens[0] = 0x0000 (Native ETH)\n- tokens[1] = 0xB82381A3fBD3FaFA77B3a7bE693342618240067b (wstETH)\n\nNote that the condition in Line 229 of the `_executeRedemptionTrades()` function below will never be `True` because:\n\n```solidity\nif (address(tokens[i]) == address(asset))\nif (address(0x0) == WETH)\nif (false)\n```\n\nIn the first iteration of the for-loop, the `Trade.sellToken` will be set to `0x0000` (Native ETH), which means it will attempt to sell 100 Native ETH. However, the issue here is that when it attempts to sell 100 Native ETH, the trade module will revert due to insufficient balance because the vault does not have 100 Native ETH. \n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L223\n\n```solidity\nFile: AbstractSingleSidedLP.sol\n223:     function _executeRedemptionTrades(\n224:         ERC20[] memory tokens,\n225:         uint256[] memory exitBalances,\n226:         TradeParams[] memory redemptionTrades\n227:     ) internal returns (uint256 finalPrimaryBalance) {\n228:         for (uint256 i; i < exitBalances.length; i++) {\n229:             if (address(tokens[i]) == address(asset)) {\n230:                 finalPrimaryBalance += exitBalances[i];\n231:                 continue;\n232:             }\n233: \n234:             TradeParams memory t = redemptionTrades[i];\n235:             // Always sell the entire exit balance to the primary token\n236:             if (exitBalances[i] > 0) {\n237:                 Trade memory trade = Trade({\n238:                     tradeType: t.tradeType,\n239:                     sellToken: address(tokens[i]),\n240:                     buyToken: address(asset),\n241:                     amount: exitBalances[i],\n242:                     limit: t.minPurchaseAmount,\n243:                     deadline: block.timestamp,\n244:                     exchangeData: t.exchangeData\n245:                 });\n246:                 (/* */, uint256 amountBought) = _executeTrade(trade, t.dexId);\n247: \n248:                 finalPrimaryBalance += amountBought;\n249:             }\n250:         }\n251:     }\n```\n\nDue to the revert, this means that in this setup, none of the users can initiate a withdrawal request because initiating a withdrawal request will always exit proportionally. As shown above, it will ultimately result in a revert.\n\n**Exiting position and liquidation**\n\nHow about exiting position and liquidation? Are these two critical operations affected by this revert? If these operations are performed via proportional exit, it will eventually revert the transaction too. However, these operations give callers the option to choose if they want to exit proportional or single-sided.\n\nLet's see if we can workaround this problem by performing a single-side exit by setting `params.redemptionTrades.length == 0` since we already know that proportional exit does not work, as discussed earlier.\n\nWhen the `_exitPool()` function below is executed, the exit balances will be as follows (assume 1 wstETH = 1 ETH):\n\n- exitBalances[PRIMARY_INDEX] = exitBalances[0] = 200 Native ETH\n- exitBalances[1] = 0\n\n200 Native ETH were later swapped for 200 WETH. It works as intended as all LP tokens have been redeemed back to the asset token (200 WETH)\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L244\n\n```solidity\nFile: CurveConvex2Token.sol\n244:     function _exitPool(\n245:         uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n246:     ) internal returns (uint256[] memory exitBalances) {\n247:         if (isSingleSided) {\n248:             exitBalances = new uint256[](_NUM_TOKENS);\n249:             if (CURVE_INTERFACE == CurveInterface.V1 || CURVE_INTERFACE == CurveInterface.StableSwapNG) {\n250:                 // Method signature is the same for v1 and stable swap ng\n251:                 exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV1(CURVE_POOL).remove_liquidity_one_coin(\n252:                     poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n253:                 );\n254:             } else {\n255:                 exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity_one_coin(\n256:                     // Last two parameters are useEth = true and receiver = this contract\n257:                     poolClaim, _PRIMARY_INDEX, _minAmounts[_PRIMARY_INDEX], true, address(this)\n258:                 );\n259:             }\n260:         } else {\n```\n\nIn summary, during exiting position and liquidation, the user is always forced to perform a single-sided exit via Curve's `remove_liquidity_one_coin`. Forcing users to perform a single-sided exit is an issue here.\n\nHowever, the problem here is that due to the AMM and fee math in the Curve pool, any single-asset withdrawals that worsen the pool imbalance will incur a greater imbalance penalty. Thus, if the Curve pool is imbalanced, the single-sided exit will result in fewer assets being received.\n\n### Impact\n\n**Exiting position and liquidation**\n\nHigh, as this led to a loss of assets during the forced single-sided exit.\n\nThe impact is similar to the past Notional contest issues (https://github.com/sherlock-audit/2023-10-notional-judging/issues/87 and https://github.com/sherlock-audit/2023-10-notional-judging/issues/82), which are judged as a valid High.\n\n**Initiating withdrawal request**\n\nUsers are unable to initiate a withdrawal request due to a revert. In this case, users are always forced to swap their yield tokens for asset tokens via a DEX, which incurs unnecessary slippage and fees.\n\n### PoC\n\n_No response_\n\n### Mitigation\n\n_No response_\n\n",
    "summary": "\nThis bug report discusses an issue found by a user named xiaoming90 on a platform called GitHub. The issue involves a Yield Strategy vault where its asset is WETH and the Curve Pool is Native ETH/wstETH. When attempting to exit the position or initiate a withdrawal, the LP tokens will be unstaked/redeemed from Curve or Convex. However, due to a code error, the vault does not have enough Native ETH to complete the transaction, resulting in a revert. This means that users are unable to initiate a withdrawal request and are forced to swap their yield tokens for asset tokens via a DEX, incurring unnecessary fees and slippage. The impact of this bug is considered high and similar to past Notional contest issues. No response or mitigation has been provided by the developers.",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/708",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "m-22-setup-with-asset-weth-and-a-curve-pool-that-contains-native-eth-will-lead-to-a-loss-for-the-users-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "xiaoming90"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}