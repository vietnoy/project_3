{
    "id": 62142,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3384,
    "title": "Fractional division causes system to debit less than expected",
    "content": "## Severity: Medium Risk\n\n## Context\n- `PaymentLib.sol#L22`\n- `PaymentLib.sol#L28`\n\n## Description\nA key system invariant is that the sum of the `accCash` of all users and the `treasuryCash` for a given `tokenId` should be no more than the actual token balance held by the `MarketHub`. It is possible for this invariant to be broken due to under-debiting when an order is filled through multiple partial matches. There are 2 instances of this:\n- The first, when calculating the payment when sweeping and processing settled orders, where `PMath.mulDown()` rounds to 0 for negative numbers.\n- The second, when calculating the upfront fixed cost, which rounds towards 0 too.\n\n### Simple example for illustration:\n22 / 7 = 3, but (-16 / 7) + (-6 / 7) = -2 + 0 = -2.\n\n## Proof of Concept\n```solidity\nfunction test_multipleTradersCashSettlement() public {\n    address charlie = makeUserWithCashAndEnterMarket0(\"charlie\", 10 ether);\n    // total accCash in system = 30 ether\n    vm.startPrank(admin);\n    // set fees to 0\n    market0.setFeeRates(0, 0);\n    // set mark rate to 10%\n    setMarkRate(rateOracle, 10e16);\n    vm.stopPrank();\n    vm.prank(alice);\n    router.placeOrderALO(true, market0Id, LONG, 11 ether, 1906); // ~10%\n    vm.prank(bob);\n    router.placeOrderFOK(true, market0Id, SHORT, 3.66 ether, type(int16).min);\n    vm.prank(charlie);\n    router.placeOrderFOK(true, market0Id, SHORT, 7.34 ether, type(int16).min);\n    router.settlePaymentAndOrders(toCrossAcc(alice));\n    router.settlePaymentAndOrders(toCrossAcc(bob));\n    router.settlePaymentAndOrders(toCrossAcc(charlie));\n    // try forwarding 1 epoch at a time\n    FIndex index = indexOracle.getLatestFIndex();\n    uint32 timestamp = index.fTime();\n    while (timestamp < maturity) {\n        int112 floatingRate = int112(8e16) * int112(uint112(period)) / int112(365 days);\n        forwardOneEpoch(floatingRate);\n        index = indexOracle.getLatestFIndex();\n        timestamp = index.fTime();\n    }\n    vm.prank(alice);\n    router.exitMarket(true, market0Id);\n    vm.prank(bob);\n    router.exitMarket(true, market0Id);\n    vm.prank(charlie);\n    router.exitMarket(true, market0Id);\n    int256 aliceCashAfter = marketHub.accCash(toCrossAcc(alice));\n    int256 bobCashAfter = marketHub.accCash(toCrossAcc(bob));\n    int256 charlieCashAfter = marketHub.accCash(toCrossAcc(charlie));\n    int256 treasuryCash = int256(marketHub.treasuryCash(tokenId));\n    assertLe(\n        aliceCashAfter +\n        bobCashAfter +\n        charlieCashAfter +\n        treasuryCash,\n        30 ether\n    );\n}\n```\nThe test fails because the assertion breaks the invariant: the total amount accounted for is 1 wei more than expected. Upon inspection of the logs, we find that the payments made are as follows:\n- Bob's payment is `-3660000000000000000 * 39525114155250813 / ONE = -144661917808217975`.\n- Charlie's payment is `-7340000000000000000 * 39525114155250813 / ONE = -290114337899540967`.\n\nThe sum of Bob and Charlie's debits (`-144661917808217975 + (-290114337899540967) = -434776255707758942`) is 1 less than Alice's credit (`434776255707758943`). Likewise, for the upfront fixed cost.\n\n```solidity\nfunction test_upfrontFixedCostRounding() public {\n    address charlie = makeUserWithCashAndEnterMarket0(\"charlie\", 10 ether);\n    // total accCash in system = 30 ether\n    // set all fees to 0\n    vm.startPrank(admin);\n    market0.setFeeRates(0, 0);\n    vm.stopPrank();\n    changeFIndexOracleSettleFee(indexOracle, 0);\n    vm.prank(alice);\n    router.placeOrderALO(true, market0Id, SHORT, 1 ether, 1906); // ~10%\n    vm.prank(bob);\n    router.placeOrderFOK(true, market0Id, LONG, 0.2745 ether, 1906);\n    vm.prank(charlie);\n    router.placeOrderFOK(true, market0Id, LONG, 0.7255 ether, 1906);\n    router.settlePaymentAndOrders(toCrossAcc(alice));\n    int256 aliceTotalValue = getTotalValue(alice);\n    int256 bobTotalValue = getTotalValue(bob);\n    int256 charlieTotalValue = getTotalValue(charlie);\n    assertLe(aliceTotalValue + bobTotalValue + charlieTotalValue, 30 ether);\n}\n```\n\n## Recommendation\nIn general, the rounding directions need to be further scrutinized. A simple fix would be to have `mulDown()` round \"up\" for negative numbers, i.e., round to negative infinity instead of 0, but it is unclear what effect this will have for other `mulDown()` calls. Another approach would be to explicitly round to negative infinity for negative payments, so that more is taken.\n\n```solidity\n// TODO: implement mulUp(): round to positive / negative infinity for positive / negative numbers respectively\nfunction calcSettlement(int256 signedSize, FIndex last, FIndex current) internal pure returns (PayFee res) {\n    if (last == current) return PayFeeLib.ZERO;\n    int256 floatingDiff = int256(int64(current.floatingIndex() - last.floatingIndex()));\n    int256 netPaymentSign = (signedSize >> 255) | int256(1) * (floatingDiff >> 255) | int256(1);\n    res = PayFeeLib.from(\n        netPaymentSign > 0 ?\n        signedSize.mulDown(floatingDiff) :\n        signedSize.mulUp(floatingDiff),\n        signedSize.abs().mulDown(current.feeIndex() - last.feeIndex())\n    );\n}\n```\nSimilarly, for `calcUpfrontFixedCost()`.\n\n**Pendle Finance:** We introduce new functions for multiplication and division, with different rounding directions, and use them as suggested.\n\n**Spearbit:** Acknowledged. Reviewed in a subsequent audit.",
    "summary": "\nThe bug report discusses a Medium Risk issue in the PaymentLib.sol code. The problem occurs when calculating payments for multiple orders that are filled partially. This can lead to a situation where the total amount of money held by users and the market is more than the actual balance of the token. The report provides a simple example and a proof of concept to illustrate the problem. The recommendation suggests implementing new functions for multiplication and division with different rounding directions to fix the issue. ",
    "report_date": "2025-08-22T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Pendle-Spearbit-Security-Review-August-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Pendle-Spearbit-Security-Review-August-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Pendle-Spearbit-Security-Review-August-2025.pdf",
    "pdf_page_from": 7,
    "contest_id": "",
    "slug": "fractional-division-causes-system-to-debit-less-than-expected-spearbit-none-pendle-core-v3-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Pendle Core v3",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Ethan"
            }
        },
        {
            "wardens_warden": {
                "handle": "Desmond Ho"
            }
        },
        {
            "wardens_warden": {
                "handle": "RustyRabbit"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Pendle Core v3",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}