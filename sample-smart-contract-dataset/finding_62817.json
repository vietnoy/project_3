{
    "id": 62817,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3398,
    "title": "M-2: Unconditional lastUpdated advance in RangePool.sync leads to loss of streamed BMX when pool liquidity == 0",
    "content": "\nSource: https://github.com/sherlock-audit/2025-09-bmx-deli-swap-judging/issues/53 \n\n## Found by \n0x73696d616f, blockace, maigadoh, makeWeb3safe\n\n### Summary\n\nA logic ordering issue in RangePool::sync causes the pool's lastUpdated timestamp to advance even when liquidity == 0. If the gauge consumes its N+2 day-bucket during a period with zero active liquidity, the streamed BMX is never credited to the pool's rewards-per-liquidity accumulator and therefore cannot be claimed later, even after liquidity returns. The tokens remain in the gauge contract balance but are unreachable by LP positions.\n\n\n\n### Root Cause\n\nhttps://github.com/sherlock-audit/2025-09-bmx-deli-swap/blob/main/deli-swap-contracts/src/libraries/RangePool.sol#L282\nhttps://github.com/sherlock-audit/2025-09-bmx-deli-swap/blob/main/deli-swap-contracts/src/libraries/RangePool.sol#L287\n```javascript\n    /// @notice High-level helper used by gauges: initialise (if needed), accumulate rewards and adjust to new tick.\n    /// @param self        Pool state storage pointer.\n    /// @param perTokenAmounts  Token amounts accrued over the window since last update (0 allowed).\n    /// @param tickSpacing Pool tick spacing (passed to adjustToTick).\n    /// @param activeTick  Current active tick from PoolManager.slot0.\n    function sync(\n        State storage self,\n        address[] memory tokens,\n        uint256[] memory perTokenAmounts,\n        int24 tickSpacing,\n        int24 activeTick\n    ) internal {\n        // Bootstrap state on first touch so accumulate sees dt = 0\n        if (self.lastUpdated == 0) {\n            self.initialize(activeTick);\n            // no need to accumulate or adjust because lastUpdated = now and tick == activeTick\n            return;\n        }\n        // 1. Update lastUpdated and credit per-token amounts\n@>>        self.lastUpdated = uint64(block.timestamp);\n\n        if (self.liquidity > 0) {\n            uint256 len = tokens.length;\n            for (uint256 i; i < len; ++i) {\n  @>>              _accumulateToken(self, tokens[i], perTokenAmounts[i]);\n            }\n        }\n        // 2. If price moved out of current range adjust liquidity & tick, flipping per-token outside\n        if (activeTick != self.tick) {\n            self.adjustToTick(tickSpacing, activeTick, tokens);\n        }\n    }\n}\n```\nRangePool::sync sets self.lastUpdated = uint64(block.timestamp) before applying per-token accumulation. It only executes `_accumulateToken` when self.liquidity > 0.\n\nWhen self.liquidity == 0, lastUpdated advances but accumulation is skipped so, `DailyEpochGauge::_syncPoolStateCore's` computed `_amountOverWindow` is effectively consumed and lost for distribution.\n\n```javascript\n    function _syncPoolStateCore(PoolId pid, int24 activeTick, int24 tickSpacing) internal {\n        RangePool.State storage pool = poolRewards[pid];\n        uint256 t0 = pool.lastUpdated;\n        uint256 t1 = block.timestamp;\n        address[] memory toks = new address[](1);\n        toks[0] = address(BMX);\n        uint256[] memory amts = new uint256[](1);\n        if (t1 > t0) {\n @>>           amts[0] = _amountOverWindow(pid, t0, t1);\n        } else {\n            amts[0] = 0;\n        }\n @>>      pool.sync(toks, amts, tickSpacing, activeTick);\n    }\n```\n\n\n\n\n### Internal Pre-conditions\n\n- DailyEpochGauge has a non‑zero day bucket for a pool (via DailyEpochGauge::addRewards called by FeeProcessor).\n- The pool's RangePool.State.lastUpdated is older than the target streaming window.\n- RangePool.State.liquidity == 0 at the time DailyEpochGauge syncs the pool (no active in-range liquidity).\n- DailyEpochGauge::pokePool (or any sync path) is invoked, causing RangePool::sync to run.\n\n\n### External Pre-conditions\n\n- A position that previously provided liquidity was unsubscribed (via PositionManagerAdapter::notifyUnsubscribeWithContext), resulting in the pool having zero active liquidity.\n- The scheduled streaming day arrives (N+2), and an external actor or hook triggers a pool sync (e.g., DeliHook calls pokePool on swaps).\n- The fee flow has previously transferred BMX into a gauge balance (via FeeProcessor → DAILY_GAUGE.addRewards), so tokens exist but are unallocated.\n\n\n### Attack Path\n\nNo response\n\n### Impact\n\n- Funds meant for distribution (BMX) are retained in the gauge balance but never credited to any pool accumulator for claim by LP positions.\n- LPs present after liquidity returns cannot claim past streaming amounts; protocol revenue intended for LPs can be effectively sidelined.\n- Denial of reward for LPs; accounting mismatch between gauge token balance and claimable amounts.\n- This is not an immediate theft but a correctness/availability failure with lasting distribution impact.\n\n### PoC\n\n1. Place the test in the `GaugeStream.t.sol` test file.\n2. Run the test using this ` forge test --mt testLostStreamingWhenZeroLiquidity -vvvv`\n```JavaScript\n /// @notice Demonstrates that if a pool has zero liquidity when the gauge\n    ///         sync runs, the per-day bucket amounts are not applied to the\n    ///         pool accumulator (they become effectively unallocated to any\n    ///         position). This reproduces the \"lost streaming when\n    ///         liquidity==0\" behaviour: tokens remain in the gauge balance\n    ///         but positions can't claim them.\n    function testLostStreamingWhenZeroLiquidity() public {\n        // Precondition: setUp has funded the gauge and added a day-bucket.\n        uint256 bucket = 1000 ether;\n\n        // Ensure initial gauge balance contains the bucket\n        assertGe(bmx.balanceOf(address(gauge)), bucket);\n\n        // 1) Remove the only tracked liquidity so pool active liquidity == 0\n        positionManager.unsubscribe(wideTokenId);\n\n        // Confirm pool has zero active liquidity now via gauge view\n        (,, uint128 activeLiq) = gauge.getPoolData(pid);\n        assertEq(activeLiq, 0, \"pool liquidity should be zero\");\n\n        // 2) Advance to the streaming day (N+2) so the gauge will try to credit\n        uint256 dayEnd = TimeLibrary.dayNext(block.timestamp);\n        vm.warp(dayEnd + 1 days);\n\n        // Sanity: streamRate should be non-zero because the day-bucket exists\n        assertGt(gauge.streamRate(pid), 0, \"streamRate should be active for the day\");\n\n        // 3) Trigger pool sync while liquidity == 0. Because RangePool.sync\n        //    updates lastUpdated before accumulating, the amounts for the\n        //    elapsed window are not applied when liquidity==0.\n        vm.prank(address(hook));\n        gauge.pokePool(key);\n\n        // 4) Re-add liquidity (mint and subscribe a fresh position after the\n        //    missed window). This new position cannot recover the previously\n        //    scheduled streaming for the earlier window.\n        uint256 tokenIdNew;\n        (tokenIdNew,) = EasyPosm.mint(\n            positionManager,\n            key,\n            -60000,\n            60000,\n            1e21,\n            type(uint256).max,\n            type(uint256).max,\n            address(this),\n            block.timestamp + 1 hours,\n            bytes(\"\")\n        );\n        positionManager.subscribe(tokenIdNew, address(adapter), bytes(\"\"));\n\n        // 5) Sync now that liquidity > 0. Only amounts since the previous\n        //    lastUpdated will be applied — the bucket that streamed during\n        //    The earlier zero-liquidity window is not credited to positions.\n        vm.prank(address(hook));\n        gauge.pokePool(key);\n\n        // 6) Claim for owner: should receive zero (or very small) because the\n        // Earlier, the streaming window was missed when liquidity was 0.\n        PoolId[] memory arr = new PoolId[](1);\n        arr[0] = pid;\n        uint256 balBefore = bmx.balanceOf(address(this));\n        gauge.claimAllForOwner(arr, address(this));\n        uint256 claimed = bmx.balanceOf(address(this)) - balBefore;\n\n        // The test demonstrates the bug: the bucket is still sitting in the\n        // gauge contract balance but positions received nothing for the\n        // streaming window that occurred while liquidity was zero.\n        assertEq(claimed, 0, \"expected no rewards allocated to position\");\n        assertGe(bmx.balanceOf(address(gauge)), bucket, \"gauge should still hold the bucket funds\");\n    }\n```\n\n\n### Mitigation\n\nDo not advance lastUpdated and therefore do not consume the elapsed-window amounts. when `self.liquidity == 0`. Return early so the pending per-day amounts remain available and are applied once liquidity appears.\n\nApply changes in the `RangePool.sol::sync`\n```diff\n@@\n-        // 1. Update lastUpdated and credit per-token amounts\n-        self.lastUpdated = uint64(block.timestamp);\n-\n-        if (self.liquidity > 0) {\n-            uint256 len = tokens.length;\n-            for (uint256 i; i < len; ++i) {\n-                _accumulateToken(self, tokens[i], perTokenAmounts[i]);\n-            }\n-        }\n+        // If no active liquidity, do not advance lastUpdated or consume amounts.\n+        // Preserve the time window so amounts are processed later when liquidity exists.\n+        if (self.liquidity == 0) {\n+            // Adjust price movement if needed, but keep lastUpdated unchanged.\n+            if (activeTick != self.tick) {\n+                self.adjustToTick(tickSpacing, activeTick, tokens);\n+            }\n+            return;\n+        }\n+\n+        // 1. Update lastUpdated and credit per-token amounts\n+        self.lastUpdated = uint64(block.timestamp);\n+\n+        uint256 len = tokens.length;\n+        for (uint256 i; i < len; ++i) {\n+            _accumulateToken(self, tokens[i], perTokenAmounts[i]);\n+        }\n```\n\n\n",
    "summary": "\nThe bug report discusses an issue found in the code for the BMX Deli Swap platform. The problem occurs when the pool's lastUpdated timestamp advances even when there is no liquidity in the pool. This can cause the BMX tokens to be retained in the pool's balance but not distributed to LP positions, resulting in a loss of rewards for LPs. The root cause of the issue is an error in the RangePool::sync function, where the lastUpdated timestamp is set before checking for liquidity. This can lead to the loss of streaming rewards when liquidity is zero. The bug can be reproduced by removing all liquidity from the pool and then syncing the pool while there is still no liquidity. The suggested solution is to not advance the lastUpdated timestamp and preserve the time window for processing when liquidity becomes available. ",
    "report_date": "2025-09-16T15:00:00.000Z",
    "contest_prize_txt": "47000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1154",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-09-bmx-deli-swap-judging/issues/53",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1154",
    "slug": "m-2-unconditional-lastupdated-advance-in-rangepoolsync-leads-to-loss-of-streamed-bmx-when-pool-liquidity-0-sherlock-bmx-deli-swap-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "BMX Deli Swap",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "0x73696d616f"
            }
        },
        {
            "wardens_warden": {
                "handle": "maigadoh"
            }
        },
        {
            "wardens_warden": {
                "handle": "blockace"
            }
        },
        {
            "wardens_warden": {
                "handle": "makeWeb3safe"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "BMX Deli Swap",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}