{
    "id": 62400,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3405,
    "title": "[LOGLAB-22] Lack of slippage protection for manual swap in SpotManager",
    "content": "**Severity:** Medium\n\n**Path:** src/spot/SpotManager.sol#L145-L188, src/libraries/uniswap/ManualSwapLogic.sol#L16-L30\n\n**Description:** In the `SpotManager` contract, the `buy()` and `sell()` functions attempt to swap tokens between assets and products via the 1inch router or through manual swaps using Uniswap V3 Pools. However, these functions lack slippage protection for the swaps, such as a `minAmountOut` variable. The `INCH_V6` swap type is unaffected because the `minAmountOut` can be encoded into swapData for swaps via the 1inch router. However, the issue arises with the `MANUAL` swap type, which swaps directly through Uniswap V3 Pools without any slippage protection.\n```\namountOut = ManualSwapLogic.swap(amount, $.productToAssetSwapPath);\n```\nThis may put the assets of SpotManager at risk of slippage due to price fluctuations in Uniswap V3 Pools. It could harm the protocol if swaps are performed under unfavorable price or pool conditions.\n```\nfunction buy(uint256 amount, SwapType swapType, bytes calldata swapData) external authCaller(strategy()) {\n    uint256 amountOut;\n    if (swapType == SwapType.INCH_V6) {\n        bool success;\n        (amountOut, success) = InchAggregatorV6Logic.executeSwap(amount, asset(), product(), true, swapData);\n        if (!success) {\n            revert Errors.SwapFailed();\n        }\n    } else if (swapType == SwapType.MANUAL) {\n        SpotManagerStorage storage $ = _getSpotManagerStorage();\n        amountOut = ManualSwapLogic.swap(amount, $.assetToProductSwapPath);\n    } else {\n        // TODO: fallback swap\n        revert Errors.UnsupportedSwapType();\n    }\n    emit SpotBuy(amount, amountOut);\n\n    IBasisStrategy(_msgSender()).spotBuyCallback(amount, amountOut);\n}\n\nfunction sell(uint256 amount, SwapType swapType, bytes calldata swapData) external authCaller(strategy()) {\n    uint256 amountOut;\n    if (swapType == SwapType.INCH_V6) {\n        bool success;\n        (amountOut, success) = InchAggregatorV6Logic.executeSwap(amount, asset(), product(), false, swapData);\n        if (!success) {\n            revert Errors.SwapFailed();\n        }\n    } else if (swapType == SwapType.MANUAL) {\n        SpotManagerStorage storage $ = _getSpotManagerStorage();\n        amountOut = ManualSwapLogic.swap(amount, $.productToAssetSwapPath);\n    } else {\n        // TODO: fallback swap\n        revert Errors.UnsupportedSwapType();\n    }\n    emit SpotSell(amountOut, amount);\n\n    IBasisStrategy(_msgSender()).spotSellCallback(amountOut, amount);\n}\n```\n```\nfunction swap(uint256 amountIn, address[] memory path) external returns (uint256 amountOut) {\n    address tokenIn = path[0];\n    uint256 balance = IERC20(tokenIn).balanceOf(address(this));\n    if (balance < amountIn) {\n        revert Errors.SwapAmountExceedsBalance(amountIn, balance);\n    }\n\n    for (uint256 i; i <= path.length / 2; i += 2) {\n        address pool = path[i + 1];\n        amountIn = exactInputInternal(\n            amountIn, address(this), pool, path[i] < path[i + 2], abi.encode(path[i], path[i + 2], address(this))\n        );\n    }\n    amountOut = amountIn;\n}\n\nfunction exactInputInternal(uint256 amountIn, address recipient, address pool, bool zeroForOne, bytes memory data)\n    internal\n    returns (uint256 amountOut)\n{\n    (int256 amount0, int256 amount1) = IUniswapV3Pool(pool).swap(\n        recipient,\n        zeroForOne,\n        amountIn.toInt256(),\n        zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,\n        data\n    );\n    amountOut = uint256(-(zeroForOne ? amount1 : amount0));\n}\n```\n\n**Remediation:**  A `minAmountOut` variable should be added to the `buy()` and `sell()` functions to validate the amount received from the swap.\n\n**Status:** Fixed\n\n- - -",
    "summary": "\nThe `buy()` and `sell()` functions in the `SpotManager` contract attempt to swap tokens between assets and products using the 1inch router or manual swaps through Uniswap V3 Pools. However, these functions do not have any protection against slippage, which could result in unfavorable price conditions and harm the protocol. To fix this, a `minAmountOut` variable should be added to the functions. This issue has been resolved.",
    "report_date": "2024-11-25T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2024-11-25-BasisOS.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "loglab-22-lack-of-slippage-protection-for-manual-swap-in-spotmanager-hexens-none-basisos-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Basisos",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Basisos",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}