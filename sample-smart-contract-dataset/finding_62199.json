{
    "id": 62199,
    "kind": "MARKDOWN",
    "auditfirm_id": 11,
    "impact": "MEDIUM",
    "finders_count": 2,
    "protocol_id": 3392,
    "title": "Yield tokens can be permanently locked in the vault when all stakers withdraw during vesting window",
    "content": "**Description:** Yield tokens can be permanently locked in the vault when all stakers withdraw during vesting window.\n\n**Proof of Concept:** Add test to `StakingVaultTest.t.sol`:\n```solidity\nfunction test_allStakersWithdrawDuringVestingWindow_LockedTokensInVault() public {\n    // Start fresh - check initial state\n    assertEq(vault.totalSupply(), 100 ether); // Owner already has 100 from setup\n\n    // Setup: 2 more stakers\n    address staker1 = address(0x1);\n    address staker2 = address(0x2);\n\n    uint256 stakeAmount = 100 ether;\n\n    // Setup stakers\n    vm.startPrank(owner);\n    sbtContract.setVerified(staker1, true);\n    sbtContract.setVerified(staker2, true);\n    asset.mint(staker1, stakeAmount);\n    asset.mint(staker2, stakeAmount);\n    vm.stopPrank();\n\n    // Each stakes 100 HILBTC\n    vm.prank(staker1);\n    asset.approve(address(vault), stakeAmount);\n    vm.prank(staker1);\n    vault.stake(stakeAmount);\n\n    vm.prank(staker2);\n    asset.approve(address(vault), stakeAmount);\n    vm.prank(staker2);\n    vault.stake(stakeAmount);\n\n    // Vault now has 300 HILBTC total (100 owner + 200 from stakers), 300 shares\n    assertEq(vault.totalSupply(), 300 ether);\n    assertEq(asset.balanceOf(address(vault)), 300 ether);\n\n    // Owner distributes 30 HILBTC yield\n    vm.startPrank(owner);\n    asset.approve(address(vault), 30 ether);\n    vault.distributeYield(30 ether, block.timestamp);\n    vm.stopPrank();\n\n    // After 4 hours (50% vested)\n    vm.warp(block.timestamp + 4 hours);\n\n    console.log(\"Before withdrawals:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Unvested:\", vault.getUnvestedAmount());\n    console.log(\"Total assets:\", vault.totalAssets());\n    console.log(\"Total shares:\", vault.totalSupply());\n\n    // Owner withdraws their 100 shares\n    vm.prank(owner);\n    vault.redeem(100 ether, owner, owner);\n\n    console.log(\"\\nAfter owner withdrawal:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Unvested:\", vault.getUnvestedAmount());\n    console.log(\"Total assets:\", vault.totalAssets());\n    console.log(\"Total shares:\", vault.totalSupply());\n\n    // Check if remaining stakers can withdraw\n    uint256 staker1Shares = vault.balanceOf(staker1);\n    uint256 maxRedeem1 = vault.maxRedeem(staker1);\n    console.log(\"\\nStaker1 shares:\", staker1Shares);\n    console.log(\"Max redeemable:\", maxRedeem1);\n\n    // Try withdrawal\n    vm.prank(staker1);\n    vault.redeem(staker1Shares, staker1, staker1);\n\n    console.log(\"\\nAfter staker1 withdrawal:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Total assets:\", vault.totalAssets());\n    console.log(\"Total shares:\", vault.totalSupply());\n\n    // Can staker2 still withdraw?\n    uint256 staker2Shares = vault.balanceOf(staker2);\n    uint256 maxRedeem2 = vault.maxRedeem(staker2);\n    console.log(\"\\nStaker2 shares:\", staker2Shares);\n    console.log(\"Max redeemable:\", maxRedeem2);\n    console.log(\"Would receive:\", vault.previewRedeem(staker2Shares));\n\n    // Final withdrawal\n    vm.prank(staker2);\n    vault.redeem(staker2Shares, staker2, staker2);\n\n    console.log(\"\\nFinal state:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Total shares:\", vault.totalSupply());\n\n    // Wait for vesting to complete\n    vm.warp(block.timestamp + 4 hours); // Now 8 hours total\n\n    console.log(\"\\nAfter vesting completes:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Unvested:\", vault.getUnvestedAmount());\n\n    // 15000000000000000001 still locked in the vault\n    console.log(\"Total assets:\", vault.totalAssets());\n    // 0 shares\n    console.log(\"Total supply:\", vault.totalSupply());\n\n    // Owner deposits 100 HILBTC\n    vm.startPrank(owner);\n    asset.approve(address(vault), 100 ether);\n    uint256 sharesReceived = vault.deposit(100 ether, owner);\n    vm.stopPrank();\n\n    console.log(\"\\nAfter owner re-deposits 100 HILBTC:\");\n    console.log(\"Shares received:\", sharesReceived);\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Total assets:\", vault.totalAssets());\n    console.log(\"Share price:\", vault.totalAssets() * 1e18 / vault.totalSupply());\n\n    // Owner withdraws all\n    vm.prank(owner);\n    uint256 withdrawn = vault.redeem(sharesReceived, owner, owner);\n\n    console.log(\"\\nOwner withdrew:\", withdrawn);\n    // 16428571428571428571 still locked in the vault greater than\n    // 15000000000000000001 previously locked!\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    // 0 shares\n    console.log(\"Total shares:\", vault.totalSupply());\n}\n```\n\n**Recommended Mitigation:** Don't allow all shares to be withdrawn; a common technique is on the first deposit to mint 1000 shares to a burn address. Using this technique the owner doesn't need to make the first deposit either.\n\n**Syntetika:**\nFixed in commits [315fd62](https://github.com/SyntetikaLabs/monorepo/commit/315fd620ea68ed473c5169e6b662d341ecb0f92b), [8c6deb1](https://github.com/SyntetikaLabs/monorepo/commit/8c6deb10f509d6cb2f21e5efa2812af00687c1a7) - `StakingVault::deposit` now burns an amount of shares equivalent to the minimum allowed deposit amount (~$10) as the first deposit - the owner is effectively paying a $10 fee to secure the vault.\n\n**Cyfrin:** Experimenting with the new code and modifying our PoC, we found the issue can still manifest even with the dead shares:\n```solidity\nfunction test_vestingWithDeadShares() public {\n    // Simulate the dead shares implementation\n    uint256 DEAD_SHARES = 10000;\n\n    // First deposit by owner triggers dead shares\n    vm.startPrank(owner);\n    asset.approve(address(vault), 100 ether);\n    vault.stake(100 ether);\n\n    // Simulate minting dead shares (in reality this would be in deposit function)\n    uint256 actualOwnerShares = vault.balanceOf(owner);\n    console.log(\"Owner shares received:\", actualOwnerShares);\n    console.log(\"Total supply (includes dead shares):\", vault.totalSupply() + DEAD_SHARES);\n    assertEq(actualOwnerShares + DEAD_SHARES, vault.totalSupply());\n    vm.stopPrank();\n\n    // Setup 2 more stakers\n    address staker1 = address(0x1);\n    address staker2 = address(0x2);\n\n    uint256 stakeAmount = 100 ether;\n\n    // Setup and stake\n    vm.startPrank(owner);\n    asset.mint(staker1, stakeAmount);\n    asset.mint(staker2, stakeAmount);\n    vm.stopPrank();\n\n    vm.startPrank(staker1);\n    asset.approve(address(vault), stakeAmount);\n    vault.stake(stakeAmount);\n    vm.stopPrank();\n\n    vm.startPrank(staker2);\n    asset.approve(address(vault), stakeAmount);\n    vault.stake(stakeAmount);\n    vm.stopPrank();\n\n    // Current state: 300 HILBTC deposited, 300 shares (+ 1000 dead shares)\n    uint256 totalUserShares = vault.totalSupply(); // This would be 1300 with dead shares\n    console.log(\"\\nBefore yield distribution:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Total user shares:\", totalUserShares);\n\n    // Owner distributes 30 HILBTC yield\n    vm.startPrank(owner);\n    asset.approve(address(vault), 30 ether);\n    vault.distributeYield(30 ether, block.timestamp);\n    vm.stopPrank();\n\n    // After 4 hours (50% vested)\n    vm.warp(block.timestamp + 4 hours);\n\n    console.log(\"\\nDuring vesting (4 hours):\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Unvested amount:\", vault.getUnvestedAmount());\n    console.log(\"Total assets:\", vault.totalAssets());\n\n    // All users withdraw during vesting\n    uint256 ownerShares = vault.balanceOf(owner);\n    vm.prank(owner);\n    vault.redeem(ownerShares, owner, owner);\n\n    uint256 staker1Shares = vault.balanceOf(staker1);\n    vm.prank(staker1);\n    vault.redeem(staker1Shares, staker1, staker1);\n\n    uint256 staker2Shares = vault.balanceOf(staker2);\n    vm.prank(staker2);\n    vault.redeem(staker2Shares, staker2, staker2);\n\n    console.log(\"\\nAfter all users withdraw:\");\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Unvested amount:\", vault.getUnvestedAmount());\n    console.log(\"Total assets:\", vault.totalAssets());\n    console.log(\"Remaining shares (should be just dead shares):\", vault.totalSupply());\n\n    // Wait for vesting to complete\n    vm.warp(block.timestamp + 4 hours);\n\n    console.log(\"\\nAfter vesting completes:\");\n    // 15000000000000010501 tokens locked in vault\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Unvested amount:\", vault.getUnvestedAmount());\n    console.log(\"Total assets:\", vault.totalAssets());\n    // only 10000 dead shares remain\n    console.log(\"Dead shares remain:\", vault.totalSupply());\n\n    // New user tries to deposit and recover locked funds\n    address newUser = address(0x3);\n    vm.startPrank(owner);\n    asset.mint(newUser, 100 ether);\n    vm.stopPrank();\n\n    vm.startPrank(newUser);\n    asset.approve(address(vault), 100 ether);\n    uint256 sharesReceived = vault.deposit(100 ether, newUser);\n\n    console.log(\"\\nNew user deposits 100 HILBTC:\");\n    // 66673\n    console.log(\"Shares received:\", sharesReceived);\n    // 115000000000000010501\n    console.log(\"Vault balance:\", asset.balanceOf(address(vault)));\n    console.log(\"Total assets:\", vault.totalAssets());\n\n    // New user immediately withdraws to see how much they can recover\n    uint256 withdrawAmount = vault.redeem(sharesReceived, newUser, newUser);\n    console.log(\"\\nNew user withdraws all shares:\");\n    // user received 99999934788846293400 tokens\n    console.log(\"Amount received:\", withdrawAmount);\n    // user lost 65211153706600 tokens\n    console.log(\"Loss:\", 100 ether - withdrawAmount);\n    // vault locked balance increased to 15000065211153717101\n    console.log(\"Vault balance (still locked):\", asset.balanceOf(address(vault)));\n    vm.stopPrank();\n}\n```\n\n**Recommended Mitigation:** * The simplest option is to remove the 8-hour vesting period and allow the yield to be collected when it is deposited into the contract. As long as there is a sufficiently long cooldown period (default 90 days), this deters \"just in time\" attacks where users deposit large amounts to collect most of the yield then immediately withdraw. The yield distribution transaction could also be run through particular [services](https://docs.flashbots.net/flashbots-protect/overview) designed to prevent front-running to further protect against \"just in time\" attacks\n\n* A more complicated option is to:\n\n1) have the owner deposit in addition to the dead shares, such that any \"locked\" tokens effectively accrue to the owner's stake as well as the dead shares. In this case ensure that the owner's deposit is much greater than the dead shares. If the owner is the last one to withdraw, then don't distribute anymore yield afterwards\n2) in `_withdraw`, check if this transaction would result in only the dead shares remaining\n3) if true, then check if the unvested amount > 0\n4) if true, reset the unvested amount and send the unvested amount to the contract owner (or another contract)\n```solidity\n// After the operation, check if only dead shares remain\nif (totalSupply() - shares == deadShares) {\n    uint256 remainingUnvested = getUnvestedAmount();\n    if(remainingUnvested > 0) {\n        vestingAmount = 0;\n        lastDistributionTimestamp = 0;\n        IERC20(asset()).safeTransfer(owner(), remainingUnvested);\n    }\n}\n```\n\nAdditionally consider implementing a \"sunset\" feature where:\n* the admin can initiate the \"sunset\" process; this prevents new deposits and mints but allows users to redeem or withdraw. It also sets a `sunsetTimestamp` 6 months into the future\n* once either only the `DEAD_SHARES` remain (all stakers have withdrawn) OR `block.timestamp > sunsetTimestamp`, the admin can call a special function that performs the \"rescue\" transferring all asset tokens to the admin\n\nThis provides a nice way to \"sunset\" the vault and collect any remaining tokens, while giving users plenty of time to withdraw and protecting them from a rugpull.\n\n**Syntetika:**\nFixed in commits [1625c09](https://github.com/SyntetikaLabs/monorepo/commit/1625c09f07d8c43c7cfc3b051e12a3a95c26f32d), [8113753](https://github.com/SyntetikaLabs/monorepo/commit/8113753148d12ee24ec26713f3fc76b2cd12cf54), [347330a](https://github.com/SyntetikaLabs/monorepo/commit/347330a078470164c51074b3a8bc2cb141fa9ca8) by:\n* mint 1000 \"dead shares\" to the burn address with the first deposit\n* the first deposit can only be done by the admin, who will do a significantly bigger (at least 10x) deposit than the dead shares\n* the admin will keep this stake active such that any \"lost\" unvested amounts accrue to the admin and the dead shares\n* implemented the \"rescue\" mechanism in `_withdraw` when all non-dead shares are burned while there is a positive unvested amount, the positive unvested amount gets sent to the owner\n\n**Cyfrin:** Verified though ideally the [transfer](https://github.com/SyntetikaLabs/monorepo/blob/audit/issuance/src/vault/StakingVault.sol#L387) in `StakingVault::_withdraw` would use `safeTransfer` instead of `transfer`.\n\n\\clearpage",
    "summary": "\nSummary:\n\nThe bug report describes an issue where yield tokens can become permanently locked in the vault if all stakers withdraw during the vesting window. A proof of concept is provided and a mitigation strategy is recommended. The issue has been fixed by the developers by implementing a \"dead shares\" system and a \"rescue\" mechanism in the code.",
    "report_date": "2025-08-01T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-08-01-cyfrin-syntetika-v2.0.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "yield-tokens-can-be-permanently-locked-in-the-vault-when-all-stakers-withdraw-during-vesting-window-cyfrin-none-syntetika-markdown",
    "firm_name": "Cyfrin",
    "firm_logo_square": "Cyfrin_square.jpg",
    "protocol_name": "Syntetika",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Dacian"
            }
        },
        {
            "wardens_warden": {
                "handle": "Jorge"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
    },
    "protocols_protocol": {
        "name": "Syntetika",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}