{
    "id": 62168,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 3,
    "protocol_id": 3130,
    "title": "M-6: VaultAdapter::multiplier not initialized can  lead first borrows to have `utilizationRate` = 0",
    "content": "\nSource: https://github.com/sherlock-audit/2025-07-cap-judging/issues/396 \n\n## Found by \nHeckerTrieuTien, magiccentaur, montecristo\n\n### Summary\n\nInterestRate calculted in `DebtToken::_nextInterestRate()`  is composed of 2 value:  rate (marketRate or benchmarkRate)  plus an `utilizationRate`.  For an issue in `VaultAdapter` the utilizationRate for the first borrowers can be 0, leading to a lower cost for the users and a loss of yield for protocol. \n\n### Root Cause\n\nhttps://github.com/sherlock-audit/2025-07-cap/blob/main/cap-contracts/contracts/oracle/libraries/VaultAdapter.sol#L27-L50\n\nRate is a function that changes the storage.  `utilization` value is retrieved by `rate` under different cases.\n\n\nhttps://github.com/sherlock-audit/2025-07-cap/blob/main/cap-contracts/contracts/oracle/libraries/VaultAdapter.sol#L79-L95\n\n`multiplier` is a storage variable auto-initialized to 0. In `_applySlopes` if the first user borrows a large amount of tokens such that `_utilization > slopes.kink` we have this formula:\n\n```solidity\n utilizationData.multiplier = utilizationData.multiplier\n                * (1e27 + (1e27 * excess / (1e27 - slopes.kink)) * (_elapsed * $.rate / 1e27)) / 1e27;\n```\nutilizationData.multiplier will be multiplied for a number, but is 0 so final `multiplier` will be 0:\n\n```solidity\n utilizationData.multiplier= 0 * (1e27 + (1e27 * excess / (1e27 - slopes.kink)) * (_elapsed * $.rate / 1e27)) / 1e27 = 0\n```\nSo: \n\n```solidity\n\n            interestRate = (slopes.slope0 + (slopes.slope1 * excess / 1e27)) * utilizationData.multiplier / 1e27;\n\n```\n```solidity\ninterestRate = (slopes.slope0 + (slopes.slope1 * excess / 1e27)) * 0 / 1e27 = 0\n```\nThe final `interestRate` will be 0 too.  New ` utilizationData.multiplier` is stored as 0. \nFor a second borrower (if  remains `utilization > slopes.kink` ) will have the same situation, and so on.\n\nSeries will be interrupted when, after some operations, we will have `utilization < slopes.kink`. Entering the `else`  will set at least the multiplier to `minMultiplier` for:\n\n```solidity\n if (utilizationData.multiplier < $.minMultiplier) {\nutilizationData.multiplier = $.minMultiplier;\n}\n```\n\nAt that point, the storage will contain a number != 0.\n\n### Internal Pre-conditions\n\namount borrowed by first user must lead to `utilization > slopes.kink`.\n\n### External Pre-conditions\n\n--\n\n### Attack Path\n\n1. First agent borrows a large amount of tokens such that: `utilization > slopes.kink `.\n2. New value stored as multiplier: 0.\n3.  InterestRate (from utilization) is 0.\n4.  As long as the condition `utilization > slopes.kink ` remains valid other agents can borrow at the basic condition interest because  the new multiplier that should be used is always multiplied by the old one which is 0 (and the new value will be too).\n\n\n### Impact\n\nUnder the conditions, early borrowers borrow with a interest rate lower than expected. The protocol will receive less interests than it should. The higher the usage, the higher the interest to be paid should be, instead it is 0 (only the base interest will be paid).\n\n### PoC\n\n--\n\n### Mitigation\n\nConsider the initialization of `multiplier` at the neutral value.\n\n",
    "summary": "\nThis bug report discusses an issue with the InterestRate calculation in the DebtToken::_nextInterestRate() function. The problem occurs when the utilizationRate for the first borrowers is 0, resulting in a lower cost for users and a loss of yield for the protocol. The root cause of this issue is a function that changes the storage and retrieves the utilizationRate under different cases. This leads to a situation where the multiplier is set to 0, causing the final interest rate to also be 0. This issue can only occur if the first borrower borrows a large amount of tokens, leading to a utilizationRate above a certain threshold. This bug allows early borrowers to borrow at a lower interest rate than expected, resulting in less interest being received by the protocol. The mitigation suggested is to initialize the multiplier at a neutral value.",
    "report_date": "2025-07-24T15:00:00.000Z",
    "contest_prize_txt": "126000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/990",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-07-cap-judging/issues/396",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "990",
    "slug": "m-6-vaultadaptermultiplier-not-initialized-can-lead-first-borrows-to-have-utilizationrate-0-sherlock-cap-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Cap",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "montecristo"
            }
        },
        {
            "wardens_warden": {
                "handle": "HeckerTrieuTien"
            }
        },
        {
            "wardens_warden": {
                "handle": "magiccentaur"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Cap",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}