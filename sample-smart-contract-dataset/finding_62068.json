{
    "id": 62068,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 9,
    "protocol_id": 2159,
    "title": "[M-05] Missing `update_rz_emis_data` calls in `draw` and `donate` functions lead to incorrect emissions distribution",
    "content": "\n\n<https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/backstop/src/emissions/manager.rs# L223>\n\n<https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/backstop/src/backstop/fund_management.rs# L10-L42>\n\n### Finding description\n\nThe `non_queued_tokens` value is a critical component in the calculation of reward zone emissions index. While most functions that modify this value (such as deposits and withdrawals) correctly call `update_rz_emis_data` before making changes, two important functions - `execute_draw` and `execute_donate` in the `fund_management.rs` - fail to update the emissions data before modifying `non_queued_tokens`.\n\nThis oversight creates an inconsistency in the protocol’s emissions accounting system, leading to unfair distribution of rewards.\n\n### Impact\n\nThis vulnerability affects the fair distribution of emissions across pools:\n\n* **`draw`**: Pools that have tokens drawn from them will unfairly earn **fewer emissions** than they deserve. This occurs because the emissions calculation would use the new (lower) token amount rather than the amount that was actually present during the `distribute` period.\n* **`donate`**: Pools that receive donations will unfairly earn **more emissions** than they should. This occurs because the emissions index update would use the new (higher) token amount rather than the amount at the time of the last `distribute`. This would also cause the total tokens of all pools to be less than balance.\n\n### Proof of Concept\n\nConsider this scenario with two pools:\n\n**Initial state:**\n\n* PoolA: 100 tokens, 100 shares, 0 q4w\n* PoolB: 100 tokens, 100 shares, 0 q4w\n* Total `non_queued_tokens`: 200\n* New emissions to distribute: 10\n* Emissions rate increase: 0.05 per token (10/200)\n\n**Normal case:**\n\n1. Both pools should receive 5 emissions each (`0.05 * 100`)\n\n**Exploited case:**\n\n1. PoolB receives a donation of 50 tokens (increasing its tokens to 150)\n2. Since `donate` doesn’t call `update_rz_emis_data`, the emissions calculation uses 150 tokens instead of 100\n3. When `gulp_emissions` is called, PoolB receives 7.5 emissions (0.05 \\* 150) instead of the fair 5 emissions\n4. This results in 2.5 emissions being unfairly distributed to PoolB\n\nThis test is modified from [`test_gulp_emissions`](https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/backstop/src/emissions/manager.rs# L320)\n```\n\n#[test]\nfn test_gulp_emissions_after_donate() {\n    let e = Env::default();\n    e.cost_estimate().budget().reset_unlimited();\n\n    e.ledger().set(LedgerInfo {\n        timestamp: 1713139200,\n        protocol_version: 22,\n        sequence_number: 0,\n        network_id: Default::default(),\n        base_reserve: 10,\n        min_temp_entry_ttl: 10,\n        min_persistent_entry_ttl: 10,\n        max_entry_ttl: 3110400,\n    });\n\n    let backstop = create_backstop(&e);\n    let emitter_distro_time = 1713139200 - 10;\n    let blnd_token_client = create_blnd_token(&e, &backstop, &Address::generate(&e)).1;\n    create_emitter(\n        &e,\n        &backstop,\n        &Address::generate(&e),\n        &Address::generate(&e),\n        emitter_distro_time,\n    );\n    let pool_1 = Address::generate(&e);\n    let pool_2 = Address::generate(&e);\n    let pool_3 = Address::generate(&e);\n    let reward_zone: Vec<Address> = vec![&e, pool_1.clone(), pool_2.clone(), pool_3.clone()];\n\n    // setup pool 1 to have ongoing emissions\n    let pool_1_emissions_data = BackstopEmissionData {\n        expiration: 1713139200 + 1000,\n        eps: 0_10000000000000,\n        index: 8877660000000,\n        last_time: 1713139200 - 12345,\n    };\n\n    // setup pool 2 to have expired emissions\n    let pool_2_emissions_data = BackstopEmissionData {\n        expiration: 1713139200 - 12345,\n        eps: 0_05000000000000,\n        index: 4532340000000,\n        last_time: 1713139200 - 12345,\n    };\n    // setup pool 3 to have no emissions\n    e.as_contract(&backstop, || {\n        storage::set_last_distribution_time(&e, &(emitter_distro_time - 7 * 24 * 60 * 60));\n        storage::set_reward_zone(&e, &reward_zone);\n        storage::set_backstop_emis_data(&e, &pool_1, &pool_1_emissions_data);\n        storage::set_rz_emis_data(\n            &e,\n            &pool_1,\n            &RzEmissionData {\n                index: 0,\n                accrued: 0,\n            },\n        );\n        storage::set_rz_emis_data(\n            &e,\n            &pool_2,\n            &RzEmissionData {\n                index: 0,\n                accrued: 0,\n            },\n        );\n        storage::set_rz_emis_data(\n            &e,\n            &pool_3,\n            &RzEmissionData {\n                index: 0,\n                accrued: 0,\n            },\n        );\n        storage::set_backstop_emis_data(&e, &pool_2, &pool_2_emissions_data);\n        storage::set_pool_balance(\n            &e,\n            &pool_1,\n            &PoolBalance {\n                tokens: 300_000_0000000,\n                shares: 200_000_0000000,\n                q4w: 0,\n            },\n        );\n        storage::set_pool_balance(\n            &e,\n            &pool_2,\n            &PoolBalance {\n                tokens: 200_000_0000000,\n                shares: 150_000_0000000,\n                q4w: 0,\n            },\n        );\n        storage::set_pool_balance(\n            &e,\n            &pool_3,\n            &PoolBalance {\n                tokens: 500_000_0000000,\n                shares: 600_000_0000000,\n                q4w: 0,\n            },\n        );\n        // diff 1, I don't see the point\n        // blnd_token_client.approve(&backstop, &pool_1, &100_123_0000000, &e.ledger().sequence());\n\n        distribute(&e);\n\n        // diff 2: donate\n        let user = Address::generate(&e);\n        let (backstop_token, backstop_token_client) = create_token(&e, &user);\n        storage::set_backstop_token(&e, &backstop_token);\n        e.mock_all_auths();\n        backstop_token_client.mint(&user, &300_000_0000000);\n        backstop_token_client.approve(&user, &backstop, &300_000_0000000, &e.ledger().sequence());\n        // this can be triggered from auction\n        execute_donate(&e, &user, &pool_1, 300_000_0000000);\n\n        gulp_emissions(&e, &pool_1);\n        gulp_emissions(&e, &pool_2);\n        gulp_emissions(&e, &pool_3);\n\n        assert_eq!(storage::get_last_distribution_time(&e), emitter_distro_time);\n        assert_eq!(\n            storage::get_pool_balance(&e, &pool_1).tokens,\n            // diff 3: pool balance has doubled\n            300_000_0000000 * 2\n        );\n        assert_eq!(\n            storage::get_pool_balance(&e, &pool_2).tokens,\n            200_000_0000000\n        );\n        assert_eq!(\n            storage::get_pool_balance(&e, &pool_3).tokens,\n            500_000_0000000\n        );\n        assert_eq!(\n            blnd_token_client.allowance(&backstop, &pool_1),\n            // diff 4: allowance should double 544320000000=154_555_0000000-100_123_0000000\n            // 154_555_0000000\n            544320000000 * 2\n        );\n        assert_eq!(\n            blnd_token_client.allowance(&backstop, &pool_2),\n            36_288_0000000\n        );\n        assert_eq!(\n            blnd_token_client.allowance(&backstop, &pool_3),\n            90_720_0000000\n        );\n\n        // validate backstop emissions\n\n        let new_pool_1_data = storage::get_backstop_emis_data(&e, &pool_1).unwrap_optimized();\n        // diff 5: eps approximately doubled from 0_21016534391534 to 0_42016534391534\n        assert_eq!(new_pool_1_data.eps, 0_42016534391534);\n        assert_eq!(new_pool_1_data.expiration, 1713139200 + 7 * 24 * 60 * 60);\n        assert_eq!(new_pool_1_data.index, 9494910000000);\n        assert_eq!(new_pool_1_data.last_time, 1713139200);\n\n        let new_pool_2_data = storage::get_backstop_emis_data(&e, &pool_2).unwrap_optimized();\n        assert_eq!(new_pool_2_data.eps, 0_14000000000000);\n        assert_eq!(new_pool_2_data.expiration, 1713139200 + 7 * 24 * 60 * 60);\n        assert_eq!(new_pool_2_data.index, 4532340000000);\n        assert_eq!(new_pool_2_data.last_time, 1713139200);\n\n        let new_pool_3_data = storage::get_backstop_emis_data(&e, &pool_3).unwrap_optimized();\n        assert_eq!(new_pool_3_data.eps, 0_35000000000000);\n        assert_eq!(new_pool_3_data.expiration, 1713139200 + 7 * 24 * 60 * 60);\n        assert_eq!(new_pool_3_data.index, 0);\n        assert_eq!(new_pool_3_data.last_time, 1713139200);\n    });\n}\n```\n\n### Recommended mitigation steps\n\nAdd calls to `update_rz_emis_data` at the beginning of both the `execute_draw` and `execute_donate` functions to ensure emissions calculations use the correct token amounts.\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-12?commentParent=SwunfxwRMZt):**\n\n> Validated as a finding.\n>\n> The impact of this is small, and is unlikely to impact actual claim ability in the long run. Backstop emissions data for pools is updated daily, if not more than daily, for all active Blend pools, and user’s don’t really have control over when `donate` and `draw` are called, so attempting to time long emission gaps up to exploit this is not possible.\n>\n> However, this does result in an increased emissions output for the entire pool backstop, which does result in slightly higher emissions for users that expected. So the angle is there that if timing is lucky for a long period of time and lots of tokens are added through `donate`, we could run into an issue where some users are unable to claim.\n>\n> Given this is possible and no user funds are at risk, a medium seems appropriate.\n\n**[LSDan (judge) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-12?commentParent=SwunfxwRMZt&commentChild=44RJkB2Dt3q):**\n\n> Agree that medium is more appropriate given the scale of funds lost.\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-12?commentParent=RxG2SqVZHk2):**\n\n> Fixed; backstop emissions math was reverted to how it works in v1, alongside some optimizations.\n>\n> * Thus, no `rz_emis_index` is tracked, and rather emissions are distributed during `distribute` based on the current state of the backstops.\n> * Pools can still call `distribute` immediately after a `donate`, but given pool token balances `>>` donate amounts, this effect is small and therefore accepted, as it does not result in any way to inflate overall emissions.\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [Commit 77373e3](https://github.com/blend-capital/blend-contracts-v2/commit/77373e35f8fd91408df9a3f79d1e4443c13e8f4a) to remove `rz index` from backstop emissions.\n\n**Status:** Mitigation confirmed. Full details in reports from [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-46), [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-65), [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-10) and [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-30).\n\n---\n\n",
    "summary": "\nThis bug report discusses a vulnerability in the code for a protocol called Blend, which is used for distributing rewards across different pools of tokens. The issue lies in the calculation of reward emissions, specifically in two functions called `execute_draw` and `execute_donate`. These functions do not update the emissions data before making changes, leading to an inconsistency in the distribution of rewards. This means that some pools may receive more or less emissions than they should, resulting in an unfair distribution of rewards. A proof of concept is provided to demonstrate how this could occur in practice. The impact of this vulnerability is considered to be medium, as it could potentially lead to some users being unable to claim their rewards. The recommended mitigation step is to add calls to update the emissions data at the beginning of the affected functions. The issue has since been fixed by removing the affected code. ",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-12",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-05-missing-update_rz_emis_data-calls-in-draw-and-donate-functions-lead-to-incorrect-emissions-distribution-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "carrotsmuggler"
            }
        },
        {
            "wardens_warden": {
                "handle": "rapid"
            }
        },
        {
            "wardens_warden": {
                "handle": "oakcobalt"
            }
        },
        {
            "wardens_warden": {
                "handle": "adamIdarrha"
            }
        },
        {
            "wardens_warden": {
                "handle": "Testerbot"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xAlix2"
            }
        },
        {
            "wardens_warden": {
                "handle": "Tigerfrake"
            }
        },
        {
            "wardens_warden": {
                "handle": "0x007"
            }
        },
        {
            "wardens_warden": {
                "handle": "Kirkeelee"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}