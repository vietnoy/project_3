{
    "id": 62107,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 16,
    "protocol_id": 3135,
    "title": "H-2: RedeemQueue Accounting Mismatch Between Batch Creation and Claim Eligibility",
    "content": "\nSource: https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults-judging/issues/65 \n\n## Found by \n7, Arav, Brene, Cybrid, JeRRy0422, KupiaSec, Smacaud, algiz, blockace, bughuntoor, dimulski, hunt1, lodelux, reedai, silver\\_eth, t.aksoy\n\n### Summary\n\nThe RedeemQueue contract contains a critical vulnerability where _handleReport processes fewer redemption requests than what users can claim, leading to accounting inconsistencies and potential loss of funds. The issue occurs due to a mismatch between the timestamp boundary logic in batch creation versus claim eligibility checks.\n\n### Root Cause\n\nThe vulnerability stems from inconsistent timestamp boundary handling between two functions:\n\n_handleReport: Uses upperLookupRecent(timestamp) followed by latestEligibleIndex--, which excludes the last redemption request before the report timestamp\n\nclaim: Uses latestEligibleTimestamp from prices, allowing claims for any timestamp ≤ report timestamp\n\nThis creates a scenario where users can claim from batches that don't contain their shares, causing accounting mismatches.\n\n```solidity\n\n    function claim(address receiver, uint32[] calldata timestamps) external nonReentrant returns (uint256 assets) {\n...\n           //@audit users can claim up to higher price saved\n           (bool hasRequest, uint256 shares) = callerRequests.tryGet(timestamp);\n            if (!hasRequest) {\n                continue;\n            }\n            if (shares != 0) {\n                uint256 index = $.prices.lowerLookup(timestamp);\n                if (index >= batchIterator) {\n                    continue;\n                }\n...\n}\n\n    function _handleReport(uint224 priceD18, uint32 timestamp) internal override {\n        RedeemQueueStorage storage $ = _redeemQueueStorage();\n\n        Checkpoints.Trace224 storage timestamps = _timestamps();\n        (, uint32 latestTimestamp, uint224 latestIndex) = timestamps.latestCheckpoint();\n        uint256 latestEligibleIndex;\n        if (latestTimestamp <= timestamp) {\n            latestEligibleIndex = latestIndex;\n        } else {\n            latestEligibleIndex = uint256(timestamps.upperLookupRecent(timestamp));\n            if (latestEligibleIndex == 0) {\n                return;\n            }\n            latestEligibleIndex--;\n        }\n}...\n```\n\nhttps://github.com/sherlock-audit/2025-07-mellow-flexible-vaults/blob/eca8836d68d65bcbfc52c6f04cf6b4b1597555bf/flexible-vaults/src/queues/RedeemQueue.sol#L219\n\n### Internal Pre-conditions\n\nMultiple users must submit redemption requests at different timestamps\n_handleReport must be called with a timestamp that falls between redemption request timestamps\nThe report timestamp must be greater than some redemption timestamps but not necessarily after all pending requests\n\n### External Pre-conditions\n\n-\n\n### Attack Path\n\n1. Users submit redemption requests:\n\n- User1: timestamp 100 (10,000 shares)\n- User2: timestamp 110 (10,000 shares)\n- User3: timestamp 120 (10,000 shares)\n- User4: timestamp 130 (10,000 shares)\n\n2. handleReport is called with timestamp 125\n3. Batch Creation:\n\n- upperLookupRecent(125) returns index pointing to timestamp 120\n- latestEligibleIndex-- excludes timestamp 120\n- Batch 0 created with only 20,000 shares (from timestamps 100, 110)\n- But claim eligibility allows timestamps ≤ 125 (including 100, 110, 120)\n\n4. Claim:\n\n- User3 (timestamp 120) can claim because 120 ≤ 125 (latestEligibleTimestamp)\n- User3 claims 10,000 shares from Batch 0 that doesn't include their contribution\n- Batch 0 now has only 10,000 shares remaining instead of 20,000\n- User1 and User2 can only claim partial amounts, with one user unable to claim at all\n- If User3 share ratio is higher more users wouldn't be able to claim\n\n5. Permanent Fund Lockup:\n\n- Next _handleReport call processes User3's 120 timestamp shares into Batch 1\n- User3 cannot claim from Batch 1 \n- User3's 10,000 shares in Batch 1 become permanently unclaimable\n\n### Impact\n\nBatch accounting would be broken\nLegitimate users cannot claim their full entitlement due to depleted batch\nShares processed in subsequent batches become unclaimable\n\n\n### PoC\n\n// File: flexible-vaults/test/unit/queues/DepositQueue.t.sol\n\n```solidity\n\n    // forge test --fork-url $(grep ETH_RPC .env | cut -d '=' -f2,3,4,5) --gas-limit 10000000000000000 --fork-block-number 22730425 -vvv --mt testRedeemMulti\n    function testRedeemMulti() external {\n        Deployment memory deployment = createVault(\n            vaultAdmin,\n            vaultProxyAdmin,\n            assetsDefault\n        );\n        DepositQueue queue = DepositQueue(\n            addDepositQueue(deployment, vaultProxyAdmin, asset)\n        );\n\n        IOracle.SecurityParams memory securityParams = IOracle.SecurityParams({\n            maxAbsoluteDeviation: 6e16,\n            suspiciousAbsoluteDeviation: 2e16,\n            maxRelativeDeviationD18: 4e16,\n            suspiciousRelativeDeviationD18: 3e16,\n            timeout: 1000,\n            depositInterval: 3600,\n            redeemInterval: 3600\n        });\n\n        vm.prank(deployment.vaultAdmin);\n        deployment.oracle.setSecurityParams(securityParams);\n\n        pushReport(\n            deployment.oracle,\n            IOracle.Report({asset: asset, priceD18: 1e18})\n        );\n\n        vm.warp(block.timestamp + securityParams.timeout);\n\n        address user1 = vm.createWallet(\"user1\").addr;\n        address user2 = vm.createWallet(\"user2\").addr;\n        address user3 = vm.createWallet(\"user3\").addr;\n        address user4 = vm.createWallet(\"user4\").addr;\n        address user5 = vm.createWallet(\"user5\").addr;\n        uint256 amount = 1 ether;\n\n        {\n            makeDeposit(user1, amount, queue);\n\n            vm.warp(block.timestamp + securityParams.timeout);\n            pushReport(\n                deployment.oracle,\n                IOracle.Report({asset: asset, priceD18: 1e18})\n            );\n\n            makeDeposit(user2, amount, queue);\n\n            vm.warp(block.timestamp + securityParams.timeout);\n            pushReport(\n                deployment.oracle,\n                IOracle.Report({asset: asset, priceD18: 1e18})\n            );\n\n            makeDeposit(user3, amount, queue);\n            makeDeposit(user4, amount, queue);\n            makeDeposit(user5, amount, queue);\n            emit log_int(deployment.riskManager.pendingAssets(asset));\n\n            vm.warp(block.timestamp + securityParams.depositInterval);\n            pushReport(\n                deployment.oracle,\n                IOracle.Report({asset: asset, priceD18: 1e18})\n            );\n        }\n\n        vm.warp(block.timestamp + securityParams.depositInterval);\n\n        queue.claim(user1);\n        queue.claim(user2);\n        queue.claim(user3);\n        queue.claim(user4);\n        queue.claim(user5);\n\n        //@audit setup RedeemQueue\n        vm.startPrank(deployment.vaultAdmin);\n        deployment.vault.setQueueLimit(deployment.vault.queueLimit() + 1);\n        deployment.vault.createQueue(\n            0,\n            false,\n            vaultProxyAdmin,\n            asset,\n            new bytes(0)\n        );\n        vm.stopPrank();\n\n        RedeemQueue redeemQue = RedeemQueue(\n            payable(\n                deployment.vault.queueAt(\n                    asset,\n                    deployment.vault.getQueueCount(asset) - 1\n                )\n            )\n        );\n\n        vm.prank(deployment.feeManager.owner());\n        deployment.feeManager.setFees(0, 0, 0, 0);\n\n        //@audit start redemptions\n        uint256 redeemStart = block.timestamp;\n        uint256 redeemAmount = 10000000;\n\n        makeRedeem(user1, redeemAmount, redeemQue);\n\n        skip(100);\n        makeRedeem(user2, redeemAmount, redeemQue);\n\n        skip(100);\n        makeRedeem(user3, redeemAmount, redeemQue);\n\n        //@audit make report after second user redeem time\n        vm.startPrank(address(deployment.vault));\n        redeemQue.handleReport(uint224(1e18), uint32(redeemStart + 150));\n        vm.stopPrank();\n\n        (, uint256 batchShares) = redeemQue.batchAt(0);\n        //@audit only first user is processes\n        assertEq(batchShares, redeemAmount);\n\n        redeemQue.handleBatches(2);\n        assertEq(ERC20(asset).balanceOf(address(redeemQue)), redeemAmount);\n\n        uint32[] memory timestamps = new uint32[](1);\n\n        timestamps[0] = uint32(redeemStart + 100);\n        vm.prank(user2);\n        //@audit second user can claim even thoough only first user shares are processed\n        redeemQue.claim(user2, timestamps);\n        assertEq(ERC20(asset).balanceOf(address(user2)), redeemAmount);\n\n        timestamps[0] = uint32(redeemStart);\n        vm.prank(user1);\n        //@audit Fails here ::[FAIL: panic: division or modulo by zero (0x12)]\n        //@audit first user cant claim since user 2 removed all shres\n        vm.expectRevert();\n        redeemQue.claim(user1, timestamps);\n        assertEq(ERC20(asset).balanceOf(address(user1)), 0);\n    }\n\n```\n\n### Mitigation\n\nDont remove the last user from the batch processing\n\n`        // latestEligibleIndex--; // REMOVE THIS LINE`\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/mellow-finance/flexible-vaults/pull/11\n\n\n\n\n",
    "summary": "\nSummary:\n\nThe RedeemQueue contract has a critical vulnerability that can lead to accounting inconsistencies and potential loss of funds. This is caused by a mismatch between the timestamp boundary logic in batch creation and claim eligibility checks. This allows users to claim from batches that don't contain their shares, causing accounting mismatches and permanent fund lockup. The vulnerability can be exploited by submitting redemption requests at different timestamps and then calling the _handleReport function with a specific timestamp. The impact of this vulnerability is broken batch accounting and legitimate users being unable to claim their full entitlement. A proof-of-concept has been provided to demonstrate the vulnerability. The protocol team has fixed the issue in their code. To mitigate this vulnerability, the line \"latestEligibleIndex--;\" should be removed from the code.",
    "report_date": "2025-07-28T15:00:00.000Z",
    "contest_prize_txt": "70000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/964",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults-judging/issues/65",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "964",
    "slug": "h-2-redeemqueue-accounting-mismatch-between-batch-creation-and-claim-eligibility-sherlock-mellow-flexible-vaults-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Mellow Flexible Vaults",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "reedai"
            }
        },
        {
            "wardens_warden": {
                "handle": "dimulski"
            }
        },
        {
            "wardens_warden": {
                "handle": "bughuntoor"
            }
        },
        {
            "wardens_warden": {
                "handle": "lodelux"
            }
        },
        {
            "wardens_warden": {
                "handle": "Smacaud"
            }
        },
        {
            "wardens_warden": {
                "handle": "Brene"
            }
        },
        {
            "wardens_warden": {
                "handle": "hunt1"
            }
        },
        {
            "wardens_warden": {
                "handle": "KupiaSec"
            }
        },
        {
            "wardens_warden": {
                "handle": "blockace"
            }
        },
        {
            "wardens_warden": {
                "handle": "Cybrid"
            }
        },
        {
            "wardens_warden": {
                "handle": "JeRRy0422"
            }
        },
        {
            "wardens_warden": {
                "handle": "Arav"
            }
        },
        {
            "wardens_warden": {
                "handle": "7"
            }
        },
        {
            "wardens_warden": {
                "handle": "t.aksoy"
            }
        },
        {
            "wardens_warden": {
                "handle": "silver\\_eth"
            }
        },
        {
            "wardens_warden": {
                "handle": "algiz"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Mellow Flexible Vaults",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}