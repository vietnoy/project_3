{
    "id": 62905,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3419,
    "title": "Missing Peer and IP based Reputation System",
    "content": "## Security Assessment Report\n\n## Severity\n**Medium Risk**\n\n## Context\n(No context files were provided by the reviewer)\n\n## Description\nMonad's networking layer lacks a comprehensive peer reputation and rate limiting system, which enables sustained resource consumption style DoS attacks. Due to the computational cost of ECDSA signature verification, Merkle proof verification, decompression, and RaptorCast's error correction decoding, a system to gate these flows is needed. Without proper rate limiting and reputation tracking, malicious peers can repeatedly abuse computational resources without consequences.\n\n## Proof of Concept\n\n### Example Attack Vector 1: Merkle Proof CPU Exhaustion\n```rust\n// Attack via maximum depth Merkle proof verification\nlet attack_message = craft_udp_message_with_merkle_proof(\n    tree_depth: 9, // Maximum allowed depth\n    chunk_data: minimal_data, // Small payload for efficiency\n    signature: valid_signature, // Authenticated attacker\n);\n\n// Each message forces expensive operations:\n// 1. ECDSA signature recovery: ~50s (well-resourced server)\n// 2. Merkle proof computation: ~4s (SHA256 Œ depth, optimized)\n// 3. Message processing overhead: ~6s\n// Total: ~60s per attack message\n\n// Sustained attack calculation:\nlet attack_rate = 1000; // messages per second\nlet cpu_consumption = attack_rate * 60; // 60ms per second = 6% CPU core\nlet daily_messages = 86_400_000; // 86.4 million verification operations per day\n\n// No rate limiting enables unlimited sustained CPU consumption\n```\n\n### Example Attack Vector 2: UDP/TCP Decompression CPU Exhaustion\nNote: This attack works via both UDP (RaptorCast) and TCP message channels.\n```rust\n// Attack via computationally expensive compressed message payloads\nlet compression_attack = create_expensive_compressed_message(\n    compressed_size: 100_000, // 100KB compressed payload\n    decompressed_size: 10_000_000, // 10MB decompressed content\n    compression_complexity: HIGH, // Computationally expensive to decompress\n);\n\n// Attack flow (works for both UDP and TCP):\n// 1. Message passes signature verification (~50s)\n// 2. ZSTD decompression operation (~20ms for complex payload on well-resourced server)\n// 3. Additional RLP parsing overhead (~5ms)\n// Total: ~25ms CPU time per attack message\n\n// UDP-specific flow:\n// 1. UDP chunks received and decoded via RaptorCast reconstructed message\n// 2. Reconstructed message goes through InboundRouterMessage::try_deserialize()\n// 3. Same decompression logic as TCP messages\n\n// TCP-specific flow:\n// 1. TCP message received directly\n// 2. Goes through InboundRouterMessage::try_deserialize()\n// 3. Decompression logic applied\n\n// UDP decompression attack\nlet udp_decompression_attack = UdpRaptorCastMessage {\n    signature: valid_signature, // Pass authentication\n    compressed_app_message: compression_attack,\n    compression_version: DefaultZSTDVersion, // Force expensive decompression\n};\n\n// TCP decompression attack\nlet tcp_decompression_attack = TcpMessage {\n    signature: valid_signature, // Pass authentication\n    compressed_payload: compression_attack,\n    compression_level: MAXIMUM, // Force expensive decompression\n};\n\n// Sustained attack calculation:\nlet attack_rate = 40; // messages per second (limited by decompression cost)\nlet cpu_consumption = attack_rate * 25; // 1.0 seconds per second = 100% CPU core\nlet daily_cpu_hours = 24 * 1.0; // 24 CPU hours consumed per day\n\n// No rate limiting enables sustained decompression CPU exhaustion via UDP or TCP\n// Multiple concurrent attackers can saturate all available CPU cores\n// UDP attacks have advantage: no TCP connection overhead, higher message throughput\n// TCP attacks have advantage: larger message size limits, direct connection\n```\n\n### Example Attack Vector 3: Decoder Instance Memory Multiplication (Validator-Only)\nNote: This attack requires validator privileges to create authenticated broadcast chunks.\n```rust\n// Attack via unbounded decoder cache exploitation (requires validator access)\nlet memory_exhaustion_attack = |validator_key: ValidatorKey| {\n    let mut attack_messages = Vec::new();\n    // Generate 1000 unique cache keys for decoder multiplication\n    for i in 0..1000 {\n        let unique_cache_key = MessageCacheKey {\n            unix_ts_ms: current_time() + i, // Unique timestamp\n            author: validator_key, // Requires validator privileges\n            app_message_hash: hash(format!(\"attack_{}\", i)),\n            app_message_len: 0x7FFFFFFF, // Large message claim\n        };\n        let attack_chunk = craft_chunk_with_large_allocation(\n            cache_key: unique_cache_key,\n            symbol_len: 1, // Minimize chunk size\n            app_message_len: u32::MAX, // Maximize decoder allocation\n        );\n        attack_messages.push(attack_chunk);\n    }\n    // Memory impact calculation:\n    // Each decoder: ~8MB allocation\n    // 1000 decoders: ~8GB total memory consumption\n    // Attack completes in seconds, memory pressure persists for hours\n    attack_messages\n};\n\n// Attack amplification through cache exploitation:\n// - Each unique cache key creates new 8MB decoder instance\n// - LRU eviction insufficient - attacker refreshes entries periodically\n// - No bounds checking on total memory consumption across all decoders\n```\n\n### Example Attack Vector 4: Broadcast Chunk Network Amplification (Validator-Only)\nNote: This attack requires malicious validator access and is limited to the validator set.\n```rust\n// Attack via malicious validator broadcast amplification\nlet validator_attack = |malicious_validator: ValidatorKey| {\n    // Generate massive chunk spam for network amplification\n    let mut broadcast_chunks = Vec::new();\n    for message_id in 0..10000 { // 10,000 different messages\n        for chunk_id in 0..57344 { // 57,344 chunks per message maximum\n            let malicious_chunk = BroadcastChunk {\n                author: malicious_validator, // Valid validator signature\n                message_key: generate_unique_key(message_id),\n                chunk_id: chunk_id, // Unique chunk identifier\n                broadcast_flag: true, // Trigger full node forwarding\n                payload: minimal_payload(100), // Optimize for amplification\n            };\n            broadcast_chunks.push(malicious_chunk);\n        }\n    }\n    // Attack multiplication:\n    // 10,000 messages Œ 57,344 chunks = 573 million potential attack chunks\n    // Each chunk triggers forwarding to ALL full nodes in network\n    // Single validator can sustain 67MB/sec continuous network traffic\n    // Total potential: 5.5TB per day of amplified network traffic\n    broadcast_chunks\n};\n\n// No rate limiting on broadcast chunk forwarding enables:\n// - Network-wide bandwidth exhaustion\n// - Resource consumption across entire validator set\n// - Sustained attack for entire validator window (80+ seconds)\n// - **Limitation**: Attack requires malicious validator participation (limited attacker pool)\n```\n\n### Example Attack Vector 5: Sybil Attack via Ephemeral Peer IDs\n```rust\n// Sybil attack exploiting unlimited peer ID generation\nlet sybil_attack = |attacking_ip: IpAddr| {\n    let mut ephemeral_peers = Vec::new();\n    // Generate 1000 unique peer identities from single IP address\n    for i in 0..1000 {\n        let ephemeral_key = generate_random_keypair();\n        let peer_id = NodeId::from(ephemeral_key.public_key);\n        ephemeral_peers.push(SybilPeer {\n            peer_id: peer_id,\n            private_key: ephemeral_key.private_key,\n            source_ip: attacking_ip, // Same IP, different peer IDs\n        });\n    }\n\n    // Attack amplification through identity multiplication:\n    for peer in ephemeral_peers {\n        std::thread::spawn(move || {\n            loop {\n                // Each \"peer\" gets independent rate limits (if any existed)\n                spam_merkle_proofs(peer.peer_id, rate: 100); // 6ms/sec per peer (100 ops Œ 60s)\n                create_decoder_instances(peer.peer_id, count: 10); // 80MB per peer\n                std::thread::sleep(Duration::from_secs(1));\n            }\n        });\n    }\n\n    // Sybil amplification calculation:\n    // 1000 fake peers Œ 6ms/sec = 6 seconds/sec = 600% CPU utilization\n    // 1000 fake peers Œ 80MB = 80GB memory consumption\n    // All from single IP address with no IP-based rate limiting\n};\n\n// Attack characteristics:\n// - Unlimited peer identity generation from single source\n// - Each identity appears as \"different\" peer to peer-only rate limiting\n// - No correlation between peer behavior and source IP address\n// - Perfect Sybil multiplication: 1 attacker IP = 1000+ attack identities\n```\n\n## Coordinated Attack Scenarios\n\n### Scenario 1: Unpermissioned External Attack (No Validator Access Required)\n```rust\n// External attackers with no special privileges\nlet unpermissioned_external_attack = |attacking_ips: Vec<IpAddr>| {\n    for ip in attacking_ips {\n        // Generate multiple fake peer identities per IP\n        for peer_id in generate_fake_peers(ip, count: 100) {\n            std::thread::spawn(move || {\n                loop {\n                    // Vector 1: CPU exhaustion via Merkle proofs (unpermissioned)\n                    spam_merkle_proofs(peer_id, rate: 100); // 6ms/sec CPU load\n                    // Vector 2: UDP/TCP decompression attacks (unpermissioned)\n                    launch_udp_decompression_attack(peer_id, rate: 40); // 1000ms/sec CPU load\n                    launch_tcp_decompression_attack(peer_id, rate: 40); // 1000ms/sec CPU load\n                    // Vector 5: Sybil identity multiplication (unpermissioned)\n                    // Each peer gets independent rate limits (if any existed)\n                    std::thread::sleep(Duration::from_secs(1));\n                }\n            });\n        }\n    }\n\n    // Unpermissioned attack impact (10 IPs Œ 100 fake peers each):\n    // - CPU: 1000 fake peers Œ (6ms + 2000ms)/sec = 2,006,000ms/sec = 200,600% CPU utilization\n    // - Memory: Limited to legitimate processing overhead + decoder instances\n    // - Network: Very high bandwidth (UDP + TCP decompression payloads)\n    // - Barrier to entry: ZERO - any external attacker (UDP requires no connections, TCP needs connection setup)\n    // - Duration: Unlimited (no reputation system to stop attacks)\n    // - UDP advantage: Higher throughput, no connection limits\n    // - TCP advantage: Larger message sizes, more predictable delivery\n};\n```\n\n### Scenario 2: Validator Privilege Attack (Requires Validator Compromise or a Malicious Validator)\n```rust\n// Malicious validators with full broadcast privileges\nlet validator_privilege_attack = |malicious_validators: Vec<ValidatorKey>| {\n    for validator in malicious_validators {\n        std::thread::spawn(move || {\n            loop {\n                // Vector 1: CPU exhaustion via Merkle proofs\n                spam_merkle_proofs(validator.node_id, rate: 100); // 6ms/sec CPU load\n                // Vector 3: Memory exhaustion via decoder multiplication (VALIDATOR-ONLY)\n                create_decoder_instances(validator, count: 100); // 800MB memory per validator\n                // Vector 4: Network amplification (VALIDATOR-ONLY)\n                broadcast_spam_chunks(validator, rate: 1000); // Network flooding\n                std::thread::sleep(Duration::from_secs(1));\n            }\n        });\n    }\n\n    // Validator privilege attack impact (5 malicious validators):\n    // - CPU: All unpermissioned attacks (200,600%+ per validator) PLUS validator-only attacks\n    // - Memory: 5 validators Œ 800MB = 4GB sustained memory pressure (additional to base attacks)\n    // - Network: Multi-gigabyte amplified traffic across entire network\n    // - Barrier to entry: HIGH - requires malicious validator participation\n    // - Duration: Limited to validator windows but recurring\n    // - Total: MAXIMUM impact - combines all attack vectors simultaneously\n};\n```\n\n## Attack Scenarios Enabled\n\n### Unpermissioned Attacks (High Likelihood)\n- Sybil attacks - External attackers can generate unlimited ephemeral peer IDs.\n- UDP Merkle proof spam - Any external attacker can force expensive signature verification.\n- UDP/TCP decompression attacks - Any external attacker can send compressed payloads for CPU exhaustion.\n- Persistent CPU exhaustion - No mechanism to automatically limit problematic IPs/peers.\n- Multi-protocol abuse - Attackers can simultaneously abuse UDP and TCP channels.\n\n### Validator Privilege Attacks (Lower Likelihood, Maximum Impact)\n- All unpermissioned attacks - Validators can execute every attack available to external attackers.\n- Decoder instance memory exhaustion - Additional validator-only capability via broadcast chunks.\n- Network amplification attacks - Additional validator-only capability for broadcast chunk flooding.\n- Combined maximum impact - All attack vectors simultaneously with highest privileges.\n\n## Recommendation\n\n### Priority 1 - Unpermissioned Attack Defenses (Critical)\n1. Add IP-based rate limiting - Primary defense against Sybil attacks using ephemeral peer IDs.\n2. Add connection limits per IP - Limit total peer identities from single source.\n\n### Priority 2 - Validator Privilege Attack Defenses (High)\n1. Add validator broadcast rate limiting - Prevent decoder instance multiplication attacks.\n2. Implement memory usage tracking - Monitor and limit total decoder cache memory.\n3. Add validator reputation tracking - Score validators based on broadcast behavior quality.\n\n### Priority 3 - General Resilience (Medium)\n1. Create a progressive penalty system - Escalating restrictions for repeated misbehavior.\n2. Add automated response mechanisms - Automatic temporary bans for severe abuse.\n3. Implement peer quality metrics - Track and act on peer performance indicators.\n\n## Example Code Suggestion\n```rust\n// Multi-layered rate limiting system\nstruct RateLimitingSystem {\n    ip_limits: HashMap<IpAddr, IpRateLimiter>, // Primary Sybil defense\n    peer_limits: HashMap<PeerId, PeerRateLimiter>, // Per-peer tracking\n    reputation: HashMap<PeerId, PeerReputation>, // Behavioral scoring\n}\n\n// IP-based rate limiting (Sybil attack prevention)\nstruct IpRateLimiter {\n    source_ip: IpAddr,\n    operations_per_second: RateCounter,\n    total_peers_from_ip: u32, // Track peer count per IP\n    bandwidth_usage: RateCounter, // Network usage tracking\n    violation_count: u32,\n    temporary_ban_until: Option<Timestamp>,\n}\n\n// Peer reputation system\nstruct PeerReputation {\n    peer_id: PeerId,\n    source_ip: IpAddr, // Link peer to IP for correlation\n    trust_score: f64, // 0.0-1.0 reputation score\n    violation_count: u32, // Number of violations\n    last_violation: Timestamp, // Time of last misbehavior\n    rate_limit_multiplier: f64, // Dynamic rate limit adjustment\n}\n\n// Multi-layer rate limiting check\nfn check_rate_limit(peer_id: &PeerId, source_ip: &IpAddr, operation: &Operation) -> RateLimitResult {\n    // Layer 1: IP-based rate limiting (primary Sybil defense)\n    let ip_limiter = get_ip_rate_limiter(source_ip);\n    if ip_limiter.exceeds_limit(operation) {\n        apply_ip_penalty(source_ip);\n        return RateLimitResult::Rejected(\"IP rate limit exceeded \");\n    }\n\n    // Layer 2: Check for too many peers from single IP (Sybil detection)\n    if ip_limiter.total_peers_from_ip > MAX_PEERS_PER_IP {\n        return RateLimitResult::Rejected(\"Too many peers from IP \");\n    }\n\n    // Layer 3: Per-peer rate limiting with reputation\n    let reputation = get_peer_reputation(peer_id);\n    let base_limit = operation.base_rate_limit();\n    let adjusted_limit = base_limit * reputation.rate_limit_multiplier;\n    if peer_exceeds_limit(peer_id, adjusted_limit) {\n        // Update both peer and IP tracking\n        update_peer_reputation(peer_id, ReputationEvent::RateLimitViolation);\n        update_ip_reputation(source_ip, ReputationEvent::PeerViolation);\n        RateLimitResult::Rejected(\"Peer rate limit exceeded \")\n    } else {\n        RateLimitResult::Accepted\n    }\n}\n\n// Constants for Sybil attack prevention\nconst MAX_PEERS_PER_IP: u32 = 5; // Limit peer identities per IP\nconst MAX_OPERATIONS_PER_IP_PER_SEC: u32 = 50; // Aggregate IP rate limit\nconst IP_BAN_DURATION_SECS: u64 = 300; // 5 minute temporary bans\n```\n\n**Category Labs: Acknowledged.**  \n**Spearbit: Acknowledged.**",
    "summary": "\nThis report discusses potential security vulnerabilities in the networking layer of Monad. These vulnerabilities can be exploited to launch denial of service (DoS) attacks and consume computational resources without consequences. The report provides proof of concept examples for various attack vectors, including Merkle proof CPU exhaustion, UDP/TCP decompression CPU exhaustion, decoder instance memory multiplication, broadcast chunk network amplification, and Sybil attacks via ephemeral peer IDs. These attacks can be launched by external attackers with no special privileges or by malicious validators. The report recommends implementing IP-based rate limiting, connection limits per IP, validator broadcast rate limiting, memory usage tracking, validator reputation tracking, a progressive penalty system, automated response mechanisms, and peer quality metrics to mitigate these vulnerabilities.",
    "report_date": "2025-09-19T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Monad-Spearbit-Security-Review-September-2025.pdf",
    "pdf_page_from": 31,
    "contest_id": "",
    "slug": "missing-peer-and-ip-based-reputation-system-spearbit-none-monad-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Monad",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Haxatron"
            }
        },
        {
            "wardens_warden": {
                "handle": "Dtheo"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guido Vranken"
            }
        },
        {
            "wardens_warden": {
                "handle": "Rikard Hjort"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Monad",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}