{
    "id": 62109,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 9,
    "protocol_id": 3135,
    "title": "H-4: Protocol Fee Multiple Accrual in Oracle.submitReports",
    "content": "\nSource: https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults-judging/issues/167 \n\n## Found by \n0x23r0, 0xc0ffEE, 7, Etherking, ZanyBonzy, blockace, evta, lodelux, silver\\_eth\n\n### Summary\n\nThe `Oracle.submitReports` function processes multiple asset reports in a single transaction, but the `ShareModule.handleReport` function calculates and accrues protocol fees for each report individually without considering that the timestamp should only be updated once per batch. This leads to multiple fee accruals when non-base assets are processed before the base asset, resulting in excessive protocol fees being charged.\n\n### Root Cause\n\nThe issue stems from the interaction between [`Oracle.submitReports`](https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults/blob/eca8836d68d65bcbfc52c6f04cf6b4b1597555bf/flexible-vaults/src/oracles/Oracle.sol#L103-L121) and `ShareModule.handleReport`. In `ShareModule.handleReport`, the fee calculation uses the current timestamp and the last stored timestamp to calculate protocol fees:\n\n```solidity\n// In ShareModule.handleReport (lines 281-283)\nuint256 fees = feeManager_.calculateFee(address(this), asset, priceD18, shareManager_.totalShares());\nif (fees != 0) {\n    shareManager_.mint(feeManager_.feeRecipient(), fees);\n}\n```\n\nThe `FeeManager.calculateFee` function calculates protocol fees based on the time difference:\n\n```solidity\n// In FeeManager.calculateFee (lines 81-83)\nuint256 timestamp = $.timestamps[vault];\nif (timestamp != 0 && block.timestamp > timestamp) {\n    shares += Math.mulDiv(totalShares, $.protocolFeeD6 * (block.timestamp - timestamp), 365e6 days);\n}\n```\n\nHowever, `FeeManager.updateState` only updates the timestamp when the asset is the base asset:\n\n```solidity\n// In FeeManager.updateState (lines 116-128)\nfunction updateState(address asset, uint256 priceD18) external {\n    FeeManagerStorage storage $ = _feeManagerStorage();\n    address vault = _msgSender();\n    if ($.baseAsset[vault] != asset) {\n        return; // Early return for non-base assets\n    }\n    // ... update minPriceD18 and timestamp\n    $.timestamps[vault] = block.timestamp;\n}\n```\n\nWhen multiple reports are submitted in `Oracle.submitReports`, if the first reports are for non-base assets, the timestamp remains unchanged, causing each subsequent report to calculate fees based on the same old timestamp, leading to multiple fee accruals.\n\n### Internal Pre-conditions\n\n1. The vault must support multiple assets with one designated as the base asset\n2. The `Oracle.submitReports` function must be called with multiple reports in a single transaction\n3. The first reports in the batch must be for non-base assets\n4. The base asset report must appear later in the batch\n5. Protocol fees must be configured (protocolFeeD6 > 0)\n6. Time must have passed since the last timestamp update (block.timestamp > lastTimestamp)\n\n### External Pre-conditions\n\n.\n\n### Attack Path\n\n1. **Setup**: Configure a vault with multiple assets where one is designated as the base asset\n2. **Initial State**: Set protocol fees and ensure time has passed since the last timestamp update\n3. **Submit Reports**: Call `Oracle.submitReports` with multiple reports where non-base assets appear first\n4. **First Report Processing**: `ShareModule.handleReport` is called for the first non-base asset\n   - `FeeManager.calculateFee` calculates protocol fees based on old timestamp\n   - Fees are minted to the fee recipient\n   - `FeeManager.updateState` is called but returns early (not base asset)\n5. **Subsequent Reports**: For each additional report before the base asset:\n   - `FeeManager.calculateFee` uses the same old timestamp\n   - Additional fees are calculated and minted\n   - `FeeManager.updateState` continues to return early\n6. **Base Asset Report**: When the base asset report is processed:\n   - Fees are calculated again using the old timestamp\n   - `FeeManager.updateState` finally updates the timestamp\n7. **Result**: Multiple fee accruals have occurred, with fees being charged multiple times for the same time period\n\n### Impact\n\nThis vulnerability allows excessive protocol fees to be charged when multiple asset reports are submitted in a single transaction.\n\n### PoC\n\n```solidity\nfunction testMultipleTimesFee() external {\n    Deployment memory deployment = createVault(vaultAdmin, vaultProxyAdmin, assetsDefault);\n    Oracle oracle = deployment.oracle;\n    address asset = assetsDefault[0];\n\n    vm.startPrank(vaultAdmin);\n    deployment.feeManager.setFeeRecipient(vaultAdmin);\n    deployment.feeManager.setFees(0,0,0, 1e5); // 10% protocol fee\n    deployment.feeManager.setBaseAsset(address(deployment.vault), asset);\n    vm.stopPrank();\n\n    IOracle.Report[] memory reports = new IOracle.Report[](3); \n    for (uint256 i = 0; i < 3; i++) {\n        reports[i].asset = assetsDefault[2 - i];\n        reports[i].priceD18 = 1e18;\n    }\n\n    vm.startPrank(vaultAdmin);\n    oracle.submitReports(reports);\n    for (uint256 i = 0; i < 3; i++) {\n        oracle.acceptReport(reports[i].asset, reports[i].priceD18, uint32(block.timestamp));\n    }\n    vm.stopPrank();\n\n    // Set initial shares to 1000\n    vm.prank(address(deployment.vault));\n    deployment.shareManager.mint(address(0x100), 1000 ether);\n\n    // Move time forward by 1 year\n    skip(365 days);\n\n    // Submit reports for 3 assets\n    vm.prank(vaultAdmin);\n    oracle.submitReports(reports);\n\n    // Check the fee recipient's shares\n    uint256 feeRecipientShares = deployment.shareManager.sharesOf(vaultAdmin);\n    console.log(\"Fee recipient shares:\", feeRecipientShares);\n\n    assertGt(feeRecipientShares, 300 ether, \"Fee recipient shares mismatch\");\n}\n```\n\n### Mitigation\n\nThe issue can be mitigated by updating the implementation related to the timestamp update.\nI think the timestamp should be updated even though the asset is not the base asset.\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/mellow-finance/flexible-vaults/pull/6/files\n\n\n\n\n",
    "summary": "\nThe `Oracle.submitReports` function in the flexible-vaults protocol processes multiple asset reports in a single transaction. However, the function does not properly handle the calculation and accrual of protocol fees when multiple reports are submitted. This leads to excessive fees being charged when non-base assets are processed before the base asset. The root cause of this issue is the interaction between `Oracle.submitReports` and `ShareModule.handleReport`, which uses an old timestamp to calculate fees instead of updating it for each report. This vulnerability can be exploited by submitting multiple reports in a single transaction and can result in multiple fee accruals. The impact of this bug is that excessive fees can be charged to users. The protocol team has fixed this issue in the latest update.",
    "report_date": "2025-07-28T15:00:00.000Z",
    "contest_prize_txt": "70000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/964",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-07-mellow-flexible-vaults-judging/issues/167",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "964",
    "slug": "h-4-protocol-fee-multiple-accrual-in-oraclesubmitreports-sherlock-mellow-flexible-vaults-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Mellow Flexible Vaults",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "evta"
            }
        },
        {
            "wardens_warden": {
                "handle": "ZanyBonzy"
            }
        },
        {
            "wardens_warden": {
                "handle": "0x23r0"
            }
        },
        {
            "wardens_warden": {
                "handle": "lodelux"
            }
        },
        {
            "wardens_warden": {
                "handle": "blockace"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xc0ffEE"
            }
        },
        {
            "wardens_warden": {
                "handle": "7"
            }
        },
        {
            "wardens_warden": {
                "handle": "silver\\_eth"
            }
        },
        {
            "wardens_warden": {
                "handle": "Etherking"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Mellow Flexible Vaults",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}