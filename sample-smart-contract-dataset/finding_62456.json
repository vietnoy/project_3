{
    "id": 62456,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3411,
    "title": "[M-01] Staker may exploit delegators by setting commission pre-migration",
    "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe `set_commission()` function allows a staker with `V1` info to set `staker_pool_info.commission` without checking that they actually have migrated to `V2`. This is because the `internal_staker_info()` invoked to fetch the `staker_info` simply returns the available `V1` info.\n```rust\n>>      let staker_info = self.internal_staker_info(:staker_address);\n        assert!(staker_info.unstake_time.is_none(), \"{}\", Error::UNSTAKE_IN_PROGRESS);\n\n        let staker_pool_info_mut = self.staker_pool_info.entry(staker_address);\n        if let Option::Some(old_commission) = staker_pool_info_mut.commission.read() {\n            //..\n        } else {\n>>          staker_pool_info_mut.commission.write(Option::Some(commission));\n            self.emit(Events::CommissionInitialized { staker_address, commission });\n        }\n```\nSince the `staker_pool_info` is a `V2` feature, a staker in `V1` does not have it yet, and as such, the `else` block will be executed.\n\nAfter this, this staker can simply invoke `set_open_for_delegation()` function and deploy any `BTC` pool. Notice that here, he manages to pass the checks because `staker_pool_info.commission` has already been set above:\n```rust\n    let staker_info = self.internal_staker_info(:staker_address);\n    // @audit commision was already set above\n>>  let staker_pool_info_mut = self.staker_pool_info.entry(staker_address);\n    assert!(staker_info.unstake_time.is_none(), \"{}\", Error::UNSTAKE_IN_PROGRESS);\n    assert!(self.does_token_exist(:token_address), \"{}\", Error::TOKEN_NOT_EXISTS);\n    assert!(\n        !staker_pool_info_mut.has_pool_for_token(:token_address),\n        \"{}\",\n        Error::STAKER_ALREADY_HAS_POOL,\n    );\n    // @audit passes\n>>  let commission = staker_pool_info_mut.commission();\n\n    // Deploy delegation pool contract.\n    let pool_contract = self\n        .deploy_delegation_pool_from_staking_contract(\n            :staker_address,\n            staking_contract: get_contract_address(),\n            :token_address,\n            :commission,\n        );\n    // @audit Pool added\n>>  staker_pool_info_mut.pools.write(pool_contract, token_address);\n    // Initialize the delegated balance trace.\n    self.initialize_staker_delegated_balance_trace(:staker_address, :pool_contract);\n```\nUpto this point, delegators can simply delegate their `BTC` tokens to this pool since the trace has been initialized with the current epoch. \n\n**Assumptions**\n\n- The staker sets a very small commission of `2%`.\n- The staker already had `STRK` pool in `V1` with `pool_info._deprecated_commission` of `40%`, which he has not migrated.\n- New delegators have onboarded their new `BTC` pool with knowledge that commission is `2%`.\n\nNow the staker is about to perform `attestation` which should distribute and split rewards based on the `staker_pool_info.commission` i.e `2%`\nHe then invokes `staker_migration()`:\n```rust\n    fn staker_migration(ref self: ContractState, staker_address: ContractAddress) {\n        // @audit Assertion passes\n        assert!(\n>>          self.staker_own_balance_trace.entry(staker_address).is_empty(),\n            \"{}\",\n            Error::STAKER_INFO_ALREADY_UPDATED,\n        );\n        // Migrate staker pool info.\n        let internal_staker_info = self.internal_staker_info(:staker_address);\n        let staker_pool_info_mut = self.staker_pool_info.entry(staker_address);\n        let mut pool_contract = Option::None;\n        // @audit fetches his STRK pool from v1\n>>      if let Option::Some(pool_info) = internal_staker_info._deprecated_pool_info {\n            pool_contract = Option::Some(pool_info._deprecated_pool_contract);\n            let token_address = STRK_TOKEN_ADDRESS;\n            // @audit old commision from v1 fetched\n>>          let commission = pool_info._deprecated_commission;\n            // @audit previously set commission is overwritten\n>>          staker_pool_info_mut.commission.write(Option::Some(commission));\n            staker_pool_info_mut.pools.write(pool_contract.unwrap(), token_address);\n        }\n        // Note: Staker might have a commission commitment only if he has a pool.\n        staker_pool_info_mut\n            .commission_commitment\n            .write(internal_staker_info._deprecated_commission_commitment);\n        // @audit staker_own_balance_trace is then populated here\n>>      self.migrate_staker_balance_trace(:staker_address, :pool_contract);\n        // Add staker address to the stakers vector.\n        self.stakers.push(staker_address);\n    }\n```\nAs seen, the first assertion passes because upto this point, the staker's `staker_own_balance_trace` mapping is empty. This is a `V2` feature, and since he has not performed any stake here, there is no record present.\n\nThe function then checks if he has a `STRK` pool which he does from `V1`. The `pool_info._deprecated_commission` i.e `40%` from `V1` is then retrieved and set to `staker_pool_info_mut.commission` and that pool also added to his `staker_pool_info_mut.pools`. As such, the previously set `2%` commission that the `BTC` delegators subscribed to is overwritten and updated to `40%`.\n\nThe staker then performs attestation, and the following happens in `calculate_staker_pools_rewards()` via the `update_rewards_from_attestation_contract()` call.\n```rust\n            // @audit 40% is fetched\n>>          let commission = staker_pool_info.commission();\n            let curr_epoch = self.get_current_epoch();\n            for (pool_contract, token_address) in staker_pool_info.pools {\n                if !self.is_active_token(:token_address, :curr_epoch) {\n                    continue;\n                }\n                let pool_balance_curr_epoch = self\n                    .get_staker_delegated_balance_curr_epoch(\n                        :staker_address, :pool_contract, :curr_epoch,\n                    );\n                let (epoch_rewards, total_stake) = if token_address == STRK_TOKEN_ADDRESS {\n                    (strk_epoch_rewards, strk_total_stake)\n                } else {\n                    (btc_epoch_rewards, btc_total_stake)\n                };\n                // Calculate rewards for this pool.\n                let pool_rewards_including_commission = if total_stake.is_non_zero() {\n                    mul_wide_and_div(\n                        lhs: epoch_rewards,\n                        rhs: pool_balance_curr_epoch.to_amount_18_decimals(),\n                        div: total_stake,\n                    )\n                        .expect_with_err(err: GenericError::REWARDS_ISNT_AMOUNT_TYPE)\n                } else {\n                    Zero::zero()\n                };\n                // @audit staker's commission_rewards is calculated based on 40% even for BTC stakes\n>>              let (commission_rewards, pool_rewards) = self\n                    .split_rewards_with_commission(\n                        rewards_including_commission: pool_rewards_including_commission,\n                        :commission,\n                    );\n\n                // @audit Staker accumulates excess\n>>              total_commission_rewards += commission_rewards;\n                ---snip---\n            }\n```\nAs seen, the `BTC` delegators are rugged as they receive far less `pool_rewards` than they should.\n\nThis is an issue because by normal flow, a staker is not supposed to be in a position to increase their `commission` once set if they lack `commission_commitment` as enforced in `update_commission()`.\n```rust\n            else {\n>>              assert!(commission < old_commission, \"{}\", GenericError::INVALID_COMMISSION);\n            }\n```\n\n## Recommendations\n\nAdd this check in `set_commission()`:\n```diff\n        // Assert the staker has migrated.\n+       assert!(\n+           self.staker_own_balance_trace.entry(staker_address).is_non_empty(),\n+           \"{}\",\n+           Error::STAKER_INFO_NOT_UPDATED,\n+       );\n```\n\n\n\n",
    "summary": "\nThe bug report is about a function called `set_commission()` which allows a staker to set their commission without checking if they have migrated to a newer version of the function. This is a problem because it allows a staker to set a commission that is different from what was agreed upon by the delegators. This bug can be fixed by adding a check in the function to make sure that the staker has migrated to the newer version before setting their commission. This check should be added in the `set_commission()` function.",
    "report_date": "2025-09-03T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/Starknet-security-review_2025-07-31.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "m-01-staker-may-exploit-delegators-by-setting-commission-pre-migration-pashov-audit-group-none-starknet_2025-07-31-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "Starknet_2025-07-31",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "Starknet_2025-07-31",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}