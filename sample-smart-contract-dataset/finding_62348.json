{
    "id": 62348,
    "kind": "MARKDOWN",
    "auditfirm_id": 11,
    "impact": "HIGH",
    "finders_count": 3,
    "protocol_id": 3402,
    "title": "Swap-and-pop without index fix-up corrupts `Position`’s fungible array",
    "content": "**Description:** [`Position`](https://github.com/Licredity/licredity-v1-core/blob/e8ae10a7d9f27529e39ca277bf56cef01a807817/src/types/Position.sol#L10-L16) tracks fungible collateral in **two places** that must stay in sync:\n\n```solidity\nstruct Position {\n    address owner;\n    uint256 debtShare;\n    Fungible[] fungibles;                       // compact list of held assets\n    NonFungible[] nonFungibles;\n    mapping(Fungible => FungibleState) fungibleStates; // per-asset {index,balance}\n}\n```\n\nInvariant: for every asset `a` in `fungibles[k]`, we must have `fungibleStates[a].index == k+1` (the library uses 1-based indexes; `index == 0` means “not present”).\n\nWhen an asset’s balance goes to zero, [`Position::removeFungible`](https://github.com/Licredity/licredity-v1-core/blob/e8ae10a7d9f27529e39ca277bf56cef01a807817/src/types/Position.sol#L70-L114) tries to \"swap-and-pop\": move the last array element into the removed slot and shrink the array. The code does the array move, but forgets to update the moved element’s cached index in `fungibleStates`:\n\n```solidity\n// remove a fungible from the fungibles array\nassembly (\"memory-safe\") {\n    let slot := add(self.slot, FUNGIBLES_OFFSET)\n    let len := sload(slot)\n    mstore(0x00, slot)\n    let dataSlot := keccak256(0x00, 0x20)\n\n    if iszero(eq(index, len)) {\n        // overwrite removed slot with the last element (swap)\n        sstore(add(dataSlot, sub(index, 1)), sload(add(dataSlot, sub(len, 1))))\n    }\n\n    // pop\n    sstore(add(dataSlot, sub(len, 1)), 0)\n    sstore(slot, sub(len, 1))\n}\n```\n\nWhat’s missing is the index fix-up for the element that got moved down from the tail. Without it, `fungibleStates[moved].index` still points to the old tail index.\n\nWhy this corrupts state:\n\n1. Start with `fungibles = [A, B, C]` and\n\n   ```\n   index(A)=1, index(B)=2, index(C)=3\n   ```\n2. Remove `A` (index=1). Code copies last element `C` into slot 0 and pops the array:\n\n   ```\n   fungibles = [C, B], length=2\n   ```\n\n   But `index(C)` is still 3 (stale).\n3. Later, remove `C`. The function trusts the stale `index(C)=3`:\n\n   * It tries to “swap-and-pop” using `index=3` and `len=2`, which makes it copy `B` into slot `index-1 = 2` (past the new end), then pops slot 1.\n   * Net effect: `B` silently vanishes from the active array (`length` becomes 1 and `fungibles[0]` may still be `C`), while `fungibleStates[B]` still shows a positive balance.\n\nThis desynchronizes the array and mapping, leading to:\n\n* “Remove X, but actually lose Y” behavior (wrong element disappears).\n* “Ghost” balances left in the mapping not represented in the array (appraisal that iterates `fungibles` under-counts value).\n* Future removals/operations using stale indexes read/write the wrong slots.\n\n**Impact**\n\n* Inconsistent state between `fungibles[]` and `fungibleStates` (stale or duplicate indexes).\n* Removing token `X` can unexpectedly remove token `Y` from the array.\n* Enumeration-based logic (e.g., valuation/appraisal that iterates `fungibles[]`) may under- or over-count positions, leading to incorrect health/accounting decisions.\n\n**Proof of Concept:** Place the following test and helper functions in `LicredityUnlockPosition.t.sol`:\n```solidity\nfunction test_removeFungible_missingIndexFixup() public {\n    BaseERC20Mock token = _newAsset(18);\n    Fungible fungible = Fungible.wrap(address(token));\n    // --- arrange: two fungibles in the same position ---\n    token.mint(address(this), 1 ether);\n    token.approve(address(licredityRouter), 1 ether);\n\n    uint256 positionId = licredityRouter.open();\n\n    // deposit native (will be fungibles[0])\n    licredityRouter.depositFungible{value: 0.5 ether}(positionId, Fungible.wrap(ChainInfo.NATIVE), 0.5 ether);\n\n    // deposit ERC20 (will be fungibles[1])\n    licredityRouter.depositFungible(positionId, fungible, 1 ether);\n\n    // --- discover storage slots we need (once per test is fine) ---\n    // We'll find:\n    //  - the base slot of positions[positionId] (self.slot)\n    //  - the fungibleStates mapping base slot: self.slot + FUNGIBLE_STATES_OFFSET\n    //  - the fungibles array slot: self.slot + FUNGIBLES_OFFSET\n    (\n        ,\n        uint256 fungibleStatesBase,\n        uint256 fungiblesArraySlot\n    ) = _locatePositionFungibleStateAndArraySlots(positionId, address(licredity), address(token));\n\n    // Sanity: array length is 2\n    uint256 lenBefore = uint256(vm.load(address(licredity), bytes32(fungiblesArraySlot)));\n    assertEq(lenBefore, 2, \"pre: fungibles length should be 2\");\n\n    // Pre-read the packed FungibleState word for the ERC20 (this includes index + balance)\n    bytes32 stateBefore = _loadFungibleState(\n        address(licredity),\n        fungibleStatesBase,\n        address(token)\n    );\n\n    // Also read the array’s first element (should be native) and second (should be ERC20)\n    bytes32 dataSlot = keccak256(abi.encodePacked(bytes32(fungiblesArraySlot)));\n    bytes32 arr0Before = vm.load(address(licredity), dataSlot);                 // [0]\n    bytes32 arr1Before = vm.load(address(licredity), bytes32(uint256(dataSlot) + 1)); // [1]\n    assertEq(address(uint160(uint256(arr0Before))), address(0), \"pre: [0] must be native\");\n    assertEq(address(uint160(uint256(arr1Before))), address(token), \"pre: [1] must be ERC20\");\n\n    // --- act: remove the non-last fungible (native) fully -> triggers swap-and-pop ---\n    licredityRouterHelper.withdrawFungible(positionId, address(this), ChainInfo.NATIVE, 0.5 ether);\n\n    // --- assert: array element moved down, BUT ERC20's state word did not change (index not fixed up) ---\n\n    // array length dropped to 1\n    uint256 lenAfter = uint256(vm.load(address(licredity), bytes32(fungiblesArraySlot)));\n    assertEq(lenAfter, 1, \"post: fungibles length should be 1\");\n\n    // array[0] should now hold the ERC20 address (moved from index 1 -> 0)\n    bytes32 arr0After = vm.load(address(licredity), dataSlot);\n    assertEq(address(uint160(uint256(arr0After))), address(token), \"post: [0] must be ERC20\");\n\n    // read ERC20's packed state again\n    bytes32 stateAfter = _loadFungibleState(\n        address(licredity),\n        fungibleStatesBase,\n        address(token)\n    );\n\n    // Because we removed NATIVE entirely and did not touch ERC20 balance,\n    // a correct implementation would ONLY change the ERC20's *index* inside the word.\n    // Since the code does not fix up the index, the word stays identical.\n    assertEq(stateAfter, stateBefore, \"post: ERC20 FungibleState word unchanged (index not fixed up)\");\n}\n\n// Probe storage to find (self.slot, self.slot + FUNGIBLE_STATES_OFFSET, self.slot + FUNGIBLES_OFFSET).\n// Heuristic: after two deposits, the fungibles array length is 2 and\n// the fungibleStates mapping for both keys (native, token) are non-zero.\nfunction _locatePositionFungibleStateAndArraySlots(\n    uint256 positionId,\n    address target,\n    address erc20\n)\n    internal\n    view\n    returns (uint256 selfSlot, uint256 fungibleStatesBase, uint256 fungiblesArraySlot)\n{\n    // positions is a mapping at some slot S. The Position struct lives at keccak256(positionId, S).\n    // We search S∈[0..160], and offsets off∈[0..24] for the two sub-structures.\n    for (uint256 S = 0; S <= 160; S++) {\n        bytes32 self = keccak256(abi.encode(positionId, S));\n\n        // try to locate the mapping base (self + offMap) by checking both keys are non-zero\n        for (uint256 offMap = 0; offMap <= 24; offMap++) {\n            uint256 candMapBase = uint256(self) + offMap;\n\n            bytes32 nativeState = _loadFungibleState(target, candMapBase, address(0));\n            bytes32 erc20State  = _loadFungibleState(target, candMapBase, erc20);\n\n            if (nativeState != bytes32(0) && erc20State != bytes32(0)) {\n                // now also find the array slot (self + offArr) where length == 2\n                for (uint256 offArr = 0; offArr <= 24; offArr++) {\n                    uint256 candArrSlot = uint256(self) + offArr;\n                    uint256 len = uint256(vm.load(target, bytes32(candArrSlot)));\n                    if (len == 2) {\n                        // double-check array contents look like [native, erc20]\n                        bytes32 dataSlot = keccak256(abi.encodePacked(bytes32(candArrSlot)));\n                        address a0 = address(uint160(uint256(vm.load(target, dataSlot))));\n                        address a1 = address(\n                            uint160(uint256(vm.load(target, bytes32(uint256(dataSlot) + 1))))\n                        );\n                        if (a0 == address(0) && a1 == erc20) {\n                            return (uint256(self), candMapBase, candArrSlot);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    revert(\"could not locate position/fungible storage layout\");\n}\n\nfunction _loadFungibleState(address target, uint256 mapBaseSlot, address asset)\n    internal\n    view\n    returns (bytes32)\n{\n    // storage key for mapping: keccak256(abi.encode(key, slot))\n    bytes32 key = keccak256(\n        abi.encodePacked(bytes32(uint256(uint160(asset))), bytes32(mapBaseSlot))\n    );\n    return vm.load(target, key);\n}\n\nreceive() external payable {}\n```\n\n**Recommended Mitigation:** Update `index` to point at the moved entry:\n```solidity\n// (conceptually)\nFungible moved = fungibles[len-1];\nfungibles[index-1] = moved;\nfungibles.pop();\n\n// fix cached index for the moved element\nfungibleStates[moved].index = index;  // 1-based\n```\n\n**Licredity:** Fixed in [PR#64](https://github.com/Licredity/licredity-v1-core/pull/64/files), commit [`ad095fc`](https://github.com/Licredity/licredity-v1-core/commit/ad095fc6d2de3f61f6c48ddfe60b98eff410f50d)\n\n**Cyfrin:** Verified. Index is now updated.\n\n\\clearpage",
    "summary": "\nThe bug report discusses an issue with the `Position` function in the Licredity smart contract. This function keeps track of fungible collateral in two places, but they must stay in sync. However, when an asset's balance goes to zero, the `Position::removeFungible` function tries to move the last array element into the removed slot and shrink the array, but forgets to update the moved element's cached index. This results in inconsistent state between the array and mapping, potentially leading to incorrect health/accounting decisions. The report includes a proof of concept and recommended mitigation, and the bug has since been fixed. ",
    "report_date": "2025-09-01T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-09-01-cyfrin-licredity-v2.0.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "swap-and-pop-without-index-fix-up-corrupts-positions-fungible-array-cyfrin-none-licredity-markdown",
    "firm_name": "Cyfrin",
    "firm_logo_square": "Cyfrin_square.jpg",
    "protocol_name": "Licredity",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Immeas"
            }
        },
        {
            "wardens_warden": {
                "handle": "Alexzoid"
            }
        },
        {
            "wardens_warden": {
                "handle": "ChainDefenders](https://x.com/ChDefendersEth) ([0x539](https://x.com/1337web3) & [PeterSR"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
    },
    "protocols_protocol": {
        "name": "Licredity",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}