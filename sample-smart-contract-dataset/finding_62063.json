{
    "id": 62063,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 2159,
    "title": "[H-03] Utilization ratio can exceed 100% due to missing validation in withdrawal functions",
    "content": "\n\n<https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/pool/src/pool/actions.rs# L382>\n\n### Finding description\n\nThe protocol implements a maximum utilization ratio check via the `require_utilization_below_max` function, which ensures that `utilization = total_liabilities / total_supply` remains below a specific threshold. However, this validation is only enforced in the `apply_borrow` function when increasing liabilities, and is critically missing from the `apply_withdraw` and `apply_withdraw_collateral` functions.\n\nSince withdrawals reduce the `total_supply` denominator in the `utilization` formula, large withdrawals can cause the utilization ratio to increase beyond the intended maximum threshold. These seems intentional but there are downsides when utilization exceeds 100%. The extra amounts can come from `backstop_interest` or donations.\n\n### Impact\n\n1. **Unbounded Interest Rates**: The protocolâ€™s interest rate models uses utilization ratio as a key input. When utilization exceeds 100%, the interest rate calculation can produce extreme values.\n2. **Market Instability**:\n\n   * Extended periods with utilization ratio above 100% can lead to liquidations, bad debt accumulation and potential protocol insolvency.\n   * `backstop_interest_auction` might not work because the interest has been lent out\n\n### Proof of Concept\n\nThis was slightly modified from [`test_build_actions_from_request_withdraw_allows_over_max_util`](https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/pool/src/pool/actions.rs# L664)\n```\n\n#[test]\nfn test_build_actions_from_request_withdraw_allows_over_100_util() {\n    let e = Env::default();\n    e.mock_all_auths();\n\n    let bombadil = Address::generate(&e);\n    let samwise = Address::generate(&e);\n    let pool = testutils::create_pool(&e);\n\n    let (underlying, _) = testutils::create_token_contract(&e, &bombadil);\n    let (mut reserve_config, mut reserve_data) = testutils::default_reserve_meta();\n    reserve_config.max_util = 0_9000000;\n    reserve_data.b_supply = 100_0000000;\n    reserve_data.d_supply = 89_0000000;\n    testutils::create_reserve(&e, &pool, &underlying, &reserve_config, &reserve_data);\n\n    e.ledger().set(LedgerInfo {\n        timestamp: 600,\n        protocol_version: 22,\n        sequence_number: 1234,\n        network_id: Default::default(),\n        base_reserve: 10,\n        min_temp_entry_ttl: 10,\n        min_persistent_entry_ttl: 10,\n        max_entry_ttl: 3110400,\n    });\n    let pool_config = PoolConfig {\n        oracle: Address::generate(&e),\n        min_collateral: 1_0000000,\n        bstop_rate: 0_2000000,\n        status: 0,\n        max_positions: 2,\n    };\n\n    let user_positions = Positions {\n        liabilities: map![&e],\n        collateral: map![&e],\n        supply: map![&e, (0, 20_0000000)],\n    };\n    e.as_contract(&pool, || {\n        storage::set_pool_config(&e, &pool_config);\n        storage::set_user_positions(&e, &samwise, &user_positions);\n\n        let mut pool = Pool::load(&e);\n\n        let requests = vec![\n            &e,\n            Request {\n                request_type: RequestType::Withdraw as u32,\n                address: underlying.clone(),\n                // diff1 from: amount: 2_0000000,\n                amount: 20_0000000,\n            },\n        ];\n        let mut user = User::load(&e, &samwise);\n        let actions = build_actions_from_request(&e, &mut pool, &mut user, requests);\n\n        assert_eq!(actions.check_health, false);\n\n        let spender_transfer = actions.spender_transfer;\n        let pool_transfer = actions.pool_transfer;\n        assert_eq!(spender_transfer.len(), 0);\n        assert_eq!(pool_transfer.len(), 1);\n        // diff2 from: assert_eq!(pool_transfer.get_unchecked(underlying.clone()), 2_0000000);\n        assert_eq!(pool_transfer.get_unchecked(underlying.clone()), 20_0000000);\n\n        let positions = user.positions.clone();\n        assert_eq!(positions.liabilities.len(), 0);\n        assert_eq!(positions.collateral.len(), 0);\n        assert_eq!(positions.supply.len(), 1);\n        // diff3 from: assert_eq!(user.get_supply(0), 18_0000111);\n        assert_eq!(user.get_supply(0), 1110);\n\n        // diff4: add utilization rate check\n        let reserve = pool.load_reserve(&e, &underlying.clone(), false);\n        assert_eq!(reserve.utilization(&e), 1_1125010);\n    });\n}\n```\n\n### Recommended Mitigation\n\nAdd the `require_utilization_below_max` validation to both the `apply_withdraw` and `apply_withdraw_collateral` functions. This ensures that all operations that could potentially increase the utilization ratio (either by increasing liabilities or decreasing supply) are properly validated against the maximum threshold. If you want to permit withdrawal beyond threshold, add a `require_utilization_below_100` for withdrawals.\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [PR 48](https://github.com/blend-capital/blend-contracts-v2/pull/48) - Validate if util is below 100% when doing withdraw actions (see [commit](https://github.com/blend-capital/blend-contracts-v2/commit/f35271bd660470e1d3037ed03302e612821c4add)).\n\n**Status:** Mitigation confirmed. Full details in reports from [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-41), [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-18), [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-68) and [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-23).\n\n---\n\n---\n\n",
    "summary": "\nThis bug report discusses an issue with the utilization ratio check in the protocol's `apply_withdraw` and `apply_withdraw_collateral` functions. These functions do not properly validate the utilization ratio, which can lead to unbounded interest rates and market instability. A proof of concept is provided, and a recommended mitigation is to add a `require_utilization_below_max` validation in both functions. The bug has been confirmed and mitigated by the development team. ",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-15",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "h-03-utilization-ratio-can-exceed-100-due-to-missing-validation-in-withdrawal-functions-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "0x007"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}