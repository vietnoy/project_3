{
    "id": 62887,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "HIGH",
    "finders_count": 4,
    "protocol_id": 3419,
    "title": "Incorrect update to validator accumulators on syscall_epoch_change",
    "content": "## Severity: High Risk\n\n## Context\n(No context files were provided by the reviewer)\n\n## Description\n(Issue found in commit hash `1a7f9476081abc734fc6fa359698c3b8f9806576`). \n\nIn `syscall_epoch_change`, we attempt to update all the accumulators of validators present in the snapshot view at the beginning of a new epoch. This is meant to store the accumulator at the beginning for the epoch to calculate rewards for `delta_stake`.\n\n```cpp\nuint64_t const num_active_vals = vars._valset_snapshot().length();\nfor (uint64_t i = 0; i < num_active_vals; i += 1) {\n    auto const val_id = vars.valset_execution.get(i).load();\n    auto val = vars.val_execution(val_id);\n    // TODO: once Maged/quotesingle.ts1s speculative execution is merged, move this\n    // into a separate loop.\n    {\n        auto acc_storage = vars.acc(next_epoch, val_id);\n        auto acc = acc_storage.load_checked();\n        if (acc.has_value()) {\n            acc->value = val.acc().load(); // this is the realtime val.acc\n            acc_storage.store(*acc); // store in the next_epoch\n        }\n    }\n    // ...\n}\n```\n\nThe problem with the above code is that we fetch the validators to update by index from `valset_execution`. However, this may not actually correspond to the actual snapshot validators as `valset_execution` may still contain non-snapshot validators. A concrete scenario where this could happen would be the following:\n\n1. Initially, there are 201 validators ordered from index [0, 1, 2 ... 200] in `valset_execution` where `valset_execution[i+1].stake > valset_execution[i].stake` for all `i` (stakes are in ascending order).\n2. During `syscall_snapshot`, we place the top 200 validators into the consensus view. Thus the `valset_consensus` will contain the validator [1, 2 ... 200] by index from `valset_execution`. Importantly, validator index 0 in `valset_execution` is not removed as it is not added to the removals array (since `flags == ValidatorFlagsOk`), so `valset_execution` still remains [0, 1, 2 ... 200].\n\n```cpp\nuint64_t const num_validators = vars.valset_execution.length();\nfor (uint64_t i = 0; i < num_validators; i += 1) {\n    auto const val_id = vars.valset_execution.get(i).load();\n    auto const val_execution = vars.val_execution(val_id);\n    // TODO: once Maged/quotesingle.ts1s speculative execution is merged, move this\n    // into a separate loop.\n    auto const flags = val_execution.get_flags();\n    if (MONAD_LIKELY(flags == ValidatorFlagsOk)) {\n        uint256_t const stake = val_execution.stake().load().native();\n        heap.emplace(val_id, stake);\n        if (heap.size() > ACTIVE_VALSET_SIZE) {\n            heap.pop(); // smallest element removed\n        }\n    }\n    else {\n        removals.push_back(i);\n    }\n}\n```\n\n3. On the next `next_epoch` change, where `valset_consensus` will become `valset_snapshot` after the boundary block, the new accumulators for each validator in the snapshot validator set that has passed through the epoch will need to be computed.\n\nHowever, referring to the first code snippet, the first 200 active validators of `valset_execution` will have their accumulators updated, meaning that [0, 1, 2 ... 199] present in `valset_execution` will be updated. However, in actual fact, `valset_snapshot` consists of [1, 2 ... 199, 200] present in `valset_execution`, thus not all snapshot validators will have their accumulators updated.\n\nAnother scenario would be that if a validator auth address withdraws all its stake while it is active in the current `valset_consensus`. When `syscall_snapshot` is called, this validator would be removed from `valset_execution`. However, since it is currently in `valset_consensus`, it must be retained in `valset_snapshot` after the boundary block. When iterating through `valset_execution` during `syscall_epoch_change`, the validator present in `valset_snapshot` will not be accessible in `valset_execution` and thus its accumulator will not be updated.\n\n## Recommendation\nIt should not be assumed that the first N validators in `valset_execution` are present in `valset_snapshot`. You need to iterate through each item in `valset_snapshot` to obtain the correct `val_id`.\n\n## Category\nLabs: Fixed in commit `fc820c9e`.\n\n## Spearbit\nFix verified.",
    "summary": "\nThis bug report is about an issue found in the code for updating validators' accumulators at the beginning of a new epoch. The problem is that the code assumes that the first N validators in `valset_execution` are present in `valset_snapshot`, but this may not always be the case. This can result in incorrect accumulator values for some validators. The recommended solution is to iterate through each item in `valset_snapshot` to obtain the correct `val_id`. This bug has been fixed in the latest commit.",
    "report_date": "2025-09-19T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Monad-Spearbit-Security-Review-September-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Monad-Spearbit-Security-Review-September-2025.pdf",
    "pdf_page_from": 10,
    "contest_id": "",
    "slug": "incorrect-update-to-validator-accumulators-on-syscall_epoch_change-spearbit-none-monad-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Monad",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Haxatron"
            }
        },
        {
            "wardens_warden": {
                "handle": "Dtheo"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guido Vranken"
            }
        },
        {
            "wardens_warden": {
                "handle": "Rikard Hjort"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Monad",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}