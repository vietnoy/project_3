{
    "id": 62070,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 3,
    "protocol_id": 2159,
    "title": "[M-07] Pool’s gulped emissions could be lost if a reserve has no supply",
    "content": "\n\nWhen a pool is added to the reward zone, some emissions get distributed to it, these emissions could be “claimed” by calling `gulp_emissions` on that pool, which calls `gulp_emissions` on the backstop module. The gulped emissions are distributed to different reserves (borrow or debt reserves), according to the reserves set by the pool admin in `pool_emissions`, by calling `set_emissions_config`.\n\nOn the other hand, after gulping these emissions, users who deposited into these reserves can claim their part by calling `claim` -> `claim_emissions`, which ultimately calls [`update_emission_data`](https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/pool/src/emissions/distributor.rs# L152-L185) and [`update_user_emissions`](https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/pool/src/emissions/distributor.rs# L187-L221):\n```\n\n    pub(super) fn update_emission_data(\n        e: &Env,\n        res_token_id: u32,\n        supply: i128,\n        supply_scalar: i128,\n    ) -> Option<ReserveEmissionData> {\n        match storage::get_res_emis_data(e, &res_token_id) {\n            Some(mut res_emission_data) => {\n                if res_emission_data.last_time >= res_emission_data.expiration\n                    || e.ledger().timestamp() == res_emission_data.last_time\n                    || res_emission_data.eps == 0\n@>                  || supply == 0\n                {\n                    return Some(res_emission_data);\n                }\n\n                // ... snip ...\n            }\n            None => return None, // no emission exist, no update is required\n        }\n    }\n\n    fn update_user_emissions(\n        e: &Env,\n        res_emis_data: &ReserveEmissionData,\n        res_token_id: u32,\n        supply_scalar: i128,\n        user: &Address,\n        balance: i128,\n        claim: bool,\n    ) -> i128 {\n        if let Some(user_data) = storage::get_user_emissions(e, user, &res_token_id) {\n            if user_data.index != res_emis_data.index || claim {\n                let mut accrual = user_data.accrued;\n@>              if balance != 0 {\n                    // ... snip ...\n                }\n                return set_user_emissions(e, user, res_token_id, res_emis_data.index, accrual, claim);\n            }\n            0\n        } else if balance == 0 {\n            // first time the user registered an action with the asset since emissions were added\n            return set_user_emissions(e, user, res_token_id, res_emis_data.index, 0, claim);\n        } else {\n            // user had tokens before emissions began, they are due any historical emissions\n            let to_accrue =\n                balance.fixed_mul_floor(e, &res_emis_data.index, &(supply_scalar * SCALAR_7));\n            return set_user_emissions(e, user, res_token_id, res_emis_data.index, to_accrue, claim);\n        }\n    }\n```\n\nAs shown, both check if the balance/supply is `>0` to go ahead with the claiming, in other words, if no balance/supply nothing happens.\n\nHowever, this check is not available when gulping and distributing the emissions between reserves, in [`do_gulp_emissions`](https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/pool/src/emissions/manager.rs# L79-L106).\n\nAs a result, if a reserve has 0 supply, but it is already added in the pool emissions (and maybe not removed yet), any emissions incoming, that reserve’s part will be lost forever, as it can never be claimed.\n\n### Proof of Concept\n\nAdd the following test in `blend-contracts-v2/pool/src/emissions/manager.rs`:\n```\n\n#[test]\nfn test_lost_emissions() {\n    let e = Env::default();\n    e.mock_all_auths();\n    e.ledger().set(LedgerInfo {\n        timestamp: 1500000000,\n        protocol_version: 22,\n        sequence_number: 20100,\n        network_id: Default::default(),\n        base_reserve: 10,\n        min_temp_entry_ttl: 10,\n        min_persistent_entry_ttl: 10,\n        max_entry_ttl: 3110400,\n    });\n\n    let pool = testutils::create_pool(&e);\n    let bombadil = Address::generate(&e);\n\n    let new_emissions: i128 = 100_0000000;\n\n    let (reserve_config, reserve_data) = testutils::default_reserve_meta();\n    let (underlying_0, _) = testutils::create_token_contract(&e, &bombadil);\n    testutils::create_reserve(&e, &pool, &underlying_0, &reserve_config, &reserve_data);\n    let (underlying_1, _) = testutils::create_token_contract(&e, &bombadil);\n    testutils::create_reserve(&e, &pool, &underlying_1, &reserve_config, &reserve_data);\n\n    e.as_contract(&pool, || {\n        // only b_supply received emissions\n        storage::set_pool_emissions(&e, &map![&e, (0, 0_5000000), (2, 0_5000000)]);\n\n        do_gulp_emissions(&e, new_emissions);\n\n        let mut res_emis_data_0 = storage::get_res_emis_data(&e, &0).unwrap_optimized();\n        let mut res_emis_data_2 = storage::get_res_emis_data(&e, &2).unwrap_optimized();\n\n        // R0 and R2 have 0 emission indexes\n        assert!(res_emis_data_0.index == res_emis_data_2.index && res_emis_data_0.index == 0);\n\n        // R0 and R2 have the same last_time as now\n        assert!(\n            res_emis_data_0.last_time == res_emis_data_2.last_time\n                && res_emis_data_0.last_time == 1500000000\n        );\n\n        // R0 and R2 have the same eps\n        assert!(\n            res_emis_data_0.eps == res_emis_data_2.eps && res_emis_data_0.eps == 8267195767\n        );\n\n        e.ledger()\n            .set_timestamp(e.ledger().timestamp() + (24 * 60 * 60));\n\n        // R0 has no more d_supply\n        let mut reserve_data_0 = storage::get_res_data(&e, &underlying_0);\n        reserve_data_0.d_supply = 0;\n        storage::set_res_data(&e, &underlying_0, &reserve_data_0);\n\n        // New emissions are gulped\n        do_gulp_emissions(&e, new_emissions);\n\n        res_emis_data_0 = storage::get_res_emis_data(&e, &0).unwrap_optimized();\n        res_emis_data_2 = storage::get_res_emis_data(&e, &2).unwrap_optimized();\n\n        // R0 index remains the same, 0\n        assert_eq!(res_emis_data_0.index, 0);\n        // R2 index is updated\n        assert_eq!(res_emis_data_2.index, 9523809523584);\n\n        // Both R0 and R2 last times are updated\n        assert!(\n            res_emis_data_0.last_time == res_emis_data_2.last_time\n                && res_emis_data_0.last_time == 1500086400\n        );\n\n        // Both R0 and R2 eps are updated\n        //  -> R0 should have its eps updated as it has some d_supply\n        //  -> R2 shouldn't have its eps updated as it has no d_supply (all emissions for R2 are lost, as they can't be claimed)\n        assert!(\n            res_emis_data_0.eps == res_emis_data_2.eps && res_emis_data_0.eps == 15353363558\n        );\n    });\n}\n```\n\n### Recommended mitigation steps\n\nIf a reserve doesn’t have a supply, skip its distribution, and if no reserves have a supply, block gulping emissions to avoid edge cases.\n```\n\n    fn do_gulp_emissions(e: &Env, new_emissions: i128) {\n        // ... snip..\n\n        let mut total_share: i128 = 0;\n        for (res_token_id, res_eps_share) in pool_emissions.iter() {\n            let reserve_index = res_token_id / 2;\n            let res_asset_address = reserve_list.get_unchecked(reserve_index);\n            let res_config = storage::get_res_config(e, &res_asset_address);\n\n+           let reserve_data = storage::get_res_data(e, &res_asset_address);\n+           let supply = match res_token_id % 2 {\n+               0 => reserve_data.d_supply,\n+               1 => reserve_data.b_supply,\n+               _ => panic_with_error!(e, PoolError::BadRequest),\n+           };\n\n-           if res_config.enabled {\n+           if res_config.enabled && supply > 0 {\n                pool_emis_enabled.push_back((\n                    res_config,\n                    res_asset_address,\n                    res_token_id,\n                    res_eps_share,\n                ));\n                total_share += i128(res_eps_share);\n            }\n        }\n+       if pool_emis_enabled.len() == 0 {\n+           panic_with_error!(e, PoolError::BadRequest);\n+       }\n\n        // ... snip..\n    }\n```\n\n**markus\\_pl10 (Script3) disputed**\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24?commentParent=rYrYcPWxFAD):**\n\n> This is not an issue, and the suggested fix would cause more missed emissions than the current situation, in my opinion.\n>\n> When a reserve has 0 supply, it’s emissions data does not get updated. Once someone adds supply, they will receive all the emissions during the time it had zero supply.\n>\n> If the reserve has zero supply for long enough where we need to re-write the EPS / expiration, there is nothing we can do at that point to prevent lost emissions, from the time the reserve was set to 0 supply up to the pool `gulp_emissions` time period.\n>\n> Either:\n>\n> 1. The previous emissions are lost where 0 supply existed\n> 2. The reserve does not receive new emissions\n>\n> Given there is incentive to keep 1 as short as possible, it makes the most sense to keep the implementation as is, rather than have the reserve miss all new incoming emissions.\n\n**[LSDan (judge) decreased severity to Low and commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24?commentParent=rYrYcPWxFAD&commentChild=vs8ts9wy6uR):**\n\n> This seems highly unlikely, albeit possible. Downgrading to low.\n\n**[a\\_kalout (warden) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24?commentParent=XGsMRSgJggA):**\n\n> The sponsor presented a couple of points that I believe aren’t accurate, and I’d like to refute them.\n>\n> > This is not an issue, and the suggested fix would cause more missed emissions than the current situation, in my opinion.\n>\n> I’m afraid that’s not accurate. If the fix is implemented, any rewards that were for the 0 supply reserve would go to the other `>0` reserves. Why? Because `total_share` won’t account for the 0 supply, resulting in higher `new_reserve_emissions`, for all non-zero reserves:\n>\n> \n```\n\n> let new_reserve_emissions = i128(res_eps_share)\n>     .fixed_div_floor(e, &total_share, &SCALAR_7)\n>     .fixed_mul_floor(e, &new_emissions, &SCALAR_7);\n> \n```\n\n>\n> > When a reserve has 0 supply, it’s emissions data does not get updated. Once someone adds supply, they will receive all the emissions during the time it had zero supply.\n>\n> This is also not accurate. When emissions come in for 0 supply reserves, the emission data is indeed not updated (emission data index is not updated); however, the EPS is updated, and this is shown in the above PoC.\n> When someone adds some supply to a reserve that has “lost” emissions, his emission index would be set to the current supply’s emission index, in `update_user_emissions`. Later, when he tries to claim the “lost” emissions, it’ll be calculated as follows:\n>\n> \n```\n\n> if user_data.index != res_emis_data.index || claim {\n>     let mut accrual = user_data.accrued;\n>     if balance != 0 {\n>         let delta_index = res_emis_data.index - user_data.index;\n>         require_nonnegative(e, &delta_index);\n>         let to_accrue = balance.fixed_mul_floor(\n>             e,\n>             &(res_emis_data.index - user_data.index),\n>             &(supply_scalar * SCALAR_7),\n>         );\n>         accrual += to_accrue;\n>     }\n>     return set_user_emissions(e, user, res_token_id, res_emis_data.index, accrual, claim);\n> }\n> \n```\n\n>\n> Will `user_data.index` be != `res_emis_data.index`? No. So, no, all “lost” emissions are lost forever and can’t be claimed. Well.. if new emissions come in with supply `> 0` (after the deposit), only the new ones are claimable.\n>\n> > If the reserve has zero supply for long enough where we need to re-write the EPS / expiration, there is nothing we can do at that point to prevent lost emissions, from the time the reserve was set to 0 supply up to the pool `gulp_emissions` time period.\n>\n> I am not sure about the added value of re-writing the EPS/expiration. The recommended mitigation handles this perfectly, even if the reserve doesn’t receive emissions for ages, without any losses.\n>\n> Regarding the likelihood, first, I’d like to point out that for a specific asset, we have 2 reserves, b (supply) and d (debt). Having a 0 b supply is very unlikely, I agree; however, having a 0 d supply isn’t that rare. It’s pretty normal in lending protocols to have no loans issued for a specific asset.\n>\n> As a result, I respectfully believe this easily guarantees at least a medium severity. I would appreciate it if the judge could take another look at this.\n\n**[LSDan (judge) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24?commentParent=XGsMRSgJggA&commentChild=52KVVagWSWE):**\n\n> Thank you for the clarifications. On balance, I agree that the 0 d supply may not be super rare, but this still requires the admin to configure the protocol to send emissions to a pool with no activity, does it not?\n\n**[a\\_kalout (warden) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24?commentParent=XGsMRSgJggA&commentChild=JQFdmemzhTT):**\n\n> Hmm, not really. The emissions could be set to different reserves, for example, reserve X, which corresponds to a d supply (d or b depends on the key, whether even or odd), and the supply would go down to 0 (repay, withdraw, …), all emissions after that are lost, until the admin removes that from the emissions array.\n\n**[LSDan (judge) increased severity to Medium and commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24?commentParent=XGsMRSgJggA&commentChild=HBHuZ4ynUoX):**\n\n> Ok. I see the point. Reconstituting this as a medium.\n\n---\n\n",
    "summary": "\nThis bug report discusses an issue where emissions can be lost in the reward zone. When a pool is added to the reward zone, some emissions are distributed to it. These emissions can be claimed by calling `gulp_emissions` on the pool, which then calls `gulp_emissions` on the backstop module. However, if a reserve has a balance of 0, any incoming emissions will be lost and cannot be claimed. The bug report suggests adding a check to skip distribution to reserves with a balance of 0 and blocking emissions if all reserves have a balance of 0. A proof of concept test is also provided to demonstrate the issue. The recommended mitigation steps are to add the suggested check and block emissions if all reserves have a balance of 0. The severity of this bug has been increased to medium.",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-24",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-07-pools-gulped-emissions-could-be-lost-if-a-reserve-has-no-supply-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "alexxander"
            }
        },
        {
            "wardens_warden": {
                "handle": "aldarion"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xAlix2"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}