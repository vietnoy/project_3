{
    "id": 62248,
    "kind": "PDF",
    "auditfirm_id": 9,
    "impact": "MEDIUM",
    "finders_count": 3,
    "protocol_id": 3394,
    "title": "TON supply amount is locked when the gas check fails",
    "content": "## Diﬃculty: Low\n\n## Type: Data Validation\n\n**File:** `contracts_internal/contracts/core/master-supply-withdrawal.fc`\n\n### Description\n\nWhen a user supplies TON to the protocol, the supply amount can become permanently locked in the contract if the gas check fails. This occurs because the code reserves the supply amount before performing the gas check, preventing the refund message from accessing the reserved funds.\n\nIn the supply-withdrawal flow, when a user supplies TON, the code first calls `raw_reserve(supply_amount, reserve::AT_MOST + 2)` in the `supply_withdraw_ton` function to reserve the supply amount. If the subsequent gas check in the `master_core_logic_supply_withdraw` function fails (`msg_value < enough_fee`), the code attempts to refund the TON to the user by sending a message with `message_send_mode`. However, since the supply amount is already reserved, the refund message cannot access these funds, effectively locking them in the contract.\n\nThis issue could lead to users losing their TON if they do not provide enough gas for the transaction, as the reserved funds cannot be refunded. The same issue exists in the supply flow, where TON can be locked if the gas check fails.\n\n```plaintext\ncell master_core_logic_supply_withdraw(\n  [...]\n) impure {\n  [...]\n  int enough_fee = supply_withdraw_min_attachment(fwd_fee,\n    supply_withdraw_user_message) + ton_amount_for_repay_remainings;\n  if (msg_value < enough_fee) {\n    cell body =\n      begin_cell().store_op_code(error::supply_withdraw_master_transaction_fees)\n      .store_query_id(query_id).store_ref(custom_response_payload).end_cell();\n    if (supply_asset_id == constants::ton_asset_id) {\n      send_message(\n        initial_sender,\n        0,\n        body,\n        message_send_mode ;; if ton => we send 128 + raw reserve\n      );\n    } else {\n      [...]\n    }\n    return asset_dynamics_collection;\n  }\n  send_message_to_evaa_user_sc(\n    BLANK_CODE(), user_version, user_code, initial_sender,\n    supply_withdraw_user_message, message_send_mode, subaccount_id\n  );\n  return asset_dynamics_collection;\n}\n\ncell supply_withdraw_ton(\n  [...]\n) impure inline {\n  raw_reserve(supply_amount, reserve::AT_MOST + 2);\n  return master_core_logic_supply_withdraw(\n    [...]\n  );\n}\n```\n*Figure 3.1: The TON refund logic in supply-withdrawal flow in contracts_internal/contracts/core/master-supply-withdrawal.fc#L40–L97*\n\n### Exploit Scenario\n\nAlice wants to supply 100 TON to the protocol. She sends a transaction with 100 TON but includes only enough gas for a simple transfer, not accounting for the protocol’s gas requirements. When the transaction executes, the `supply_withdraw_ton` function first reserves her 100 TON using `raw_reserve`. Then the `master_core_logic_supply_withdraw` function performs the gas check and fails due to insufficient gas. The code attempts to refund the 100 TON to Alice, but this fails because the funds are already reserved and cannot be accessed by the refund message. As a result, Alice’s 100 TON becomes permanently locked in the contract with no way to recover it.\n\n### Recommendations\n\n- **Short term:** Move the `raw_reserve` call after the gas check in the `master_core_logic_supply_withdraw` function.\n- **Long term:** Implement a consistent pattern for handling gas checks and refunds across all asset types, and consider adding a recovery mechanism for locked funds in case similar issues occur in the future.",
    "summary": "\nThis bug report discusses a low difficulty issue related to data validation in the protocol's `master-supply-withdrawal` contract. When a user supplies TON to the protocol, their funds can become permanently locked if the gas check fails. This is because the code reserves the supply amount before performing the gas check, making it impossible for the refund message to access the reserved funds. This could result in users losing their TON if they do not provide enough gas for the transaction. The report also includes an example of how this issue could be exploited by a user. The recommendations for fixing this issue include moving the `raw_reserve` call and implementing a consistent pattern for handling gas checks and refunds for all asset types. ",
    "report_date": "2025-08-22T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/trailofbits/publications/blob/master/reviews/2025-08-evaafinance-securityreview.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2025-08-evaafinance-securityreview.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2025-08-evaafinance-securityreview.pdf",
    "pdf_page_from": 19,
    "contest_id": "",
    "slug": "ton-supply-amount-is-locked-when-the-gas-check-fails-trailofbits-none-evaa-finance-pdf",
    "firm_name": "TrailOfBits",
    "firm_logo_square": "trailofbits_square.png",
    "protocol_name": "EVAA Finance",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Kevin Valerio Trail of Bits PUBLIC"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guillermo Larregay"
            }
        },
        {
            "wardens_warden": {
                "handle": "Quan Nguyen"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "TrailOfBits",
        "logo_square": "trailofbits_square.png"
    },
    "protocols_protocol": {
        "name": "EVAA Finance",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}