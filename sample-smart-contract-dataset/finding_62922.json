{
    "id": 62922,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 3462,
    "title": "Losses across all adapters are not accounted before shares/assets are calculated to",
    "content": "## deposit/mint/redeem/withdraw\n\n## Severity: Medium Risk\n\n### Context\n(No context files were provided by the reviewer)\n\n### Description\nThe current flow of a user operation like deposit, mint, withdraw, or redeem is as follows:\n\n1. Execute `accrueInterest()` that will:\n   - Increase the `_totalAssets` by interest.\n   - Calculate and mint the `performanceFeeShares` and `managementFeeShares` shares for the performance/management users.\n   - Update the `lastUpdate` to `block.timestamp`.\n\n2. Calculate the amount of shares to be minted/burned (deposit/withdraw operation) via `previewDeposit`/`previewWithdraw` or assets to be pulled/withdrawn (mint/redeem operation) via `previewMint`/`previewRedeem`. Note that the `preview*` functions will also call `accrueInterestView()`; however, it will be a \"no-op\" since `accrueInterest()` has already been called at the very beginning, and at this point, `elapsed` will be equal to 0, resulting in an early return.\n\n3. Execute the `enter` (deposit/mint operation) or `exit` (withdraw/redeem operation) function. \n\nThe `enter` function mints the previously calculated shares to the user balance, increases `_totalAssets` by the deposited/pulled amount, and attempts to allocate that amount to the `liquidityAdapter` via the `allocate(...)` function if there's a `liquidityAdapter` configured. The `allocate` function called by `enter` will execute `adapter.allocate(...)` and account for the reported loss, subtracting it from `_totalAssets`. The `allocate()` function could revert if the `adapter.allocate` reverts or if the allocation for the adapter IDs has reached the upper bound.\n\nThe `exit` function checks if there are enough funds in the \"Idle Market.\" If that's the case, it will not execute the deallocate function; otherwise, it will attempt to deallocate how much is needed to perform the withdrawal by executing `deallocate(..., assets - idleAssets)` if the `liquidityAdapter` has been configured. After that, it will burn the already calculated shares from the user's balance and decrease `_totalAssets` by the amount of assets to be withdrawn. The `deallocate` function called by `exit` will execute `adapter.deallocate(...)` and account for the reported loss, subtracting it from `_totalAssets`.\n\n### Key Aspects and Issues\n1. `accrueInterest` is executed without incorporating the losses across all the adapters that the VaultV2 has allocated funds to. This means that `_totalAssets` may not be correctly synchronized with the \"reality.\" Consequently, both the `interestPerSecond` returned by `IVic.interestPerSecond(_totalAssets, elapsed)` and the shares (fees) calculated for the performance/management could be incorrect.\n\n2. The value returned by all the `preview*` functions could be wrong because losses across all the adapters have not been accounted for yet, which means the user could incur losses or earnings depending on the operation:\n   - For deposit, the loss is accounted for after the calculation of the shares to be minted. The user will receive fewer shares than expected, resulting in less underlying at redeem time.\n   - For mint, the protocol may \"pull\" more assets than necessary to mint the user's request, leading to less underlying at redeem time (potentially indicating too many underlying have been minted initially).\n   - For withdraw, the number of shares burned may be less than expected, reducing the value of other shares, leading to the need for other suppliers to burn more shares to withdraw their funds.\n   - For redeem, the user may receive more underlying than expected, resulting in a decrease in share value and necessitating that other users burn more shares to receive the same amount of underlying.\n\n3. The `enter` function could \"skip\" accounting for losses in the `liquidityAdapter` if `allocate` reverts (max allocation is reached).\n\n4. The `enter` function does not account for losses in the \"other\" adapters that are not `liquidityAdapter`.\n\n5. The `exit` function could \"skip\" accounting for losses in the `liquidityAdapter` if sufficient liquidity is available in the \"Idle Market,\" eliminating the need to deallocate.\n\n6. The `exit` function does not account for losses in the \"other\" adapters that are not `liquidityAdapter`.\n\n7. `forceDeallocate` can be exploited by withdrawers to avoid incurring a loss. If the `liquidityAdapter` has a loss and there's insufficient liquidity in the Idle Market, but there's an \"old\" adapter without loss and enough liquidity available, the logic can be exploited. The withdrawer can simply deallocate from that market and then execute a withdrawal call that only pulls from the Idle market. Refer to \"forceDeallocate allows user to avoid incurring in losses and dump them on other suppliers\" for more details.\n\n### Proof of Concept\nUser loses instant share value upon deposit:\n\n```solidity\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\nimport \"./BaseTest.sol\";\nimport {MorhoBlueAdapter} from \"../src/adapters/MorphoBlueAdapter.sol\";\nimport {MorphoBlueAdapterFactory} from \"../src/adapters/MorphoBlueAdapterFactory.sol\";\nimport {OracleMock} from \"../lib/morpho-blue/src/mocks/OracleMock.sol\";\nimport {IrmMock} from \"../lib/morpho-blue/src/mocks/IrmMock.sol\";\nimport {IMorpho, MarketParams, Id, Market, Position} from \"../lib/morpho-blue/src/interfaces/IMorpho.sol\";\nimport {MorphoBalancesLib} from \"../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\";\nimport {MarketParamsLib} from \"../lib/morpho-blue/src/libraries/MarketParamsLib.sol\";\nimport {IMorphoBlueAdapter} from \"../src/adapters/interfaces/IMorphoBlueAdapter.sol\";\nimport {IMorphoBlueAdapterFactory} from \"../src/adapters/interfaces/IMorphoBlueAdapterFactory.sol\";\n\ncontract SMBLossTest is BaseTest {\n    using MorphoBalancesLib for IMorpho;\n    using MarketParamsLib for MarketParams;\n    \n    // Morpho Blue\n    address morphoOwner;\n    MarketParams internal marketParams;\n    Id internal marketId;\n    IMorpho internal morpho;\n    OracleMock internal oracle;\n    IrmMock internal irm;\n    ERC20Mock internal collateralToken;\n    ERC20Mock internal loanToken; // This is the V2 underlying\n    bytes32[] internal expectedIds;\n    MorphoBlueAdapterFactory internal factoryMB;\n    MorphoBlueAdapter internal adapterMB;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function testLossBob() public {\n        // Setup Morpho Blue Market\n        _setupMB(underlyingToken);\n\n        // Setup Vault v2\n        _setupVV2(10_000e18, 1e18);\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n\n        // Alice deposit 100 DAI\n        _deposit(alice, 100e18);\n        \n        // MB has 50e18 DAI loss\n        _overrideMarketTotalSupplyAssets(-int256(50e18));\n        \n        // Bob deposit 100 DAI\n        _deposit(bob, 100e18);\n        \n        // Bob instantly redeems all his shares\n        vm.prank(bob);\n        vault.redeem(100e18, bob, bob);\n        \n        // From the redeem, Bob has withdrawn 75 DAI instead of 100 DAI\n        assertEq(underlyingToken.balanceOf(bob), 75e18);\n        \n        // Bob has no more shares to redeem\n        assertEq(vault.balanceOf(bob), 0);\n        \n        // Alice withdraws her shares\n        vm.prank(alice);\n        vault.redeem(100e18, alice, alice);\n        \n        // Alice redeems her 100e18 shares and will get 75 DAI too (instead of 50 DAI she should get because of the loss)\n        assertEq(underlyingToken.balanceOf(alice), 75e18);\n        \n        // Alice has no more shares to redeem\n        assertEq(vault.balanceOf(alice), 0);\n    }\n    \n    function _deposit(address user, uint256 amount) internal {\n        deal(address(underlyingToken), user, amount, true);\n        vm.prank(user);\n        underlyingToken.approve(address(vault), type(uint256).max);\n        \n        // Supply\n        vm.prank(user);\n        vault.deposit(amount, user);\n    }\n\n    function _withdraw(address user, uint256 amount) internal {\n        vm.prank(user);\n        vault.withdraw(amount, user, user);\n    }\n\n    function _setupVV2(uint256 absoluteCap, uint256 relativeCap) internal {\n        // Setup the MB adapter\n        vm.startPrank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.setIsAdapter, (address(adapterMB), true)));\n        vm.stopPrank();\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        vault.setIsAdapter(address(adapterMB), true);\n        // Setup the MB adapter as the main adapter\n        vm.prank(allocator);\n        vault.setLiquidityAdapter(address(adapterMB));\n        vm.prank(allocator);\n        vault.setLiquidityData(abi.encode(marketParams));\n        _increaseCaps(absoluteCap, relativeCap);\n    }\n\n    function _increaseCaps(uint256 absoluteCap, uint256 relativeCap) internal {\n        // Setup the absolute caps and relative caps\n        vm.startPrank(curator);\n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (abi.encode(\"adapter\", address(adapterMB)), absoluteCap)));\n        \n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (abi.encode(\"collateralToken\", marketParams.collateralToken), absoluteCap)));\n        \n        vault.submit(abi.encodeCall(IVaultV2.increaseAbsoluteCap, (abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv), absoluteCap)));\n        \n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (abi.encode(\"adapter\", address(adapterMB)), relativeCap)));\n        \n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (abi.encode(\"collateralToken\", marketParams.collateralToken), relativeCap)));\n        \n        vault.submit(abi.encodeCall(IVaultV2.increaseRelativeCap, (abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv), relativeCap)));\n        \n        vm.stopPrank();\n        vm.warp(vm.getBlockTimestamp() + 14 days);\n        \n        vault.increaseAbsoluteCap(abi.encode(\"adapter\", address(adapterMB)), absoluteCap);\n        vault.increaseAbsoluteCap(abi.encode(\"collateralToken\", marketParams.collateralToken), absoluteCap);\n        \n        vault.increaseAbsoluteCap(abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv), absoluteCap);\n        \n        vault.increaseRelativeCap(abi.encode(\"adapter\", address(adapterMB)), relativeCap);\n        vault.increaseRelativeCap(abi.encode(\"collateralToken\", marketParams.collateralToken), relativeCap);\n        \n        vault.increaseRelativeCap(abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv), relativeCap);\n    }\n\n    function _decreaseCaps(uint256 absoluteCap, uint256 relativeCap) internal {\n        // Setup the absolute caps and relative caps\n        vm.startPrank(curator);\n        vault.decreaseAbsoluteCap(abi.encode(\"adapter\", address(adapterMB)), absoluteCap);\n        vault.decreaseAbsoluteCap(abi.encode(\"collateralToken\", marketParams.collateralToken), absoluteCap);\n        \n        vault.decreaseAbsoluteCap(abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv), absoluteCap);\n        \n        vault.decreaseRelativeCap(abi.encode(\"adapter\", address(adapterMB)), relativeCap);\n        vault.decreaseRelativeCap(abi.encode(\"collateralToken\", marketParams.collateralToken), relativeCap);\n        \n        vault.decreaseRelativeCap(abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv), relativeCap);\n        vm.stopPrank();\n    }\n\n    function _setupMB(ERC20Mock v2Underlying) internal {\n        morphoOwner = makeAddr(\"MorphoOwner\");\n        morpho = IMorpho(deployCode(\"Morpho.sol\", abi.encode(morphoOwner)));\n        loanToken = v2Underlying;\n        collateralToken = new ERC20Mock();\n        oracle = new OracleMock();\n        irm = new IrmMock();\n        \n        marketParams = MarketParams({\n            loanToken: address(loanToken),\n            collateralToken: address(collateralToken),\n            irm: address(irm),\n            oracle: address(oracle),\n            lltv: 0.8 ether\n        });\n\n        vm.startPrank(morphoOwner);\n        morpho.enableIrm(address(irm));\n        morpho.enableLltv(0.8 ether);\n        vm.stopPrank();\n\n        morpho.createMarket(marketParams);\n        marketId = marketParams.id();\n        factoryMB = new MorphoBlueAdapterFactory(address(morpho));\n        adapterMB = MorphoBlueAdapter(factoryMB.createMorphoBlueAdapter(address(vault)));\n\n        expectedIds = new bytes32[](3);\n        expectedIds[0] = keccak256(abi.encode(\"adapter\", address(adapterMB)));\n        expectedIds[1] = keccak256(abi.encode(\"collateralToken\", marketParams.collateralToken));\n        expectedIds[2] = keccak256(abi.encode(\"collateralToken/oracle/lltv\", marketParams.collateralToken, marketParams.oracle, marketParams.lltv));\n    }\n\n    // Copied from the original MorphoBlueAdapter Test\n    function _overrideMarketTotalSupplyAssets(int256 change) internal {\n        bytes32 marketSlot0 = keccak256(abi.encode(marketId, 3)); // 3 is the slot of the market\n        bytes32 currentSlot0Value = vm.load(address(morpho), marketSlot0);\n        uint256 currentTotalSupplyShares = uint256(currentSlot0Value) >> 128;\n        uint256 currentTotalSupplyAssets = uint256(currentSlot0Value) & type(uint256).max;\n\n        bytes32 newSlot0Value = bytes32((currentTotalSupplyShares << 128) | uint256(int256(currentTotalSupplyAssets) + change));\n        vm.store(address(morpho), marketSlot0, newSlot0Value);\n        console.log('currentTotalSupplyShares', currentTotalSupplyShares);\n        console.log('currentTotalSupplyAssets', currentTotalSupplyAssets);\n    }\n}\n```\n\n### Recommendation\nThe only feasible way to correctly synchronize `_totalAssets` with the \"real\" value in the \"Idle Market\" and what is held in the adapters would be to iterate, as soon as possible, over all the adapters and account for the losses and interest. However, by doing so, the interest returned by the Vic would be \"useless\" at this point, making the VaultV2 implementation quite similar to what MetaMorpho already is.\n\n**Morpho:** Since PR 337, loss realization is incentivized, meaning that users must act faster than \"MEV\" to take advantage of this. This is crucial since Morpho Blue faces the same issue.\n\n**Spearbit:** The `realizeLoss` function implemented in the above PR allows anyone, in a permissionless manner, to realize losses in a whitelisted adapter. It's important to note that the assumption of this fix is that:\n1. Loss realization is performed before any further interaction with the vault.\n2. Loss realization is incentivized sufficiently to cover at least the gas cost of the operation, and then funds can be withdrawn (the caller receives shares, not underlying tokens).\n3. Loss realization is not front-run by someone else who could profit from that loss.",
    "summary": "",
    "report_date": "2025-10-13T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Morpho-Vaults-v2-Spearbit-Security-Review-May-2025.pdf",
    "pdf_page_from": 21,
    "contest_id": "",
    "slug": "losses-across-all-adapters-are-not-accounted-before-sharesassets-are-calculated-to-spearbit-none-morpho-vaults-v2-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Morpho Vaults v2",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Om Parikh"
            }
        },
        {
            "wardens_warden": {
                "handle": "Jonatas Martins"
            }
        },
        {
            "wardens_warden": {
                "handle": "Emmanuele Ricci"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Morpho Vaults v2",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}