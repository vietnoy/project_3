{
    "id": 62733,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 2,
    "protocol_id": 3324,
    "title": "M-10: Unenforced maxFee and ttl Parameters in sendMsg Function",
    "content": "\nSource: https://github.com/sherlock-audit/2025-07-malda-judging/issues/317 \n\n## Found by \n0xsai, yoooo\n\n### Summary\n\nIn the [EverclearBridge](https://github.com/sherlock-audit/2025-07-malda/blob/main/malda-lending/src/rebalancer/bridges/EverclearBridge.sol#L79) which is used by rebalancer to send cross-chain intents using `Everclear` does not enforce that the `maxFee` and `ttl` parameters are set to 0, as required for the netting pathway. The Everclear documentation specifies that rebalancers must use the netting pathway, where maxFee == 0 (no solver fees) and ttl == 0 (immediate processing by the hub). However, the contract passes these parameters to everclearFeeAdapter.newIntent without validation, allowing non-zero values that could misroute intents to the unsupported solver pathway. \n\n\n\n\n\n### Root Cause\n\nThe `sendMsg` function in `EverclearBridge.sol`  lacks validation checks to ensure `params.maxFee == 0 and params.ttl == 0` before calling everclearFeeAdapter.newIntent as specified in the everclear docs..\n```solidity\n    function sendMsg(\n        uint256 _extractedAmount,\n        address _market,\n        uint32 _dstChainId,\n        address _token,\n        bytes memory _message,\n        bytes memory // unused\n    ) external payable onlyRebalancer {\n        IntentParams memory params = _decodeIntent(_message);\n\n\n        require(params.inputAsset == _token, Everclear_TokenMismatch());\n        require(_extractedAmount >= params.amount, BaseBridge_AmountMismatch());\n\n\n        uint256 destinationsLength = params.destinations.length;\n        require(destinationsLength > 0, Everclear_DestinationsLengthMismatch());\n\n\n        bool found;\n        for (uint256 i; i < destinationsLength; ++i) {\n            if (params.destinations[i] == _dstChainId) {\n                found = true;\n                break;\n            }\n        }\n        require(found, Everclear_DestinationNotValid());\n\n\n        if (_extractedAmount > params.amount) {\n            uint256 toReturn = _extractedAmount - params.amount;\n            IERC20(_token).safeTransfer(_market, toReturn);\n            emit RebalancingReturnedToMarket(_market, toReturn, _extractedAmount);\n        }\n\n\n        SafeApprove.safeApprove(params.inputAsset, address(everclearFeeAdapter), params.amount);\n        (bytes32 id,) = everclearFeeAdapter.newIntent(\n            params.destinations,\n            params.receiver,\n            params.inputAsset,\n            params.outputAsset,\n            params.amount,\n            params.maxFee,\n            params.ttl,\n            params.data,\n            params.feeParams\n        );\n        emit MsgSent(_dstChainId, _market, params.amount, id);\n    }\n```\n\n\n\n### Internal Pre-conditions\n\n1. Already does not validates `maxFee` and `ttl`\n\n### External Pre-conditions\n\n1. both `maxFee` and `tt`l being none zero\n\n### Attack Path\n\n1. A rebalancer calls the `sendMsg` to create a cross-chain intent with both the `maxFee` and `ttl` being none zero\n2. The _decodeIntent function decodes the message into IntentParams, extracting maxFee (type uint24) and ttl (type uint48).\n3. The FeeAdapter may interpret non-zero maxFee or ttl as a solver pathway intent, misrouting the intent to solvers instead of the netting system.\n4. Since the solver pathway is not supported at launch, the intent may fail to settle, or, if solvers are active, it may incur unexpected fees or settle on a suboptimal chain.\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Impact\n\n1. A potential DOS\n2.  Non-zero maxFee or ttl could route intents to the solver pathway, which is unsupported, leading to settlement failures or delays that disrupt liquidity rebalancing across supported chains (e.g., Ethereum, Base, Linea, Optimism, Unichain, Arbitrum).\n3. may lead to loss of funds.\n4. when maxFee is not enforced as 0 the everclear netting pathway will not be used and protocol will not be able to cut their cost up to 10x\n\n\n\n### PoC\n\n.\n\n### Mitigation\n\nenforce both fields are validated..\n```solidity\n  function sendMsg(\n    uint256 _extractedAmount,\n    address _market,\n    uint32 _dstChainId,\n    address _token,\n    bytes memory _message,\n    bytes memory // unused\n) external payable onlyRebalancer {\n    IntentParams memory params = _decodeIntent(_message);\n\n    require(params.inputAsset == _token, Everclear_TokenMismatch());\n    require(_extractedAmount >= params.amount, BaseBridge_AmountMismatch());\n    // Enforce netting pathway requirements\n    require(params.maxFee == 0, Everclear_InvalidMaxFee());\n    require(params.ttl == 0, Everclear_InvalidTtl());\n\n    uint256 destinationsLength = params.destinations.length;\n    require(destinationsLength > 0, Everclear_DestinationsLengthMismatch());\n\n    bool found;\n    for (uint256 i; i < destinationsLength; ++i) {\n        if (params.destinations[i] == _dstChainId) {\n            found = true;\n            break;\n        }\n    }\n    require(found, Everclear_DestinationNotValid());\n\n    if (_extractedAmount > params.amount) {\n        uint256 toReturn = _extractedAmount - params.amount;\n        IERC20(_token).safeTransfer(_market, toReturn);\n        emit RebalancingReturnedToMarket(_market, toReturn, _extractedAmount);\n    }\n\n    SafeApprove.safeApprove(params.inputAsset, address(everclearFeeAdapter), params.amount);\n    (bytes32 id,) = everclearFeeAdapter.newIntent(\n        params.destinations,\n        params.receiver,\n        params.inputAsset,\n        params.outputAsset,\n        params.amount,\n        params.maxFee, // Now guaranteed to be 0\n        params.ttl,    // Now guaranteed to be 0\n        params.data,\n        params.feeParams\n    );\n    emit MsgSent(_dstChainId, _market, params.amount, id);\n}\n```\n\n",
    "summary": "\nThe bug report is about an issue found in the EverclearBridge contract, which is used by the rebalancer to send cross-chain intents. The contract does not enforce the required parameters for the netting pathway, specifically the `maxFee` and `ttl` parameters, which should be set to 0 according to the Everclear documentation. This can potentially lead to routing intents to the unsupported solver pathway, causing settlement failures or delays and even loss of funds. The root cause is that the `sendMsg` function lacks validation checks for these parameters before calling the `newIntent` function. The impact of this bug includes a potential denial of service attack, disruption of liquidity rebalancing, and increased costs for the protocol. A mitigation solution is proposed to enforce the validation of these parameters before calling the `newIntent` function.",
    "report_date": "2025-08-14T17:00:00.000Z",
    "contest_prize_txt": "80000 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1029",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-07-malda-judging/issues/317",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1029",
    "slug": "m-10-unenforced-maxfee-and-ttl-parameters-in-sendmsg-function-sherlock-malda-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Malda",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "yoooo"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xsai"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Malda",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}