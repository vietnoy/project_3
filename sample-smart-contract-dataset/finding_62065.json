{
    "id": 62065,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 2159,
    "title": "[M-02] Invalid utilization ratio check, blocking users from submitting a flash loan",
    "content": "\n\nEach asset in a pool has a utilization ratio, which refers to the percentage of the asset’s deposits that are currently being borrowed. A pool admin can set the max utilization ratio for each asset, which shouldn’t be bypassed; this is referred to as `max_util`.\n\nThe asset’s utilization ratio is checked whenever a borrow is made:\n```\n\n    fn apply_borrow(\n        e: &Env,\n        actions: &mut Actions,\n        pool: &mut Pool,\n        user: &mut User,\n        request: &Request,\n    ) -> i128 {\n        let mut reserve = pool.load_reserve(e, &request.address, true);\n        reserve.require_action_allowed(e, request.request_type);\n        let d_tokens_minted = reserve.to_d_token_up(e, request.amount);\n        user.add_liabilities(e, &mut reserve, d_tokens_minted);\n@>      reserve.require_utilization_below_max(e);\n        actions.add_for_pool_transfer(&reserve.asset, request.amount);\n        actions.do_check_health();\n        pool.cache_reserve(reserve);\n        d_tokens_minted\n    }\n```\n\nOn the other hand, each pool allows users to submit a flash loan, which consists of taking a loan, doing some actions, and possibly paying it back in the same transaction.\n\nHowever, when submitting a flash loan, and taking that loan (`1@`), the utilization ratio is checked immediately after it (`2@`).\n\n<https://github.com/code-423n4/2025-02-blend/blob/main/blend-contracts-v2/pool/src/pool/submit.rs# L89>\n```\n\n    pub fn execute_submit_with_flash_loan(\n        e: &Env,\n        from: &Address,\n        flash_loan: FlashLoan,\n        requests: Vec<Request>,\n    ) -> Positions {\n        if from == &e.current_contract_address() {\n            panic_with_error!(e, &PoolError::BadRequest);\n        }\n        let mut pool = Pool::load(e);\n        let mut from_state = User::load(e, from);\n\n        let prev_positions_count = from_state.positions.effective_count();\n\n        // note: we add the flash loan liabilities before processing the other\n        // requests.\n        {\n            let mut reserve = pool.load_reserve(e, &flash_loan.asset, true);\n            let d_tokens_minted = reserve.to_d_token_up(e, flash_loan.amount);\n1@>         from_state.add_liabilities(e, &mut reserve, d_tokens_minted);\n2@>         reserve.require_utilization_below_max(e);\n\n            PoolEvents::flash_loan(\n                e,\n                flash_loan.asset.clone(),\n                from.clone(),\n                flash_loan.contract.clone(),\n                flash_loan.amount,\n                d_tokens_minted,\n            );\n        }\n\n        // ... snip ...\n    }\n```\n\nThis is wrong, as it doesn’t give the user a chance to execute the flash loan, then repay it, and would revert. For example, A user submits a flash loan with 1k USDC. With that new debt, the utilization ratio exceeds the max utilization ratio. However, the user wants to take that loan, do some actions (we don’t really care), and wants to repay it after those actions. As a result, the end state after the transaction ends, the utilization ratio will be below the max; i.e., healthy.\n\nWith the current place of `require_utilization_below_max`, it blocks that user from executing that legit flashloan scenario.\n\n### Proof of Concept\n\nAdd the following test in `blend-contracts-v2/pool/src/pool/submit.rs`:\n```\n\n#[test]\n#[should_panic(expected = \"Error(Contract, # 1207)\")]\nfn test_submit_with_flash_loan_wrong_max_util() {\n    let e = Env::default();\n    e.cost_estimate().budget().reset_unlimited();\n    e.mock_all_auths_allowing_non_root_auth();\n\n    e.ledger().set(LedgerInfo {\n        timestamp: 600,\n        protocol_version: 22,\n        sequence_number: 1234,\n        network_id: Default::default(),\n        base_reserve: 10,\n        min_temp_entry_ttl: 10,\n        min_persistent_entry_ttl: 10,\n        max_entry_ttl: 3110400,\n    });\n\n    let bombadil = Address::generate(&e);\n    let samwise = Address::generate(&e);\n    let pool = testutils::create_pool(&e);\n    let (oracle, oracle_client) = testutils::create_mock_oracle(&e);\n\n    let (flash_loan_receiver, _) = testutils::create_flashloan_receiver(&e);\n\n    let (underlying_0, underlying_0_client) = testutils::create_token_contract(&e, &bombadil);\n    let (mut reserve_config, mut reserve_data) = testutils::default_reserve_meta();\n    reserve_config.max_util = 9500000;\n    reserve_data.b_supply = 100_0000000;\n    reserve_data.d_supply = 50_0000000;\n    testutils::create_reserve(&e, &pool, &underlying_0, &reserve_config, &reserve_data);\n\n    let (underlying_1, underlying_1_client) = testutils::create_token_contract(&e, &bombadil);\n    let (reserve_config, reserve_data) = testutils::default_reserve_meta();\n    testutils::create_reserve(&e, &pool, &underlying_1, &reserve_config, &reserve_data);\n\n    oracle_client.set_data(\n        &bombadil,\n        &Asset::Other(Symbol::new(&e, \"USD\")),\n        &vec![\n            &e,\n            Asset::Stellar(underlying_0.clone()),\n            Asset::Stellar(underlying_1.clone()),\n        ],\n        &7,\n        &300,\n    );\n    oracle_client.set_price_stable(&vec![&e, 1_0000000, 5_0000000]);\n\n    e.as_contract(&pool, || {\n        storage::set_pool_config(\n            &e,\n            &PoolConfig {\n                oracle,\n                min_collateral: 1_0000000,\n                bstop_rate: 0_1000000,\n                status: 0,\n                max_positions: 4,\n            },\n        );\n\n        underlying_1_client.mint(&samwise, &50_0000000);\n        underlying_1_client.approve(&samwise, &pool, &100_0000000, &10000);\n\n        underlying_0_client.mint(&samwise, &46_0000000);\n        underlying_0_client.approve(&samwise, &pool, &46_0000000, &10000);\n\n        // User takes a flash loan of 46_0000000, then supplies 50_0000000 of underlying_1, and finally repays the flash loan\n        execute_submit_with_flash_loan(\n            &e,\n            &samwise,\n            FlashLoan {\n                contract: flash_loan_receiver,\n                asset: underlying_0.clone(),\n                amount: 46_0000000,\n            },\n            vec![\n                &e,\n                Request {\n                    request_type: RequestType::SupplyCollateral as u32,\n                    address: underlying_1,\n                    amount: 50_0000000,\n                },\n                Request {\n                    request_type: RequestType::Repay as u32,\n                    address: underlying_0.clone(),\n                    amount: 46_0000000,\n                },\n            ],\n        );\n    });\n}\n```\n\n### Recommended mitigation steps\n```\n\n    pub fn execute_submit_with_flash_loan(\n        e: &Env,\n        from: &Address,\n        flash_loan: FlashLoan,\n        requests: Vec<Request>,\n    ) -> Positions {\n        // ... snip ...\n\n        // note: we add the flash loan liabilities before processing the other\n        // requests.\n        {\n            let mut reserve = pool.load_reserve(e, &flash_loan.asset, true);\n            let d_tokens_minted = reserve.to_d_token_up(e, flash_loan.amount);\n            from_state.add_liabilities(e, &mut reserve, d_tokens_minted);\n-           reserve.require_utilization_below_max(e);\n\n            PoolEvents::flash_loan(\n                e,\n                flash_loan.asset.clone(),\n                from.clone(),\n                flash_loan.contract.clone(),\n                flash_loan.amount,\n                d_tokens_minted,\n            );\n        }\n\n        // ... snip ...\n\n        // store updated info to ledger\n        pool.store_cached_reserves(e);\n        from_state.store(e);\n\n+       pool.load_reserve(e, &flash_loan.asset, false).require_utilization_below_max(e);\n\n        from_state.positions\n    }\n```\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[mootz12 (Script3) commented](https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-6?commentParent=rQsM29ZP4iA):**\n\n> Validated this is an issue. It’s more of an implementation detail rather than an finding, as no funds or functionality is at risk.\n>\n> Fixed to ensure flash loan is legal by checking flash loan under 100% util, then also check max util of asset during validation.\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [Commit f35271b](https://github.com/blend-capital/blend-contracts-v2/commit/f35271bd660470e1d3037ed03302e612821c4add) to clean up utilization checks.\n\n**Status:** Mitigation confirmed. Full details in reports from [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-2), [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-57), [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-60) and [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-35).\n\n---\n\n",
    "summary": "\nThis bug report discusses a problem with the utilization ratio in a pool. Each asset in the pool has a utilization ratio, which is the percentage of the asset's deposits that are currently being borrowed. A pool admin can set the maximum utilization ratio for each asset, but this should not be bypassed. However, there is a bug where the utilization ratio is checked when a user takes a loan, but also immediately after when they submit a flash loan. This can cause issues for users who want to take a loan, do some actions, and then repay it. To fix this, a test has been added and the code has been updated to check the utilization ratio only after the flash loan is completed. The bug has been confirmed and mitigated by the team.",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-6",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-02-invalid-utilization-ratio-check-blocking-users-from-submitting-a-flash-loan-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "0xAlix2"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}