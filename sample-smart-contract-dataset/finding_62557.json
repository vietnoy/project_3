{
    "id": 62557,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3420,
    "title": "[M-13] Buy request executed by providing `request.owner`",
    "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nWhen `buy` is executed, it first validates `isValidListing`, ensuring that `request.owner` has indeed signed the listing, and that listing.receiver has also signed the listing if the caller is not the `listing.receiver`.\n\n```solidity\nfunction isValidListing(ListingParams calldata listing) public view returns (bool) {\n        if (listing.request.price == 0) revert InvalidPrice();\n        if (block.timestamp > listing.request.deadline) revert ListingExpired();\n        if (listing.request.chainId != block.chainid) revert InvalidChainId();\n        bytes32 listingHash = generateListingSignatureHash(listing.request);\n        if (usedListings[listingHash]) revert ListingAlreadyUsed();\n        if (!IWhitelistRegistry(whitelistRegistry).isWhitelisted(listing.request.tokenContractAddress)) {\n            revert NFTNotWhitelisted();\n        }\n        if (IERC721(listing.request.tokenContractAddress).ownerOf(listing.request.tokenId) != listing.request.owner) {\n            revert NotOwner();\n        }\n\n>>>     if (!SignatureChecker.isValidSignatureNow(listing.request.owner, listingHash, listing.sig)) {\n            revert InvalidSignature();\n        }\n     \n>>>     if (msg.sender != listing.receiver && !SignatureChecker.isValidSignatureNow(listing.receiver, listingHash, listing.receiverSig)) {\n            revert InvalidSignature();\n        }\n\n        return true;\n    }\n```\n\nHowever, if the request owner has `acceptedCurrency` allowance to the contract, this could allow an attacker to trigger `buy`, designate the owner as the receiver, and provide a valid signature, causing the `buy` to be executed. This would result in the listing owner's request being fulfilled and the fee being paid to the contract.\n\n## Recommendations\n\nPrevent `buy` operation from being executed if the provided receiver is the owner.\n\n\n\n",
    "summary": "\nThis bug report is about a problem in a code that is used for buying items. When someone tries to buy an item, the code checks if the person who created the listing has signed it and if the receiver has also signed it. However, there is a way for someone to trick the code by allowing them to buy the item even if they are not the receiver. This could result in the wrong person receiving the item and the fee being paid to the wrong person. To fix this, the code needs to be changed so that the person who created the listing cannot also be the receiver.",
    "report_date": "2025-09-11T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/RipIt-security-review_2025-04-25.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "m-13-buy-request-executed-by-providing-requestowner-pashov-audit-group-none-ripit_2025-04-25-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "RipIt_2025-04-25",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "RipIt_2025-04-25",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}