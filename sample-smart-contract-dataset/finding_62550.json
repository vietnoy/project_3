{
    "id": 62550,
    "kind": "MARKDOWN",
    "auditfirm_id": 16,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3420,
    "title": "[M-06] Improper randomness requests in `CardAllocationPool` and `SpinLottery`",
    "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nAccording to [best practices](https://docs.chain.link/vrf/v2/security#dont-accept-bidsbetsinputs-after-you-have-made-a-randomness-request) outlined by Chainlink, **once a contract has submitted a randomness request, it should not accept any additional user-supplied inputs that could affect the outcome. This is to ensure fairness and prevent potential griefing attacks.**\n\n> Generally speaking, whenever an outcome in your contract depends on some user-supplied inputs and randomness, the contract should not accept any additional user-supplied inputs after it submits the randomness request.\n\nIn the `CardAllocationPool` contract, the `selectedCards` are determined based on the `packetTypeToCardBundles` mapping.\n\n```solidity\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal {\n        PacketOpenRequest storage request = requestIdToPacketOpen[requestId];\n        if (request.fulfilled) revert(\"Already fulfilled\");\n\n        // fetch the available card bundles\n        CardBundle[] storage cardBundles = packetTypeToCardBundles[request.packetType]; \n\n        // Select random cards using the provided randomness\n        uint256[] memory selectedCards = selectRandomCards(cardBundles, randomWords[0]); // <= random input here\n\n        // Transfer cards to owner\n        for (uint256 i = 0; i < selectedCards.length; i++) {\n            IERC721(cardNFTAddress).transferFrom(address(this), request.owner, selectedCards[i]);\n        }\n\n        // Mark request as fulfilled\n        request.fulfilled = true;\n\n        // Call finalize open on packet contract\n        RipFunPacks(packetNFTAddress).finalizeOpen(request.packetId, \"\");\n\n        emit PacketOpenFulfilled(requestId, request.packetId, selectedCards);\n    }\n```\n\nHowever, the `addCardBundlesToPacketPool` function allows modifications to this input, which can be called by the user with the `redeemManagerRole`.\n\n```solidity\n    function addCardBundlesToPacketPool(uint256 packetType, uint256[] memory cardBundles, bytes32 bundleProvenance)\n        external\n        onlyRole(redeemManagerRoleId)\n    {\n        packetTypeToCardBundles[packetType].push(CardBundle({cardIds: cardBundles, bundleProvenance: bundleProvenance})); // <= changed here\n        for (uint256 i = 0; i < cardBundles.length; i++) {\n            IERC721(cardNFTAddress).transferFrom(msg.sender, address(this), cardBundles[i]);\n        }\n\n        emit CardsAddedToPool(packetType, cardBundles, bundleProvenance);\n    }\n```\n\nAt the same time, the process of `fulfillRandomWords` for `requestA` could also impact `requestB` since `selectedCardBundle` is popped out from `availableCardBundles`.\n\n```solidity\n        selectedCardBundle = availableCardBundles[index].cardIds;\n\n        // Swap selected card bundle with last unselected card bundle and pop\n        availableCardBundles[index] = availableCardBundles[availableCardBundles.length - 1];\n        availableCardBundles.pop();\n```\n\nAdditionally, `removeCardBundlesFromPacketPool` could also change the corresponding `packetTypeToCardBundles[packetType]`:\n\n```solidity\n    function removeCardBundlesFromPacketPool(uint256 packetType, uint256[] memory cardBundleIndexes)\n        external\n        onlyRole(redeemManagerRoleId)\n    {\n        CardBundle[] storage cardBundles = packetTypeToCardBundles[packetType];\n\n        for (uint256 i = 0; i < cardBundleIndexes.length; i++) {\n            uint256 index = cardBundleIndexes[i];\n\n            // transfer the cards to the caller\n            for (uint256 j = 0; j < cardBundles[index].cardIds.length; j++) {\n                IERC721(cardNFTAddress).transferFrom(address(this), msg.sender, cardBundles[index].cardIds[j]);\n            }\n\n            // Swap selected card bundle with last unselected card bundle and pop\n            cardBundles[index] = cardBundles[cardBundles.length - 1];\n            cardBundles.pop();\n        }\n\n        emit CardBundlesRemovedFromPool(packetType, cardBundleIndexes);\n    }\n```\n\n**This design violates the recommended practice, as it permits changes to the card bundles after a randomness request has been made**, potentially skewing the selection of cards and compromising the integrity of the outcome.\n\nSimilarly, this also applies to `SpinLottery`, while after a `Randomness Requests` is being made, `rarity weight` and `card` could also be changed via `configureRarity` and `addPrize`, even after the user has paid the `spin` fee. However, the situation could be completely different for the user.\n\n```solidity\n    function configureRarity(uint8 _rarityId, uint8 _weight, uint160 _basePrice, bool _active) \n        external \n        onlyRole(lotteryManagerRoleId) \n    {\n        if (_rarityId == 0) revert InvalidRarity();\n        if (_rarityId > MAX_RARITIES) revert MaxRaritiesExceeded();\n        \n        // If this is a new rarity, track the highest rarity ID\n        if (_rarityId > maxRarityId) {\n            maxRarityId = _rarityId;\n        }\n        \n        // Update total weight (subtract old weight if exists, add new weight)\n        RarityConfig memory oldConfig = rarityConfigs[_rarityId];\n        if (oldConfig.active) {\n            totalRarityWeight -= oldConfig.weight;\n        }\n        \n        // Only add new weight if rarity will be active\n        if (_active) {\n            totalRarityWeight += _weight;\n        }\n        \n        // Update configuration\n        rarityConfigs[_rarityId] = RarityConfig({\n            weight: _weight,\n            basePrice: _basePrice,\n            active: _active\n        });\n        \n        emit RarityConfigUpdated(_rarityId, _weight, _basePrice, _active);\n    }\n```\n\n```solidity\n    function addPrize(address _nftAddress, uint256 _tokenId, uint8 _rarity) external onlyRole(lotteryManagerRoleId) {\n        if (_nftAddress == address(0)) revert ZeroAddress();\n        if (_tokenId > type(uint88).max) revert TokenIdTooLarge();\n        if (_rarity == 0 || _rarity > maxRarityId || !rarityConfigs[_rarity].active) revert InvalidRarity();\n\n        IERC721 nft = IERC721(_nftAddress);\n        if (nft.ownerOf(_tokenId) != address(this)) revert NFTNotOwnedByContract();\n\n        uint256 packed = packPrize(_nftAddress, uint88(_tokenId), _rarity);\n        _addPrizeToPool(_rarity, packed);\n\n        emit PrizeAdded(_nftAddress, _tokenId, _rarity);\n    }\n```\n\n## Recommendations\n**Evaluate the Impact of Randomness Requests** and **Decide on whether following  Best Practice Or Not.**\n\n\n\n",
    "summary": "\nThe bug report discusses a potential issue in the `CardAllocationPool` and `SpinLottery` contracts that could affect the fairness and integrity of the outcome. According to the recommended best practices by Chainlink, once a randomness request has been made, the contract should not accept any additional user-supplied inputs that could influence the outcome. However, the `CardAllocationPool` contract allows modifications to the input after a randomness request has been made, potentially skewing the selection of cards. Similarly, the `SpinLottery` contract also allows changes to the rarity weight and prize after a randomness request has been made, which could affect the outcome for the user. The report recommends evaluating the impact of randomness requests and deciding whether to follow the best practice or not.",
    "report_date": "2025-09-11T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/pashov/audits/blob/master/team/md/RipIt-security-review_2025-04-25.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "m-06-improper-randomness-requests-in-cardallocationpool-and-spinlottery-pashov-audit-group-none-ripit_2025-04-25-markdown",
    "firm_name": "Pashov Audit Group",
    "firm_logo_square": "Pashov_square.png",
    "protocol_name": "RipIt_2025-04-25",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Pashov Audit Group"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Pashov Audit Group",
        "logo_square": "Pashov_square.png"
    },
    "protocols_protocol": {
        "name": "RipIt_2025-04-25",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}