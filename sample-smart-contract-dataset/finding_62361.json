{
    "id": 62361,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 3403,
    "title": "[FTN-1] Wrong activity calculations",
    "content": "**Severity:** High\n\n**Path:** core/vm/evm.go\n\n**Description:** In functions `CallCode` and `DelegateCall`, activity parameters are incorrectly calculated.\n\nThe problem is that when the `DelegateCall` and `CallCode` are called, the execution context changes. This can cause problems when counting activity scores.\nFor example, when using proxy pattern, activity will be credited to the implementation contract. This can cause problems for the validator, since when the implementation changes, all activity points will be lost.\n```\nfunc (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n    // Fail if we're trying to execute above the call depth limit\n    if evm.depth > int(params.CallCreateDepth) {\n        return nil, gas, ErrDepth\n    }\n\n    initialGas := gas\n    // Fail if we're trying to transfer more than the available balance\n    // Note although it's noop to transfer X ether to caller itself. But\n    // if caller doesn't have enough balance, it would be an error to allow\n    // over-charging itself. So the check here is necessary.\n    if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n        return nil, gas, ErrInsufficientBalance\n    }\n    snapshot := evm.StateDB.Snapshot()\n\n    // Invoke tracer hooks that signal entering/exiting a call frame\n    if evm.Config.Debug {\n        evm.Config.Tracer.CaptureEnter(CALLCODE, caller.Address(), addr, input, gas, value)\n        defer func(startGas uint64) {\n            evm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n        }(gas)\n    }\n\n    // It is allowed to call precompiles, even via delegatecall\n    if p, isPrecompile := evm.precompile(addr); isPrecompile {\n        ret, gas, err = RunPrecompiledContract(p, input, gas)\n    } else {\n        addrCopy := addr\n        // Initialise a new contract and set the code that is to be used by the EVM.\n        // The contract is a scoped environment for this execution context only.\n        contract := NewContract(caller, AccountRef(caller.Address()), value, gas)\n        contract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), evm.StateDB.GetCode(addrCopy))\n        ret, err = evm.interpreter.Run(contract, input, false)\n        gas = contract.Gas\n\n        memGas, err := evm.memoryGas(input)\n        if err != nil {\n            return nil, gas, err\n        }\n        if caller.Address() != evm.Origin {\n            memGas = 0\n        }\n        evm.StateDB.AddActivity(addrCopy, initialGas-contract.Gas-contract.OthersGas+memGas)\n        evm.StateDB.AddActivities(&types.Activity{\n            Address:       addrCopy,\n            Activity:      evm.StateDB.GetActivity(addrCopy),\n            DeltaActivity: initialGas - contract.Gas - contract.OthersGas,\n        })\n    }\n    if err != nil {\n        evm.StateDB.RevertToSnapshot(snapshot)\n        if err != ErrExecutionReverted {\n            gas = 0\n        }\n    }\n    return ret, gas, err\n}\n```\n```\nfunc (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n    // Fail if we're trying to execute above the call depth limit\n    if evm.depth > int(params.CallCreateDepth) {\n        return nil, gas, ErrDepth\n    }\n\n    initialGas := gas\n\n    snapshot := evm.StateDB.Snapshot()\n\n    // Invoke tracer hooks that signal entering/exiting a call frame\n    if evm.Config.Debug {\n        evm.Config.Tracer.CaptureEnter(DELEGATECALL, caller.Address(), addr, input, gas, nil)\n        defer func(startGas uint64) {\n            evm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n        }(gas)\n    }\n\n    // It is allowed to call precompiles, even via delegatecall\n    if p, isPrecompile := evm.precompile(addr); isPrecompile {\n        ret, gas, err = RunPrecompiledContract(p, input, gas)\n    } else {\n        addrCopy := addr\n        // Initialise a new contract and make initialise the delegate values\n        contract := NewContract(caller, AccountRef(caller.Address()), nil, gas).AsDelegate()\n        contract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), evm.StateDB.GetCode(addrCopy))\n        ret, err = evm.interpreter.Run(contract, input, false)\n        gas = contract.Gas\n\n        evm.StateDB.AddActivity(addrCopy, initialGas-contract.Gas-contract.OthersGas)\n        evm.StateDB.AddActivities(&types.Activity{\n            Address:       addrCopy,\n            Activity:      evm.StateDB.GetActivity(addrCopy),\n            DeltaActivity: initialGas - contract.Gas - contract.OthersGas,\n        })\n    }\n    if err != nil {\n        evm.StateDB.RevertToSnapshot(snapshot)\n        if err != ErrExecutionReverted {\n            gas = 0\n        }\n    }\n    return ret, gas, err\n}\n```\n\n**Remediation:**  Remove activity score calculations from `DelegateCall` and `CallCode`.\n\n**Status:**  Fixed\n\n- - -",
    "summary": "\nSeverity: High\n\nDescription: The `CallCode` and `DelegateCall` functions in the `evm.go` file are incorrectly calculating activity parameters. This is due to a change in execution context when these functions are called, which can cause problems when counting activity scores. For example, in the proxy pattern, activity is credited to the implementation contract, which can cause issues for validators if the implementation changes.\n\nRemediation: The activity score calculations should be removed from the `DelegateCall` and `CallCode` functions.\n\nStatus: This issue has been fixed.",
    "report_date": "2023-04-06T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2023-04-06-Bahamut.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "ftn-1-wrong-activity-calculations-hexens-none-bahamut-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Bahamut",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Bahamut",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}