{
    "id": 62401,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 3405,
    "title": "[LOGLAB-18] $.pendingDecreaseCollateral variable will be updated incorrectly if the agent executes an insufficient response, leading to an imbalance in the strategy after unpausing",
    "content": "**Severity:** Medium\n\n**Path:** src/strategy/BasisStrategy.sol#L946-L966, src/strategy/BasisStrategy.sol#L578-L590, src/strategy/BasisStrategy.sol#L590-L609\n\n**Description:** When the agent executes the deutilize request with an insufficient response, the `_afterDecreasePosition()` function will revert the request to the spot manager, returning the assets corresponding to the insufficient response size, and will repurchase the product in the spot manager. After that, it returns `shouldPause` as `true`, causing the strategy to be paused.\n```\nfunction _afterDecreasePosition(IHedgeManager.AdjustPositionPayload calldata responseParams)   \n    [...]\n    (bool exceedsThreshold, int256 sizeDeviation) = _checkDeviation(\n        responseParams.sizeDeltaInTokens, requestParams.sizeDeltaInTokens, _responseDeviationThreshold\n    );\n    if (exceedsThreshold) {\n        shouldPause = true;\n        if (sizeDeviation < 0) {\n            uint256 sizeDeviationAbs = uint256(-sizeDeviation);\n            uint256 assetsToBeReverted;\n            if (sizeDeviationAbs == requestParams.sizeDeltaInTokens) {\n                assetsToBeReverted = _pendingDeutilizedAssets;\n            } else {\n                assetsToBeReverted =\n                    _pendingDeutilizedAssets.mulDiv(sizeDeviationAbs, requestParams.sizeDeltaInTokens);\n            }\n            if (assetsToBeReverted > 0) {\n                ISpotManager _spotManager = $.spotManager;\n                _asset.safeTransfer(address(_spotManager), assetsToBeReverted);\n                _spotManager.buy(assetsToBeReverted, ISpotManager.SwapType.MANUAL, \"\");\n            }\n        }\n    }\n    [...]\n    if (requestParams.collateralDeltaAmount > 0) {\n        (bool exceedsThreshold,) = _checkDeviation(\n            responseParams.collateralDeltaAmount, requestParams.collateralDeltaAmount, _responseDeviationThreshold\n        );\n        shouldPause = exceedsThreshold;\n    }\n```\nThe issue arises because, during this deutilization, `requestParams.sizeDeltaInTokens` represents only the size of the current request, while `requestParams.collateralDeltaAmount` may also include the collateral delta from previous deutilizations stored in the `$.pendingDecreaseCollateral` variable. Since the previous deutilizations were executed correctly, `$.pendingDecreaseCollateral` is supposed to be decreased from the hedge position. However, the `$.pendingDecreaseCollateral` variable will be updated incorrectly if the response for the current deutilization is insufficient.\n\nConsider 2 cases:\n\n1. The current deutilization is fully deutilizing\nIn this case, `spotSellCallback()` already updates `$.pendingDecreaseCollateral` to 0 without considering the result of the response\n```\nif ($.vault.totalSupply() == 0 || ISpotManager(_msgSender()).exposure() == 0) {\n    // in case of redeeming all by users,\n    // or selling out all product\n    // close hedge position\n    sizeDeltaInTokens = type(uint256).max;\n    collateralDeltaAmount = type(uint256).max;\n    $.pendingDecreaseCollateral = 0;\n} else if (status == StrategyStatus.FULL_DEUTILIZING) {\n    (uint256 min,) = $.hedgeManager.decreaseCollateralMinMax();\n    uint256 pendingWithdraw = assetsToDeutilize();\n    collateralDeltaAmount = min > pendingWithdraw ? min : pendingWithdraw;\n    $.pendingDecreaseCollateral = 0;\n}\n```\nSo, if the response of this deutilization is insufficient, `$.pendingDecreaseCollateral` will be cleared, resulting in missing an collateral amount that should have been decreased from the hedge manager based on previous requests. Since the previous deutilizations successfully reduced the size of both the spot manager and hedge manager without adjusting the collateral, the leverage and state of the hedge manager will become imbalanced. Additionally, after unpausing the strategy, `$.pendingDecreaseCollateral` (which is now 0) will be in an incorrect state for the previous withdrawal request.\n\n\n2. The current deutilization is partially deutilizing, and `collateralDeltaToDecrease` is larger than `limitDecreaseCollateral`.\nIn this case, spotSellCallback() will add `$.pendingDecreaseCollateral` to the current collateralDeltaAmount for the request. However, `$.pendingDecreaseCollateral` remains unchanged without any updates.\n```\nelse {\n    // when partial deutilizing\n    IHedgeManager _hedgeManager = $.hedgeManager;\n    uint256 positionNetBalance = _hedgeManager.positionNetBalance();\n    uint256 _pendingDecreaseCollateral = $.pendingDecreaseCollateral;\n    if (_pendingDecreaseCollateral > 0) {\n        (, positionNetBalance) = positionNetBalance.trySub(_pendingDecreaseCollateral);\n    }\n    uint256 positionSizeInTokens = _hedgeManager.positionSizeInTokens();\n    uint256 collateralDeltaToDecrease =\n        positionNetBalance.mulDiv(productDelta, positionSizeInTokens);\n    collateralDeltaToDecrease += _pendingDecreaseCollateral;\n    uint256 limitDecreaseCollateral = _hedgeManager.limitDecreaseCollateral();\n    if (collateralDeltaToDecrease < limitDecreaseCollateral) {\n        $.pendingDecreaseCollateral = collateralDeltaToDecrease;\n    } else {\n        collateralDeltaAmount = collateralDeltaToDecrease;\n    }\n}\n```\nAfter that, `_afterDecreasePosition` updates `$.pendingDecreaseCollateral` by subtracting the collateral reduced based on the response.\n```\nif (responseParams.collateralDeltaAmount > 0) {\n    // the case when deutilizing for withdrawals and rebalancing Up\n    (, $.pendingDecreaseCollateral) = $.pendingDecreaseCollateral.trySub(responseParams.collateralDeltaAmount);\n    _asset.safeTransferFrom(_msgSender(), address(this), responseParams.collateralDeltaAmount);\n}\n```\nThis behavior is incorrect when the response is insufficient because `responseParams.collateralDeltaAmount` is expected to include the collateral delta from both the current and previous deutilizations, while `$.pendingDecreaseCollateral` does not account for the collateral delta from the current deutilization. As a result, this update will either excessively reduce or incorrectly clear `$.pendingDecreaseCollateral`, leading to the same impact as in Case 1.\n\n**Remediation:**  Update `$.pendingDecreaseCollateral` in the `_afterDecreasePosition` function instead of resetting it to 0 before making the request, as shown below:\n```\nif (responseParams.collateralDeltaAmount > 0) {\n    // the case when deutilizing for withdrawals and rebalancing Up\n    if (!shouldPause) {\n        //The response decreased the sufficient size and collateral of the position, including pendingDecreaseCollateral\n        $.pendingDecreaseCollateral = 0;\n    } else {\n        //Calculate the corresponding collateral requested when the response is insufficient\n        uint256 currentRequestedCollateral = (requestParams.collateralDeltaAmount - $.pendingDecreaseCollateral)\n            .mulDiv(responseParams.sizeDeltaInTokens, requestParams.sizeDeltaInTokens);\n\n        //If the response lacks sufficient collateral for the current request, add the deficit to pendingDecreaseCollateral\n        //Otherwise, decrease pendingDecreaseCollateral by the remaining collateral.\n        if (responseParams.collateralDeltaAmount < currentRequestedCollateral) {\n            $.pendingDecreaseCollateral += currentRequestedCollateral - responseParams.collateralDeltaAmount;\n        } else {\n            (, $.pendingDecreaseCollateral) = $.pendingDecreaseCollateral.trySub(\n                responseParams.collateralDeltaAmount - currentRequestedCollateral\n            );\n        }\n    }\n    _asset.safeTransferFrom(_msgSender(), address(this), responseParams.collateralDeltaAmount);\n}\n```\n\n**Status:** Fixed\n\n\n- - -",
    "summary": "\nThis report describes a bug in the BasisStrategy smart contract, which could cause the strategy to be paused and the hedge manager to become imbalanced. The bug occurs when the agent executes a deutilize request with an insufficient response, causing the strategy to be paused and the assets to be repurchased in the spot manager. This bug is caused by incorrect updates to the `$.pendingDecreaseCollateral` variable, which can result in missing collateral that should have been decreased from the hedge manager. To fix this bug, the report recommends updating the `$.pendingDecreaseCollateral` variable in the `_afterDecreasePosition` function. This bug has been fixed.",
    "report_date": "2024-11-25T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2024-11-25-BasisOS.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "loglab-18-pendingdecreasecollateral-variable-will-be-updated-incorrectly-if-the-agent-executes-an-insufficient-response-leading-to-an-imbalance-in-the-strategy-after-unpausing-hexens-none-basisos-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Basisos",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Basisos",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}