{
    "id": 62384,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 1408,
    "title": "[FNG-8] All NFTs are evaluated at their floor price and can lead to user's loss",
    "content": "**Severity:** Medium\n\n**Path:** CErc721.sol:doNFTTransferOut#L624-L637\n\n**Description:** In the `CErc721.sol` when the user mints CTokens with the `mint()` function the user supplies `nftIds` which they would like to exchange for CTokens. But the `exchangeRate` is fixed for any NFT in that collection. This might lead to NFTs with different prices leading to the user getting the same amount of CTokens, as all NFTs are basically evaluated at their floor price. \n\nThe same price calculation is missing in the `redeem()` function which once again leads to that same problem. For example the Azuki NFTs, which according to the protocols documentation is supported, currently has NFT `Azuki #1725` which was sold for 7.30 ETH and `Azuki #5544` which was sold for 4.135 ETH. In case both of those users decided to mint their NFTs in the `CErc721.sol` and while their prices have significant difference both of them would get the same amount of CTokens.\n\nThis can lead to malicious user changing his low value NFT for a much higher value NFT because of the way the `doNFTTransferOut()` is implemented.\n\nThe documentation claims that when the user calls the redeem() function the protocol would use Chainlink’s VRF to get a verifiable random number to give a random NFT to the user who called the redeem() function, but instead the protocol gives the last NFT that was deposited into the protocol to the user. This can be seen in the implementation of the doNFTTransferOut() where the protocol transfers the last element of the heldNFTs array which contains the ids of all of the NFTs that were deposited into the contract. Thus the following case might happen:\n\n- The malicious user deposits a cheap NFT for some x amount of tokens in the `CErc721.sol`\n\n- A normal user comes and deposits his expensive NFT into the same contract\n\n- The malicious user seeing that a more expensive NFT was deposited into the contract and because all of the NFTs have a flat exchangeRate with CTokens, the malicious user redeems his tokens for the more expensive NFT thus changing his cheap NFT for a more expensive NFT\n```\n    function mint(uint[] memory nftIds) external override nonReentrant returns (uint) {\n\n        comptroller.autoEnterMarkets(msg.sender); // silent failure allowed\n\n        accrueInterest();\n\n        uint mintAmount = nftIds.length * expScale;\n        address minter = msg.sender;\n\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            revert MintComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert MintFreshnessCheck();\n        }\n\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        supplyInterest[minter].interestAccrued = supplyInterestStoredInternal(minter);\n        supplyInterest[minter].interestIndex = supplyIndex;\n\n        uint actualMintAmount = doNFTTransferIn(minter, nftIds) * expScale;\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, actualMintAmount, mintTokens, nftIds);\n        emit Transfer(address(this), minter, mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n\n        return NO_ERROR;\n    }\n```\n```\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal override {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        // NFT count -> amount\n        redeemAmountIn = redeemAmountIn * expScale; //1e18\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\n\n        uint redeemTokens;\n        uint redeemAmount;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n        require(redeemAmount % expScale == 0, \"invalid redeemTokens\");\n\n        uint redeemNFTCount = redeemAmount / expScale;\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n        if (allowed != 0) {\n            revert RedeemComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RedeemFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getNFTsHeld() < redeemNFTCount) {\n            revert RedeemTransferOutNotPossible();\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        uint redeemInterestAmount = supplyInterestStoredInternal(redeemer);\n        supplyInterest[redeemer].interestIndex = supplyIndex;\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n         */\n        totalSupply = totalSupply - redeemTokens;\n\n        uint accountTokensNew = accountTokens[redeemer] - redeemTokens;\n        accountTokens[redeemer] = accountTokensNew;\n\n        uint256[] memory nftIds = doNFTTransferOut(redeemer, redeemNFTCount);\n\n        if (redeemInterestAmount != 0) {\n            supplyInterest[redeemer].interestAccrued = 0;\n            interestMarket.collectInterest(redeemer, redeemInterestAmount);\n        }\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), redeemTokens);\n        emit Redeem(redeemer, redeemNFTCount, redeemTokens, nftIds);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n\n        if (accountTokensNew == 0 && borrowBalanceStoredInternal(redeemer) == 0) {\n            comptroller.autoExitMarkets(redeemer); // silent failure allowed\n        }\n    }\n```\n```\n    function doNFTTransferOut(address to, uint nftCount) virtual internal returns (uint256[] memory nftIds) {\n        nftIds = new uint256[](nftCount);\n        uint256 nftID;\n        uint idx = heldNFTs.length;\n        IERC721 underlying_ = IERC721(underlying);\n        for(uint i = 0; i < nftCount;) {\n            idx--;\n            nftID = heldNFTs[idx];\n            underlying_.transferFrom(address(this), to, nftID);\n            heldNFTs.pop();\n            nftIds[i] = nftID;\n            unchecked { i++; }\n        }\n    }\n```\n\n**Remediation:**  This constitutes to a user risk and users holding NFTs with a significant higher price than the floor price should at least be warned by the front-end that their NFT won’t be evaluated at its price.\n\n**Status:** Acknowledged\n\n\n- - -",
    "summary": "\nThe bug report addresses a problem in the `CErc721.sol` contract where the `exchangeRate` for NFTs is fixed, leading to users receiving the same amount of CTokens for NFTs with different prices. This can also result in a malicious user swapping their low-value NFT for a higher-value one. The documentation claims that the protocol will use a random number to give a random NFT to users, but instead it gives the last NFT deposited into the contract. This poses a risk for users with more expensive NFTs. The recommended solution is to warn users that their NFTs may not be evaluated at their actual price. The bug has been acknowledged.",
    "report_date": "2023-11-06T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2023-11-06-Fungify.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "fng-8-all-nfts-are-evaluated-at-their-floor-price-and-can-lead-to-users-loss-hexens-none-fungify-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Fungify",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Fungify",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}