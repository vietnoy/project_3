{
    "id": 62490,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 2,
    "protocol_id": 3104,
    "title": "H-9: Hardcoded `useEth = true` in `remove_liquidity_one_coin` or `remove_liquidity` lead to stuck fund",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/691 \n\n## Found by \nelolpuer, xiaoming90\n\n### Summary\n\n-\n\n### Root Cause\n\n-\n\n### Internal Pre-conditions\n\n-\n\n### External Pre-conditions\n\n-\n\n### Attack Path\n\nAssume the Curve V2 pool with two-token setup. The following are some of the Curve pools that fit into this example.\n\nhttps://www.curve.finance/dex/ethereum/pools/teth/deposit/ (t/ETH)\n\n- LP Token - https://etherscan.io/address/0x752ebeb79963cf0732e9c0fec72a49fd1defaeac\n\n- Coin 0 - 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n- Coin 1 - 0xCdF7028ceAB81fA0C6971208e83fa7872994beE5 (T)\n\nhttps://www.curve.finance/dex/ethereum/pools/cvxeth/deposit/ (cvxeth) \n\n- LP Token - https://etherscan.io/address/0xb576491f1e6e5e62f1d8f26062ee822b40b0e0d4\n- Coin 0 - 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 (WETH)\n- Coin 1 - 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B (CVX)\n\nCurve Pool's Coin 0 is WETH, and thus `ETH_INDEX` is set to 0 during deployment. I have checked the source code and confirmed that `ETH_INDEX` is 0. Readers can access the LP token's etherscan link above to view the source code and see that the `ETH_INDEX` is set to 0.\n\nNote that the Yield Strategy vault's `TOKEN_1` is equal to Curve Pool's Coin 0 and is set to WETH.\n\nAssume that the Yield Strategy (YS) vault's asset is WETH, and we will enter the pool on a single-sided basis, with all deposited assets being in WETH.\n\nThe `msgValue` at Line 237 will be zero as `TOKEN_1` is in WETH and not Native ETH (0x0). Thus, the condition `0 < msgValue` will be evaluated to `false`.\n\nAs a result, no native ETH will be forwarded to the Curve Pool. Instead, the Curve pool will pull the WETH from the YS vault later. In this case, the `use_eth` parameter will be set to `false`, which makes sense because we are entering the pool with WETH and not Native ETH.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L219\n\n```solidity\nFile: CurveConvex2Token.sol\n219:     function _enterPool(\n220:         uint256[] memory _amounts, uint256 minPoolClaim, uint256 msgValue\n221:     ) internal returns (uint256) {\n..SNIP..\n235:         } else if (CURVE_INTERFACE == CurveInterface.V2) {\n236:             return ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n237:                 amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n238:             );\n239:         }\n```\n\nNote that `use_eth` is `false`. The condition at Line 959 will be `true` and the Curve Pool will pull WETH from YS vault. Then, in Line 962, it will unwrap the WETH to Native ETH balance and proceed with the rest of the calculations.\n\n```solidity\nFile: v2 (0.3.1).py\n920: @payable\n921: @external\n922: @nonreentrant('lock')\n923: def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256,\n924:                   use_eth: bool = False, receiver: address = msg.sender) -> uint256:\n..SNIP..\n954:     for i in range(N_COINS):\n955:         if use_eth and i == ETH_INDEX:\n956:             assert msg.value == amounts[i]  # dev: incorrect eth amount\n957:         if amounts[i] > 0:\n958:             coin: address = _coins[i]\n959:             if (not use_eth) or (i != ETH_INDEX):\n960:                 assert ERC20(coin).transferFrom(msg.sender, self, amounts[i])\n961:                 if i == ETH_INDEX:\n962:                     WETH(coin).withdraw(amounts[i])\n963:             amountsp[i] = xp[i] - xp_old[i]\n```\n\nThe problem here is that when exiting the pool either via `remove_liquidity_one_coin` or `remove_liquidity` function, the `useEth` parameter is hardcoded to `true`, as shown below.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L244\n\n```solidity\nFile: CurveConvex2Token.sol\n244:     function _exitPool(\n245:         uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n246:     ) internal returns (uint256[] memory exitBalances) {\n247:         if (isSingleSided) {\n248:             exitBalances = new uint256[](_NUM_TOKENS);\n..SNIP..\n255:                 exitBalances[_PRIMARY_INDEX] = ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity_one_coin(\n256:                     // Last two parameters are useEth = true and receiver = this contract\n257:                     poolClaim, _PRIMARY_INDEX, _minAmounts[_PRIMARY_INDEX], true, address(this)\n258:                 );\n259:             }\n..SNIP..\n279:                 // Remove liquidity on CurveV2 does not return the exit amounts so we have to measure\n280:                 // them before and after.\n281:                 ICurve2TokenPoolV2(CURVE_POOL).remove_liquidity(\n282:                     // Last two parameters are useEth = true and receiver = this contract\n283:                     poolClaim, minAmounts, true, address(this)\n284:                 );\n```\n\nSince `use_eth` is true, in Line 1043 below, it will transfer Native ETH to YS when exiting the pool.\n\n```solidity\nFile: v2 (0.3.1).py\n1024: @external\n1025: @nonreentrant('lock')\n1026: def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],\n1027:                      use_eth: bool = False, receiver: address = msg.sender):\n..SNIP..\n1037:     for i in range(N_COINS):\n1038:         d_balance: uint256 = balances[i] * amount / total_supply\n1039:         assert d_balance >= min_amounts[i]\n1040:         self.balances[i] = balances[i] - d_balance\n1041:         balances[i] = d_balance  # now it's the amounts going out\n1042:         if use_eth and i == ETH_INDEX:\n1043:             raw_call(receiver, b\"\", value=d_balance)\n```\n\nAfter exiting the pool, native ETH will reside in the YS vault, and the logic at Lines 205-211 will be executed. The first condition (`ASSET == address(WETH)`) will evaluate to `true` in Line 205 below. However, the subsequent conditions `TOKEN_1 == ETH_ADDRESS` and `TOKEN_2 == ETH_ADDRESS` both evaluate to `false` as neither `TOKEN_1` nor `TOKEN_2` is equal to `ETH_ADDRESS`(0x0). Note that `TOKEN_1` is equal to WETH and not Native ETH (0x0) in this scenario.\n\nIn this case, the Native ETH residing in the YS will not be wrapped back to WETH.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/CurveConvex2Token.sol#L205\n\n```solidity\nFile: CurveConvex2Token.sol\n198:     function unstakeAndExitPool(\n199:         uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n200:     ) external returns (uint256[] memory exitBalances) {\n201:         _unstakeLpTokens(poolClaim);\n202: \n203:         exitBalances = _exitPool(poolClaim, _minAmounts, isSingleSided);\n204: \n205:         if (ASSET == address(WETH)) {\n206:             if (TOKEN_1 == ETH_ADDRESS) {\n207:                 WETH.deposit{value: exitBalances[0]}();\n208:             } else if (TOKEN_2 == ETH_ADDRESS) {\n209:                 WETH.deposit{value: exitBalances[1]}();\n210:             }\n211:         }\n212:     }\n```\n\nNote that if it is a single-side exit, the `_executeRedemptionTrades()` will not be executed. If it is a proportional exit, the `_executeRedemptionTrades()` function will be executed, the condition at Line 229 (`address(tokens[i]) == address(asset) -> (WETH == WETH) -> True`) will be `True` and the `finalPrimaryBalance` will be set to the exit balance, and the for-loop will continue without swapping any assets.\n\nEither way, the Native ETH remains in the YS vault.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L229\n\n```solidity\nFile: AbstractSingleSidedLP.sol\n223:     function _executeRedemptionTrades(\n224:         ERC20[] memory tokens,\n225:         uint256[] memory exitBalances,\n226:         TradeParams[] memory redemptionTrades\n227:     ) internal returns (uint256 finalPrimaryBalance) {\n228:         for (uint256 i; i < exitBalances.length; i++) {\n229:             if (address(tokens[i]) == address(asset)) {\n230:                 finalPrimaryBalance += exitBalances[i];\n231:                 continue;\n232:             }\n```\n\nSince the rest of the protocol works only with WETH, but not Native ETH. Many of the protocol's logic will be broken.\n\nOne instance is that the `_burnShares` will check the before and after balance of WETH to compute how many WETH asset to return to the user. Since we only have Native ETH here, but not WETH, the `assetsWithdrawn` will be zero, and users will receive nothing in return during withdrawal/redemption.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/AbstractYieldStrategy.sol#L416\n\n```solidity\nFile: AbstractYieldStrategy.sol\n416:     function _burnShares(\n417:         uint256 sharesToBurn,\n418:         uint256 /* sharesHeld */,\n419:         bytes memory redeemData,\n420:         address sharesOwner\n421:     ) internal virtual returns (uint256 assetsWithdrawn) {\n422:         if (sharesToBurn == 0) return 0;\n423:         bool isEscrowed = _isWithdrawRequestPending(sharesOwner);\n424: \n425:         uint256 initialAssetBalance = TokenUtils.tokenBalance(asset);\n426: \n427:         // First accrue fees on the yield token\n428:         _accrueFees();\n429:         _redeemShares(sharesToBurn, sharesOwner, isEscrowed, redeemData);\n430:         if (isEscrowed) s_escrowedShares -= sharesToBurn;\n431: \n432:         uint256 finalAssetBalance = TokenUtils.tokenBalance(asset);\n433:         assetsWithdrawn = finalAssetBalance - initialAssetBalance;\n```\n\n### Impact\n\nHigh. Loss of assets as shown in above scenario.\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nFor exiting pool code, update the code to only set `useEth` to `True` if `TOKEN_1` or `TOKEN_2` is equal to `ETH_ADDRESS`(0x0). Otherwise, `useEth` should be `False`.\n\nIn this scenario, `useEth` should be `false` when exiting the pool. If it is set to `false` in the first place, WETH will be forwarded to the YS vault, and everything will work as expected without error.\n\n",
    "summary": "\nThis bug report is about a problem found by two users, elolpuer and xiaoming90, in a code repository on GitHub. The bug affects a feature called Curve V2 pool, which is used for trading cryptocurrency. The bug can cause a loss of assets for users. The root cause of the bug is a mistake in the code, which causes the wrong type of cryptocurrency to be used when exiting the pool. This leads to the loss of assets for users. The bug can be fixed by updating the code to use the correct type of cryptocurrency when exiting the pool.",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/691",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "h-9-hardcoded-useeth-true-in-remove_liquidity_one_coin-or-remove_liquidity-lead-to-stuck-fund-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "elolpuer"
            }
        },
        {
            "wardens_warden": {
                "handle": "xiaoming90"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}