{
    "id": 62373,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "LOW",
    "finders_count": 1,
    "protocol_id": 1390,
    "title": "[ASTRO-23] Code style problems",
    "content": "**Severity:** Low\n\n**Path:** Crate.sol, Swap.sol\n\n**Description:** In the Crate contract, the ordering of the variable declaration can be tightly packed to optimize storage usage and save gas.\n\nIn the Crate and Swap contracts there is redundant return keywords usage as the variables are declared with the same syntax in the functionâ€™s return tuple.\n```\n    uint8 private tokenDecimals; // The decimals of the token\n    uint256 public totalRemoteAssets; // Amount of assets on other chains (or farmed on local chain)\n    uint256 public performanceFee; // 100% = 10000\n    uint256 public managementFee; // 100% = 10000\n    uint256 public withdrawFee; // 100% = 10000\n    uint256 public anticipatedProfits; // The yield trickling down\n    uint256 public lastUpdate; // Last time the unrealized gain was updated\n    Checkpoint public checkpoint; // Used to compute fees\n    ElasticLiquidityPool public liquidityPool; // The pool used to process withdraws\n    bool public liquidityPoolEnabled; // If the pool is enabled\n    IERC20 public asset; // The asset we are using\n```\n```\nfunction mint(\n        uint256 _shares,\n        address _receiver\n    ) external nonReentrant returns (uint256 assets) {\n        assets = convertToAssets(_shares);\n\n        // Requires\n        if (assets == 0 || _shares == 0) revert AmountZero();\n        if (assets > maxDeposit(_receiver))\n            revert AmountTooHigh(maxDeposit(_receiver));\n        if (_receiver == address(this)) revert CrateCantBeReceiver();\n\n        // Moving value\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n        _mint(_receiver, _shares);\n        emit Deposit(msg.sender, _receiver, assets, _shares);\n        return (assets);\n    }\n```\n```\nfunction _withdraw(\n        uint256 _amount,\n        uint256 _shares,\n        uint256 _minAmountOut,\n        uint256 _deadline,\n        address _receiver,\n        address _owner\n    ) internal nonReentrant returns (uint256 recovered) {\n        if (_amount == 0 || _shares == 0) revert AmountZero();\n\n        // We spend the allowance if the msg.sender isn't the receiver\n        if (msg.sender != _owner) {\n            _spendAllowance(_owner, msg.sender, _shares);\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        if (convertToAssets(_shares) == 0)\n            revert IncorrectAssetAmount(convertToAssets(_shares));\n\n        // We burn the tokens\n        _burn(_owner, _shares);\n\n        // Allows to take a withdraw fee\n        _amount = (_amount * (MAX_BPS - withdrawFee)) / MAX_BPS;\n\n        if (liquidityPoolEnabled) {\n            // We don't take into account the eventual slippage, since it will\n            // be paid to the depositoors\n            liquidityPool.debt -= Math.min(_amount, liquidityPool.debt);\n            try\n                liquidityPool.swap.swapVirtualToAsset(\n                    _amount,\n                    _minAmountOut,\n                    _deadline,\n                    _receiver\n                )\n            returns (uint256 dy) {\n                recovered = dy;\n            } catch {\n                // if the swap fails, we send the funds available\n                asset.safeTransfer(_receiver, _amount);\n                recovered = _amount;\n            }\n        } else {\n            // If the liquidity pool is not enabled, we send the funds available\n            // This allows for the bootstrapping of the pool at start\n            asset.safeTransfer(_receiver, _amount);\n            recovered = _amount;\n        }\n\n        if (_minAmountOut > 0 && recovered < _minAmountOut)\n            revert IncorrectAssetAmount(recovered);\n\n        emit Withdraw(msg.sender, _receiver, _owner, _amount, _shares);\n        return (recovered);\n    }\n```\n```\n    function swapVirtualToAsset(\n        uint256 _dx,\n        uint256 _minDy,\n        uint256 _deadline,\n        address _receiver\n    )\n        external\n        deadlineCheck(_deadline)\n        onlyCrate\n        returns (uint256 dy)\n    {\n        // If we are swapping 0, we return 0\n        if (_dx == 0) {\n            return 0;\n        }\n\n        dy = swapStorage._swap(\n            VIRTUAL_ASSET_INDEX,\n            REAL_ASSET_INDEX,\n            _dx,\n            _minDy\n        );\n\n        LENDING_POOL.withdraw(\n            address(UNDERLYING_TOKENS[REAL_ASSET_INDEX]),\n            dy,\n            _receiver\n        );\n\n        // And we withdraw and send them to the recipient\n        return dy;\n    }\n```\n\n**Remediation:**  Consider tightly packing variable declarations and removing the lines with the return keywords.\n\n**Status:** Fixed\n\n- - -",
    "summary": "",
    "report_date": "2023-04-17T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2023-04-17-Astrolab.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "astro-23-code-style-problems-hexens-none-astrolab-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Astrolab",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Astrolab",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}