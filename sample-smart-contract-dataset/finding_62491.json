{
    "id": 62491,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 2,
    "protocol_id": 3104,
    "title": "H-10: Malicious user can change the `TradeType` to steal funds from the vault or withdraw request manager",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/715 \n\n## Found by \nmstpr-brainbot, xiaoming90\n\n### Summary\n\n-\n\n### Root Cause\n\n-\n\n### Internal Pre-conditions\n\n-\n\n### External Pre-conditions\n\n-\n\n### Attack Path\n\n**Instance 1 - Yield Strategy Vault**\n\nAssume the following:\n\n- The asset token of a yield strategy vault is WBTC\n- The yield token of the vault is the LP token of a Curve Pool (DAI/WBTC)\n- 1 WBTC is worth 100,000 DAI\n- WBTC's decimals is 8. DAI's decimals is 18.\n\nWhen redeeming the LP token, the vault received back 10,000 DAI and 1 WBTC. The intention of the `_executeRedemptionTrades` function is to swap all non-asset token (DAI in this example) to asset token (WBTC), as per the comment at Line 235 below.\n\nThus, the `t.tradeType` must always be set to `TradeType.EXACT_IN_SINGLE` so that exact amount of 10,000 DAI (10000e18) will be swapped for arbitrary amount of WBTC (asset token). In this case, it should receive 0.1 WBTC after swapping in 10,000 DAI.\n\n> [!NOTE]\n>\n> The `t.minPurchaseAmount` should also be set to the maximum value possible, so that maximum allowance will be granted to the external DEX protocol to pull tokens from Notional. Refer to [here](https://github.com/sherlock-audit/2023-02-notional/blob/b33adfbe2d47ab602b4d626bb73ebd78bf7d5622/leveraged-vaults/contracts/trading/TradingUtils.sol#L118). In EXACT_OUT trades, approval will be given based on `trade.limit` value.\n\n> [!NOTE]\n>\n> This attack will work for any trading adapters, as demonstrated in the scenario below. However, if one needs maximum flexibility and control in crafting the exploit, such as the ability to set `trade.amount` to an arbitrary value instead of being restricted to `exitBalances[i]` (10000e18), they can consider using the 0x's [ZeroExAdaptor](https://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/trading/adapters/ZeroExAdapter.sol) because it allows users to define arbitrary execution data, and there is no check against the execution data internally.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L223\n\n```solidity\nFile: AbstractSingleSidedLP.sol\n222:     /// @dev Trades the amount of secondary tokens into the primary token after exiting a pool.\n223:     function _executeRedemptionTrades(\n224:         ERC20[] memory tokens,\n225:         uint256[] memory exitBalances,\n226:         TradeParams[] memory redemptionTrades\n227:     ) internal returns (uint256 finalPrimaryBalance) {\n228:         for (uint256 i; i < exitBalances.length; i++) {\n229:             if (address(tokens[i]) == address(asset)) {\n230:                 finalPrimaryBalance += exitBalances[i];\n231:                 continue;\n232:             }\n233: \n234:             TradeParams memory t = redemptionTrades[i];\n235:             // Always sell the entire exit balance to the primary token\n236:             if (exitBalances[i] > 0) {\n237:                 Trade memory trade = Trade({\n238:                     tradeType: t.tradeType,\n239:                     sellToken: address(tokens[i]), // @audit DAI\n240:                     buyToken: address(asset), // @audit WBTC\n241:                     amount: exitBalances[i], // @audit 10,000 DAI => 10000e18\n242:                     limit: t.minPurchaseAmount,\n243:                     deadline: block.timestamp,\n244:                     exchangeData: t.exchangeData\n245:                 });\n246:                 (/* */, uint256 amountBought) = _executeTrade(trade, t.dexId);\n247: \n248:                 finalPrimaryBalance += amountBought;\n249:             }\n250:         }\n```\n\nHowever, the issue here is that the `t.tradeType` can be set to any value by the caller or user. Thus, instead of setting it to `TradeType.EXACT_IN_SINGLE`, a malicious user can set it to `TradeType.EXACT_OUT_SINGLE`.\n\nIf the trade data is set to `TradeType.EXACT_OUT_SINGLE` as follows:\n\n```solidity\nTrade memory trade = Trade({\n    tradeType: TradeType.EXACT_OUT_SINGLE,\n    sellToken: DAI,\n    buyToken: WBTC,\n    amount: 10000e18, // 10,000 DAI\n    limit: t.minPurchaseAmount,\n    deadline: block.timestamp,\n    exchangeData: t.exchangeData\n});\n```\n\nThis means that the trade will swap in an arbitrary amount of DAI for the exact amount of 10000e18 WBTC (= 1.0e14 WBTC token)\n\nIt is possible that there is an excess balance of DAI residing on the Yield Strategy vault due to several reasons (e.g., reward token happens to be DAI). In this case, the DAI tokens residing on the Yield Strategy vault will be swapped to 1.0e14 WBTC tokens.\n\nTo recap, if `TradeType.EXACT_IN_SINGLE` is used, the 0.1 WBTC will be received. If `TradeType.EXACT_OUT_SINGLE` is used, 1.0e14 WBTC will be received.\n\nThus, by changing the `TradeType`, the user could potentially obtain much more assets than expected and steal funds from the vault.\n\nFollowing is an extract from the [Contest's README](https://github.com/sherlock-audit/2025-06-notional-exponent-xiaoming9090/tree/main?tab=readme-ov-file#q-please-discuss-any-design-choices-you-made). The protocol is designed to be extendable and intended to work with different pools and tokens. Thus, the above example is just one possible instance, and many other combinations are possible due to the different lending platforms, pool, tokens, reward tokens being supported by the protocol.\n\n> Q: Please discuss any design choices you made.\n>\n> Notional Exponent is designed to be extendable to new yield strategies and opportunities as well as new lending platforms. \n\n**Instance 2 - Withdraw Request Manager**\n\nThe similar issue is also found in the `AbstractWithdrawRequestManager._preStakingTrade()` function, where the trade type can be arbitrarily defined by the caller in Line 277. The exploit method closely resembles the one described in the previous instance.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/withdraws/AbstractWithdrawRequestManager.sol#L268\n\n```solidity\nFile: AbstractWithdrawRequestManager.sol\n268:     function _preStakingTrade(address depositToken, uint256 depositAmount, bytes calldata data) internal returns (uint256 amountBought, bytes memory stakeData) {\n269:         if (depositToken == STAKING_TOKEN) {\n270:             amountBought = depositAmount;\n271:             stakeData = data;\n272:         } else {\n273:             StakingTradeParams memory params = abi.decode(data, (StakingTradeParams));\n274:             stakeData = params.stakeData;\n275: \n276:             (/* */, amountBought) = _executeTrade(Trade({\n277:                 tradeType: params.tradeType,\n278:                 sellToken: depositToken,\n279:                 buyToken: STAKING_TOKEN,\n280:                 amount: depositAmount,\n```\n\nAssume that\n\n- `depositToken` is not equal to the `STAKING_TOKEN`\n- Yield Strategy vault's assets token is USDC. \n- `WITHDRAW_TOKEN` is USDC\n\nAfter the WR is finalized, the withdraw token (USDC) will reside in WRM if someone calls `finalizeRequestManual`.\n\nIn this case, when a trade is executed, `sellToken=depositToken=USDC` and `buyToken=StakingToken`. Thus, malicious users can use the same exploit (setting trading type to EXACT_OUT) mentioned earlier to steal USDC funds on WRM to purchase more staking tokens than expected, which will, in turn, generate more yield tokens/collateral shares under their account.\n\n### Impact\n\nHigh. Malicious users can exploit this to steal funds from the vault.\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nThe fix is straightforward. Simply hardcoded the trade type to `TradeType.EXACT_IN_SINGLE` to prevent this exploit. This will ensure that an exact amount of tokens is swapped in exchange for an arbitrary amount of desired tokens, and not the other way round.\n\n```diff\n/// @dev Trades the amount of secondary tokens into the primary token after exiting a pool.\nfunction _executeRedemptionTrades(\n    ERC20[] memory tokens,\n    uint256[] memory exitBalances,\n    TradeParams[] memory redemptionTrades\n) internal returns (uint256 finalPrimaryBalance) {\n    for (uint256 i; i < exitBalances.length; i++) {\n        if (address(tokens[i]) == address(asset)) {\n            finalPrimaryBalance += exitBalances[i];\n            continue;\n        }\n\n        TradeParams memory t = redemptionTrades[i];\n        // Always sell the entire exit balance to the primary token\n        if (exitBalances[i] > 0) {\n            Trade memory trade = Trade({\n-               tradeType: t.tradeType,\n+               tradeType: TradeType.EXACT_IN_SINGLE,\n                sellToken: address(tokens[i]),\n                buyToken: address(asset),\n                amount: exitBalances[i],\n                limit: t.minPurchaseAmount,\n                deadline: block.timestamp,\n                exchangeData: t.exchangeData\n            });\n            (/* */, uint256 amountBought) = _executeTrade(trade, t.dexId);\n\n            finalPrimaryBalance += amountBought;\n        }\n    }\n}\n```\n\n```diff\nfunction _preStakingTrade(address depositToken, uint256 depositAmount, bytes calldata data) internal returns (uint256 amountBought, bytes memory stakeData) {\n    if (depositToken == STAKING_TOKEN) {\n        amountBought = depositAmount;\n        stakeData = data;\n    } else {\n        StakingTradeParams memory params = abi.decode(data, (StakingTradeParams));\n        stakeData = params.stakeData;\n\n        (/* */, amountBought) = _executeTrade(Trade({\n-           tradeType: params.tradeType,\n+           tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: depositToken,\n            buyToken: STAKING_TOKEN,\n            amount: depositAmount,\n            exchangeData: params.exchangeData,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp\n        }), params.dexId);\n    }\n}\n```\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/notional-finance/notional-v4/pull/18\n\n\n\n\n",
    "summary": "\nThis bug report discusses a vulnerability found in the Notional Exponent protocol. The vulnerability allows malicious users to exploit the protocol and steal funds from the Yield Strategy vault. The root cause of the issue is a flaw in the `_executeRedemptionTrades` function, where the `t.tradeType` can be set to any value by the caller. This allows the user to set it to `TradeType.EXACT_OUT_SINGLE` and receive an arbitrary amount of tokens instead of the expected amount. The same issue is also found in the `AbstractWithdrawRequestManager._preStakingTrade()` function. The impact of this vulnerability is high and can be mitigated by hardcoding the trade type to `TradeType.EXACT_IN_SINGLE` in both functions. The protocol team has fixed this issue in the latest PRs/commits.",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/715",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "h-10-malicious-user-can-change-the-tradetype-to-steal-funds-from-the-vault-or-withdraw-request-manager-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "mstpr-brainbot"
            }
        },
        {
            "wardens_warden": {
                "handle": "xiaoming90"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}