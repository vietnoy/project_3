{
    "id": 62139,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "LOW",
    "finders_count": 4,
    "protocol_id": 3380,
    "title": "Excluding the chainId may cause unexpected effects",
    "content": "## Vulnerability Report\n\n**Severity:** Low Risk\n\n**Context:** (No context files were provided by the reviewer)\n\n**Description:** \n\nIn `Keystore.handleUpdates`, we intentionally exclude the `chainId` from the signed message:\n\n```solidity\nbytes32 message =\nkeccak256(abi.encode(action.refHash, action.nextHash, action.account, action.nonce, nodeHash));\n```\n\nThis is done for improved UX, allowing for accounts to easily have the same veriﬁers on all chains. However, there are several potential risks to this approach. \n\nThe first category of risk to consider is the variance in behavior and protocol availability between chains. For example, in case a veriﬁer includes logic which depends on the duration of blocks, the outcome can vary signiﬁcantly between chains. Similarly, in case a veriﬁer depends on some external contract, e.g. a token, it may not be present on that chain, or there may be another contract deployed to that address, executing malicious logic.\n\nThe second category of risk to consider is that the veriﬁers themselves must be safely deployed such that another contract cannot be deployed to the same address on a different chain. This is possible in case the veriﬁer contract or any parent contract is deployed by a shared factory. One potential case in which this may occur is if the veriﬁer has been deployed by a gnosis safe, whereby an attacker may deploy a safe that they control at the same address on a different chain, allowing them to deploy a different contract to the veriﬁer address, potentially stealing funds from users of that veriﬁer.\n\n**Recommendation:** Include the current `chainId` in the signed message, potentially also including logic to make it optional. Otherwise, at least clearly document this potential risk, explaining how to safely deploy veriﬁers.\n\n**Stackup:** Fixed in PR 50.\n\n**Spearbit:** Fix veriﬁed.",
    "summary": "",
    "report_date": "2025-08-18T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Stackup-Spearbit-Security-Review-July-2025.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Stackup-Spearbit-Security-Review-July-2025.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Stackup-Spearbit-Security-Review-July-2025.pdf",
    "pdf_page_from": 9,
    "contest_id": "",
    "slug": "excluding-the-chainid-may-cause-unexpected-effects-spearbit-none-stackup-keystore-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Stackup Keystore",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Tnch"
            }
        },
        {
            "wardens_warden": {
                "handle": "Kaden"
            }
        },
        {
            "wardens_warden": {
                "handle": "Hake"
            }
        },
        {
            "wardens_warden": {
                "handle": "Gerard Persoon"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Stackup Keystore",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}