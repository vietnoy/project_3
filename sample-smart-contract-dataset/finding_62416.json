{
    "id": 62416,
    "kind": "MARKDOWN",
    "auditfirm_id": 34,
    "impact": "MEDIUM",
    "finders_count": 1,
    "protocol_id": 1826,
    "title": "[EIGEN2-2] Current rate limit logic allows ejection beyond allowed limit",
    "content": "**Severity:** Medium\n\n**Path:** EjectionManager.sol:ejectOperators\n\n**Description:** The owner or an ejector can eject operators. Only the ejector has a rate limit, which restricts how much can be totally rejected during a quorum, that is based on a limit set by the owner.\n\nWhen an ejector calls `ejectOperators` to eject an operator, it checks the `amountEjectable` for the  quorum. This is used as the total amount ejectors are allowed to remove.\n\nThe issue occurs in the following condition:\n```\nfunction ejectOperators(\n    bytes32[][] memory operatorIds\n) external {  \n\n-- SNIP -- \n\n  if (\n      isEjector[msg.sender]\n          && quorumEjectionParams[quorumNumber].rateLimitWindow > 0\n          && stakeForEjection + operatorStake > amountEjectable\n  ) {\n\n      ratelimitHit = true;\n\n      stakeForEjection += operatorStake;\n      ++ejectedOperators;\n\n      slashingRegistryCoordinator.ejectOperator(\n          slashingRegistryCoordinator.getOperatorFromId(operatorIds[i][j]),\n          abi.encodePacked(quorumNumber)\n      );\n\n      emit OperatorEjected(operatorIds[i][j], quorumNumber);\n\n      break;\n  }\n```\nIf the rate limit is hit, it will still eject the operator and only then break the loop.\n\nConsider the following scenario:\n\n- `amountEjectable` = 1e16 (the allowed amount for this quorum to be removed by the ejector) \n\n- `OperatorXAmount` =  10e18.\n```\nstakeForEjection + operatorStake > amountEjectable\n0 + 10e18 > 1e16\n```\nIt will eject the operator that had a value of `10e18`, even though the ejector is only allowed to eject up to `1e16`.\n\n**Remediation:**  Considering removing the ejecting logic in the case where the rate limit would have been hit, so it will only make `ratelimitHit` true and break the loop.\n```\nfunction ejectOperators(\n    bytes32[][] memory operatorIds\n) external {  \n\n-- SNIP -- \n\n  if (\n      isEjector[msg.sender]\n          && quorumEjectionParams[quorumNumber].rateLimitWindow > 0\n          && stakeForEjection + operatorStake > amountEjectable\n  ) {\n\n      ratelimitHit = true;\n\n--    stakeForEjection += operatorStake;\n--    ++ejectedOperators;\n\n--    slashingRegistryCoordinator.ejectOperator(\n--         slashingRegistryCoordinator.getOperatorFromId(operatorIds[i][j]),\n--         abi.encodePacked(quorumNumber)\n--     );\n\n--     emit OperatorEjected(operatorIds[i][j], quorumNumber);\n\n      break;\n  }\n```\n\n**Status:**   Fixed\n\n\n- - -",
    "summary": "\nThis bug report discusses a medium severity issue in the EjectionManager.sol file, specifically in the `ejectOperators` function. The function allows the owner or an ejector to eject operators, with the ejector having a rate limit based on the owner's set limit. However, there is a problem in the code where the rate limit is not properly checked before ejecting an operator. This means that even if the rate limit is hit, the operator can still be ejected, resulting in the ejector being able to remove more operators than allowed. The suggested solution is to remove the ejecting logic in the case of a rate limit hit, so that only the `ratelimitHit` variable is set to true and the loop is broken. This issue has been fixed.",
    "report_date": "2025-04-22T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Hexens/2025-04-22-EigenLayer.md",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "",
    "slug": "eigen2-2-current-rate-limit-logic-allows-ejection-beyond-allowed-limit-hexens-none-eigenlayer-markdown",
    "firm_name": "Hexens",
    "firm_logo_square": "Hexens_square.png",
    "protocol_name": "Eigenlayer",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Hexens"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Hexens",
        "logo_square": "Hexens_square.png"
    },
    "protocols_protocol": {
        "name": "Eigenlayer",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}