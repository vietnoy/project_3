{
    "id": 62275,
    "kind": "PDF",
    "auditfirm_id": 6,
    "impact": "HIGH",
    "finders_count": 3,
    "protocol_id": 3396,
    "title": "minLiquidityRate formula",
    "content": "## Severity: High Risk\n\n## Context\n- MiniPoolDefaultReserveInterestRate.sol#L227-L254\n- MiniPoolPiReserveInterestRateStrategy.sol#L197-L224\n\n## Description/Recommendation\nWhen the Mproxy does not have enough liquidity during a mini pool borrow, the following happens:\n\n1. The mini pool PM borrows an unbacked amount from the reserve in the lending pool PL.\n2. PM deposits back into PL to get a wrapped token and take advantage of interest accrual.\n3. Deposits that wrapped token into the corresponding reserve in PM to get a double-wrapped token.\n4. Borrows to the user.\n\nDuring this process, the following amount of debt will be minted for the user in the Mproxy (idTB,U):\n- `(a ray it0,MP B,Twrapper A,U)`\n\nAnd the following amount of lending share will be minted in Mproxy (idTA,U) for PM:\n- `a ray it0,MP L,Twrapper A,U`\n\nAnd the following debt position will be minted for PM in the reserve (U, true) of the PL:\n- `(a ray it0,LP L,U) ray it0,LP B,U`\n\nWhere `t0` is the time the borrow was called on the mini pool. Now assume from that time to time `tn`:\n- The set of interactions with the lending pool is `J`.\n- The set of interactions with the mini pool is `K`.\n\nThen at time `tn`, the mini pool PM needs to pay back the lending pool the following amount:\n- `A0 = (a ray it0,LP L,U) O ray,J (1ray + r tj ,LP B,U) tj`\n\nAnd the amount owed by the user when calculated in the main underlying asset with all the mini pool borrow interest and lending pool deposit interest becomes:\n- `A1 = ((a O ray,K (1ray + rtk ,MP B,Twrapper A,U) tk) ray it0,LP L,U) O ray,J (1ray + tj r tj ,LP L,U)`\n\nNote that `ray` is not associative, and swapping the order of components can introduce tiny errors, so we have:\n- `A1 \u0019 (a ray it0,LP L,U) O ray,J (1ray + tj r tj ,LP L,U) O ray,K (1ray + rtk ,MP B,Twrapper A,U) tk`\n\nThe amount of the main underlying assets owed to the mini pool from its share in Mproxy (idTA,U) at time `tn` would be:\n- `A2 = (a O ray,K(1ray + tk rtk ,MP L,TA,U)) ray it0,LP L,U O ray,J(1ray + tj r tj ,LP L,U)`\n\nWhich is roughly:\n- `A2 \u0019 (a ray it0,LP L,U) O ray,J (1ray + tj r tj ,LP L,U) O ray,K (1ray + tk rtk ,MP L,TA,U)`\n\nNote that all `A0`, `A1`, `A2` have the common `a ray it0,LP L,U` factor (roughly). One might think that `A0` should be able to be repaid by a mix of `A1` and `A2`, but we might not always assume that the user would repay its debt on time or at all so we might want to define the following constraints:\n\n- `A0 \u0014 A2`\n- or going a little further:\n- `A0 \u0014 A2 \u0014 A1`\n\nThe first inequality would give us:\n- `O ray,J (1ray + r tj ,LP B,U) tj (1ray + tj r tj ,LP L,U) \u0014 O ray,K (1ray + tk rtk ,MP L,TA,U)`\n\nThis is the more general inequality (and the division is aray division) than the one enforced in the codebase. In the codebase, `J` and `K` coincide and have only one element, and `tj = tk` is the 5 day delta time margin normalised and the rates are also normalised with respect to `SECONDS_PER_YEAR`.\n\nAnd so if there are many interactions with the lending pool corresponding to the reserve in the question compared to the one in the mini pool, the mini pool's minted lending shares in itself might not be able to repay the borrowed loans in the lending pool.\n\nFor simplicity's sake in the equations below, assume we are analyzing the case where `J = K` and we only have one `t = tj` and `rL = r tj ,LP L,U`, `rB = r tj ,LP B,U` then define:\n- `f(t) = g(t, rL, rB) = (1 + rB)t � (1 + rLt)t + rLt2 \u0019 (rB � rL) + (t � 1/2)r2 B + (t � 1/2)(t � 2/3)r3 B / (1 + rLt)`\n\n- `f(0) = log(1 + rB) � rL \u0019 (rB � r2 B/2 + r3 B/3) � rL \u0019 rB � rL`\n- `f(1) \u0019 rB � rL / (1 + rL)`\n\n### A Few Notes\n1. The expressions above are normalized with respect to the Ray precision.\n2. Binomial approximation is used up to 4 terms according to the codebase.\n3. At `t = 0` the inequality holds since both sides would be `1 ray`, so we don't have to analyze `f(0)` that much.\n\nOne can show that on the interval `[1, 1)` the function `f(t)` is increasing (please double check). A desired property to prove is that `f(t)` is an increasing function in the positive domain or at least in the domain from `0` up to the `DELTA_TIME_MARGIN` `tm`. This would give us a guarantee that `f(tm)` is the maximum value in the domain `[0, tm]`. \n\nBased on the above, one needs to take the maximum of `f(0)` and `f(tm)` to find the maximum in the set `[0, tm] \\ Z`, let's call this value `fmax`. If we prove or guarantee the following two invariants, we can prove that `A0 \u0014 A2`:\n\n1. `J \u001a K`, this still needs to be enforced by making sure whenever the interest rates in the reserve (U, true) are updated in the lending pool, the corresponding tranched reserves' interest rates are updated in all the mini pools using that `T wrapper A,U`. Although this might be a costly operation.\n2. `fmax \u0014 rtk ,MP L,TA,U`, this has been partially checked in the code in this context although `minLiquidityRate` is not compared against `f(0)`.\n3. The interactions with the lending pool are not more than `DELTA_TIME_MARGIN` far apart. We need to ensure for all `j, tj \u0014 tm`.\n\n### Footnote\nThe second inequality `A2 \u0014 A1` gives us:\n- `O ray,K(1ray + tk rtk ,MP L,TA,U) \u0014 O ray,K(1ray + rtk ,MP B,Twrapper A,U) tk`\n\nWhere roughly assuming `rtk ,MP L,TA,U \u0014 rtk ,MP B,T wrapper A,U` should prove the above. The IRM implementations already follow this invariant when picking `currentLiquidityRate` and `currentVariableBorrowRate`.\n\n**Astera**: Addressed in PR 31.",
    "summary": "\nThis bug report discusses a potential issue in the code for the MiniPoolDefaultReserveInterestRate and MiniPoolPiReserveInterestRateStrategy contracts. The issue arises when there is not enough liquidity in the Mproxy during a mini pool borrow. This can result in incorrect calculations and a mismatch between the amount of debt owed by the user and the amount of debt owed by the mini pool. To fix this issue, the report recommends enforcing certain constraints and ensuring that the interactions with the lending pool are not too far apart. The report also mentions that this issue has been partially addressed in the code, but some further checks and updates are needed.",
    "report_date": "2025-08-29T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astera-Spearbit-Security-Review-December-2024.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astera-Spearbit-Security-Review-December-2024.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/spearbit/Astera-Spearbit-Security-Review-December-2024.pdf",
    "pdf_page_from": 6,
    "contest_id": "",
    "slug": "minliquidityrate-formula-spearbit-none-astera-pdf",
    "firm_name": "Spearbit",
    "firm_logo_square": "spearbit_square.png",
    "protocol_name": "Astera",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Saw-mon and Natalie"
            }
        },
        {
            "wardens_warden": {
                "handle": "Cergyk"
            }
        },
        {
            "wardens_warden": {
                "handle": "Jonatas Martins"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Spearbit",
        "logo_square": "spearbit_square.png"
    },
    "protocols_protocol": {
        "name": "Astera",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}