{
    "id": 62507,
    "kind": "GIT",
    "auditfirm_id": 3,
    "impact": "MEDIUM",
    "finders_count": 6,
    "protocol_id": 3104,
    "title": "M-15: Loss of reward tokens during initiating withdrawal due to cooldown",
    "content": "\nSource: https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/669 \n\n## Found by \n0xDeoGratias, Bigsam, crunter, touristS, xiaoming90, yaractf\n\n### Summary\n\n-\n\n### Root Cause\n\n-\n\n### Internal Pre-conditions\n\n-\n\n### External Pre-conditions\n\n-\n\n### Attack Path\n\nIn Line 191 below, if the cooldown has not over yet, the protocol will skip the claiming of rewards from external protocols.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/rewards/AbstractRewardManager.sol#L191\n\n```solidity\nFile: AbstractRewardManager.sol\n183:     /// @notice Executes a claim against the given reward pool type and updates internal\n184:     /// rewarder accumulators.\n185:     function _claimVaultRewards(\n186:         uint256 effectiveSupplyBefore,\n187:         VaultRewardState[] memory state\n188:     ) internal {\n189:         RewardPoolStorage memory rewardPool = _getRewardPoolSlot(); // @audit-ok\n190:         if (rewardPool.rewardPool == address(0)) return;\n191:         if (block.timestamp < rewardPool.lastClaimTimestamp + rewardPool.forceClaimAfter) return;\n```\n\nConcerning tracking of rewards, the invariant is that whenever there is a change in `effectiveSupplyBefore` (aka total supply), the protocol must claim the rewards and update the reward accumulation state variable based on the current `effectiveSupplyBefore` before updating the new `effectiveSupply` value. However, this is not always true because the protocol will sometimes skip claiming rewards.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/AbstractYieldStrategy.sol#L150\n\n```solidity\nFile: AbstractYieldStrategy.sol\n149:     function effectiveSupply() public view returns (uint256) {\n150:         return (totalSupply() - s_escrowedShares + VIRTUAL_SHARES); // @audit-info VIRTUAL_SHARES = 1e6\n151:     }\n```\n\nAssume the following states at Time T0.\n\n- `rewardPool.forceClaimAfter` is set to 15 minutes.\n- The current balance of yield tokens residing in the Yield Strategy vault, the vault is earning 1 WETH per minutes.\n- The current `effectiveSupply()` is 10. Bob holds 5 shares, while Alice holds 5 shares.\n- `accumulatedRewardPerVaultShare` = 0.\n\nAt T5 (5 minutes later since T0), 5 WETH is earned, and `accumulatedRewardPerVaultShare` will increase by 0.5 (5 WETH rewards divided by 10 vault shares), per Line 267 below. This basically means that each share is entitled to 0.5 WETH.\n\nThe `accumulatedRewardPerVaultShare` will be 0.5 now and `rewardPool.lastClaimTimestamp` will be set to T5.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/rewards/AbstractRewardManager.sol#L267\n\n```solidity\nFile: AbstractRewardManager.sol\n259:     function _accumulateSecondaryRewardViaClaim(\n260:         uint256 index,\n261:         VaultRewardState memory state,\n262:         uint256 tokensClaimed,\n263:         uint256 effectiveSupplyBefore\n264:     ) private {\n265:         if (tokensClaimed == 0) return;\n266: \n267:         state.accumulatedRewardPerVaultShare += (\n268:             (tokensClaimed * DEFAULT_PRECISION) / effectiveSupplyBefore\n269:         ).toUint128();\n270: \n271:         _getVaultRewardStateSlot()[index] = state;\n272:     }\n```\n\nAt T10 (10 minutes later), Bob decided to call `initiateWithdraw` to initiate a withdrawal, the `s_escrowedShares` will increase by 9. Before `s_escrowedShares` is increased by 5, the following `updateAccountRewards` function at Line 131 will be executed to ensure that Bob claims or retrieves all the reward tokens he is entitled to before initiating the withdrawal. This is critical because, after initiating the withdrawal, Bob can no longer claim the rewards, as per the protocol's design.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/rewards/RewardManagerMixin.sol#L131\n\n```solidity\nFile: RewardManagerMixin.sol\n120:     /// @dev Ensures that the account no longer accrues rewards after a withdraw request is initiated.\n121:     function _initiateWithdraw(\n122:         address account,\n123:         uint256 yieldTokenAmount,\n124:         uint256 sharesHeld,\n125:         bytes memory data\n126:     ) internal override returns (uint256 requestId) {\n127:         uint256 effectiveSupplyBefore = effectiveSupply();\n128: \n129:         // Claim all rewards before initiating a withdraw shares not considered \n130:         // in the escrow state at this point.\n131:         _updateAccountRewards({\n132:             account: account,\n133:             accountSharesBefore: sharesHeld,\n134:             accountSharesAfter: sharesHeld,\n135:             effectiveSupplyBefore: effectiveSupplyBefore,\n136:             sharesInEscrow: false\n137:         });\n138: \n139:         requestId = __initiateWithdraw(account, yieldTokenAmount, sharesHeld, data);\n140:     }\n```\n\nThe `updateAccountRewards` function will internally execute the `_claimVaultRewards` function in Line 159 below. Since, it is still in cooldown, the claiming of rewards from external protocols will be skipped. Even though a total reward of 5 WETH has accumulated since T5 that is awaiting to be claimed at the external protocol, it is not claimed due to the cooldown. To recap, note that from T0 to T10, 10 minutes have already been passed and a total of 10 WETH is earned. 5 WETH has been claimed and the other 5 WETH has not been claimed.\n\nSubsequently, at Line 173, the `_claimRewardToken` will be executed to claim the rewards for Bob. In this case, based on the current `accumulatedRewardPerVaultShare` (0.5), Bob will receive 2.5 WETH. Here, we can already see a valid issue that although a total of 10 WETH is earned, Bob only received 2.5 WETH instead of 5 WETH. This means that Alice will be able to obtain a rewards of 7.5 WETH later once the cooldown is over.\n\nhttps://github.com/sherlock-audit/2025-06-notional-exponent/blob/main/notional-v4/src/rewards/AbstractRewardManager.sol#L173\n\n```solidity\nFile: AbstractRewardManager.sol\n148:     function updateAccountRewards(\n149:         address account,\n150:         uint256 effectiveSupplyBefore,\n151:         uint256 accountSharesBefore,\n152:         uint256 accountSharesAfter,\n153:         bool sharesInEscrow\n154:     ) external returns (uint256[] memory rewards) {\n155:         // Short circuit in this case, no rewards to claim\n156:         if (sharesInEscrow && accountSharesAfter > 0) return rewards;\n157: \n158:         VaultRewardState[] memory state = _getVaultRewardStateSlot();\n159:         _claimVaultRewards(effectiveSupplyBefore, state);\n160:         rewards = new uint256[](state.length);\n161: \n162:         for (uint256 i; i < state.length; i++) {\n163:             if (sharesInEscrow && accountSharesAfter == 0) {\n164:                 delete _getAccountRewardDebtSlot()[state[i].rewardToken][account];\n165:                 continue;\n166:             }\n167: \n168:             if (0 < state[i].emissionRatePerYear) {\n169:                 // Accumulate any rewards with an emission rate here\n170:                 _accumulateSecondaryRewardViaEmissionRate(i, state[i], effectiveSupplyBefore);\n171:             }\n172: \n173:             rewards[i] = _claimRewardToken(\n174:                 state[i].rewardToken,\n175:                 account,\n176:                 accountSharesBefore,\n177:                 accountSharesAfter,\n178:                 state[i].accumulatedRewardPerVaultShare\n179:             );\n180:         }\n181:     }\n```\n\nThe root cause here is that, during initiating withdrawal, the cooldown should not be applicable and the claiming of reward tokens from external protocol must always occur. This is ensure that the `accumulatedRewardPerVaultShare` is updated to the latest state before Bob claims his reward for the last time.\n\n### Impact\n\nHigh, loss of funds (reward tokens) for the affected victim as shown above.\n\n\n### PoC\n\n_No response_\n\n### Mitigation\n\nDuring initiating withdrawal, the cooldown should not be applicable and the claiming of reward tokens from the external protocol must always occur. This ensures that the `accumulatedRewardPerVaultShare` is updated to the latest state before Bob claims his reward for the last time.\n\n",
    "summary": "\nBug report summary:\n\nThe bug report discusses an issue found in a code for a protocol. The issue involves a cooldown period that can cause the protocol to skip claiming rewards from external protocols. This results in a loss of funds for the affected user. The report suggests that during initiating a withdrawal, the cooldown should not be applicable and the claiming of reward tokens from the external protocol must always occur to avoid this issue.",
    "report_date": "2025-07-18T15:00:00.000Z",
    "contest_prize_txt": "75500 USDC",
    "contest_link": "https://app.sherlock.xyz/audits/contests/1001",
    "sponsor_name": "",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "",
    "github_link": "https://github.com/sherlock-audit/2025-06-notional-exponent-judging/issues/669",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "1001",
    "slug": "m-15-loss-of-reward-tokens-during-initiating-withdrawal-due-to-cooldown-sherlock-notional-exponent-git",
    "firm_name": "Sherlock",
    "firm_logo_square": "sherlock_square.png",
    "protocol_name": "Notional Exponent",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "touristS"
            }
        },
        {
            "wardens_warden": {
                "handle": "crunter"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xDeoGratias"
            }
        },
        {
            "wardens_warden": {
                "handle": "yaractf"
            }
        },
        {
            "wardens_warden": {
                "handle": "xiaoming90"
            }
        },
        {
            "wardens_warden": {
                "handle": "Bigsam"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Sherlock",
        "logo_square": "sherlock_square.png"
    },
    "protocols_protocol": {
        "name": "Notional Exponent",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}