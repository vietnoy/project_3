{
    "id": 62194,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "LOW",
    "finders_count": 0,
    "protocol_id": 3136,
    "title": "[L-01] Batch Operation Fully Reverts on Invalid Ejection Entry",
    "content": "\nType: Logic Error / Design Flaw\n\n### Summary\n\nThe `processBadPerformanceProof` function in the `CSStrikes` contract, which handles batch ejections for validators with excessive strikes, will revert the entire transaction if any single validator in the batch does not meet the required strike threshold for ejection. This “all-or-nothing” behavior is caused by a hard `revert` within the internal `_ejectByStrikes` function when it encounters an invalid entry.\n\nConsequently, all other valid ejections within the same batch are also rolled back, preventing their timely processing. This design introduces operational inefficiency, as the entire batch must be filtered off-chain and resubmitted, potentially delaying necessary enforcement actions against poorly performing validators.\n\n### Description\n\nIn Lido’s Community Staking Module, when processing batch validator ejections for excessive strikes, the entire batch operation will revert if any single entry in the batch fails a required precondition. This means no state changes or side effects are committed, even for entries that satisfy all requirements.\n\nConcretely, in `CSStrikes.processBadPerformanceProof`, a list of validator keys is processed for potential ejection. For each entry, the function calls the internal `_ejectByStrikes` method, which calculates the total strikes and checks them against the configured threshold. If any entry in the batch has `strikes < threshold`, `_ejectByStrikes` reverts with `NotEnoughStrikesToEject()`. Due to EVM atomicity, this causes the entire transaction to revert, undoing all previous state changes and external calls, including for those entries that otherwise qualified for ejection.\n\nin [`CSStrikes# L243-L245`](https://github.com/code-423n4/2025-07-lido-finance/blob/main/src/CSStrikes.sol# L243-L245):\n```\n\nif (strikes < threshold) {\n    revert NotEnoughStrikesToEject();\n}\n```\n\nWhile enforcing the threshold check on-chain is reasonable to ensure protocol-level consistency and security, reverting the entire transaction due to a single invalid entry is unnecessarily restrictive. This design can prevent the timely processing of valid entries within the batch and introduce operational friction.\n\n### PoC\n\nThis PoC was implemented directly in the existing `CSStrikesProofTest` suite, not `PoC.t.sol`, due to the low severity and straightforward nature of the issue.\n\nThe scenario is:\n\n* A user (or automation) submits a batch proof for ejection:\n\n  + `[Key1 (sufficient strikes), Key2 (sufficient strikes), Key3 (insufficient strikes)]`\n* `processBadPerformanceProof` begins processing.\n* On reaching Key3, the function reverts, causing the entire transaction to revert.\n* No validator is ejected, no penalties are recorded, and the operation must be retried offchain with a filtered list.\n\n  \n```\n\n  function test_processBadPerformanceProof_RevertWhen_OneOfManyHasNotEnoughStrikes()\n  public\n  {\n  // 1. Setup test environment and manual Merkle tree.\n  // Set the strikes threshold for ejection to 50.\n  uint256 STRIKES_THRESHOLD = 50;\n  module.PARAMETERS_REGISTRY().setStrikesParams(0, 6, STRIKES_THRESHOLD);\n\n  // Manually create leaves for success/failure scenarios.\n  // Successful entry 1 (strikes > 50)\n  (bytes memory pubkey0, ) = keysSignatures(1, 0);\n  uint256[] memory strikesData0 = UintArr(60); // total strikes: 60\n  leaves.push(Leaf(ICSStrikes.KeyStrikes({ nodeOperatorId: 0, keyIndex: 0, data: strikesData0 }), pubkey0));\n\n  // Successful entry 2 (strikes > 50)\n  (bytes memory pubkey1, ) = keysSignatures(1, 1);\n  uint256[] memory strikesData1 = UintArr(70); // total strikes: 70\n  leaves.push(Leaf(ICSStrikes.KeyStrikes({ nodeOperatorId: 1, keyIndex: 0, data: strikesData1 }), pubkey1));\n\n  // Failing entry (strikes < 50)\n  (bytes memory pubkey2, ) = keysSignatures(1, 2);\n  uint256[] memory strikesData2 = UintArr(40); // total strikes: 40\n  leaves.push(Leaf(ICSStrikes.KeyStrikes({ nodeOperatorId: 2, keyIndex: 0, data: strikesData2 }), pubkey2));\n\n  // Build the Merkle tree with the constructed leaves.\n  tree.pushLeaf(abi.encode(0, pubkey0, strikesData0));\n  tree.pushLeaf(abi.encode(1, pubkey1, strikesData1));\n  tree.pushLeaf(abi.encode(2, pubkey2, strikesData2));\n\n  // Submit the Merkle root to the contract.\n  bytes32 root = tree.root();\n  vm.prank(oracle);\n  strikes.processOracleReport(root, someCIDv0());\n\n  // 2. Prepare proof data and mocking.\n  uint256[] memory indicies = UintArr(0, 1, 2);\n  ICSStrikes.KeyStrikes[] memory keyStrikesList = new ICSStrikes.KeyStrikes[](indicies.length);\n  for(uint256 i = 0; i < indicies.length; ++i) {\n      keyStrikesList[i] = leaves[i].keyStrikes;\n  }\n\n  (bytes32[] memory proof, bool[] memory proofFlags) = tree.getMultiProof(indicies);\n\n  // Mock getSigningKeys calls for all entries in the loop.\n  for (uint256 i = 0; i < indicies.length; i++) {\n      Leaf memory leaf = leaves[indicies[i]];\n      vm.mockCall(\n          address(module),\n          abi.encodeWithSelector(\n              ICSModule.getSigningKeys.selector,\n              leaf.keyStrikes.nodeOperatorId,\n              leaf.keyStrikes.keyIndex,\n              1\n          ),\n          abi.encode(leaf.pubkey)\n      );\n  }\n\n  // 3. Expect revert and call the function.\n  // The proof is valid, so the revert will occur inside _ejectByStrikes due to threshold failure.\n  vm.expectRevert(ICSStrikes.NotEnoughStrikesToEject.selector);\n\n  this.processBadPerformanceProof{ value: keyStrikesList.length }(\n      keyStrikesList,\n      proof,\n      proofFlags,\n      address(0)\n  );\n\n  // Because the revert happens, even the entries that should have succeeded do not have their state updated.\n  }\n  \n```\n\nThe following log shows that `EjectorMock::ejectBadPerformer` is successfully called for the first two entries in the batch (with sufficient strikes), but the transaction ultimately reverts on the third entry (`NotEnoughStrikesToEject()`), rolling back all prior state changes as expected.\n```\n\nRan 1 test for test/CSStrikes.t.sol:CSStrikesProofTest\n[PASS] test_processBadPerformanceProof_RevertWhen_OneOfManyHasNotEnoughStrikes() (gas: 880667)\n...\n│   │   ├─ [285] EjectorMock::ejectBadPerformer{value: 1}(0, 0, CSStrikesProofTest: [...])\n│   │   │   └─ ← [Stop]\n│   │   ├─ [583] ExitPenaltiesMock::processStrikesReport(0, ...)\n│   │   │   └─ ← [Stop]\n│   │   ├─ [285] EjectorMock::ejectBadPerformer{value: 1}(1, 0, CSStrikesProofTest: [...])\n│   │   │   └─ ← [Stop]\n│   │   ├─ [583] ExitPenaltiesMock::processStrikesReport(1, ...)\n│   │   │   └─ ← [Stop]\n│   │   └─ ← [Revert] NotEnoughStrikesToEject()\n│   └─ ← [Revert] NotEnoughStrikesToEject()\n└─ ← [Stop]\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 12.50ms (1.93ms CPU time)\n```\n\n### Impact\n\n* This can lead to unnecessary delays in enforcement, particularly when large batches are submitted, as the entire batch must be retried after removing the invalid entry.\n* When reporting large batches of poor-performing validators, a single invalid entry can cause unnecessary transaction failures and delay enforcement across the protocol.\n\n### Recommendations\n\nTo improve operational efficiency, the contract should be updated to process all valid entries within a batch and simply skip any invalid ones, emitting an event for each skipped entry. This ensures that valid reports are handled without delay, and skipped entries can still be tracked off-chain.\n```\n\nif (strikes >= threshold) {\n    ejector.ejectBadPerformer{ value: value }(\n        keyStrikes.nodeOperatorId,\n        keyStrikes.keyIndex,\n        refundRecipient\n    );\n    EXIT_PENALTIES.processStrikesReport(keyStrikes.nodeOperatorId, pubkey);\n} else {\n\t// emit event\n}\n```\n\n---\n\n",
    "summary": "",
    "report_date": "2025-08-27T00:00:00.000Z",
    "contest_prize_txt": "103500",
    "contest_link": "https://code4rena.com/reports/2025-07-lido-finance",
    "sponsor_name": "Lido Finance",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-07-lido-finance",
    "github_link": "",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "516",
    "slug": "l-01-batch-operation-fully-reverts-on-invalid-ejection-entry-code4rena-lido-finance-lido-finance-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Lido Finance",
    "bookmarked": false,
    "read": false,
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Lido Finance",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}