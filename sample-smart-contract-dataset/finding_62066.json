{
    "id": 62066,
    "kind": "GIT",
    "auditfirm_id": 2,
    "impact": "MEDIUM",
    "finders_count": 4,
    "protocol_id": 2159,
    "title": "[M-03] If a withdrawal executes after a bad debt auction gets created, it could cause the auction to be stuck and further bad debt auctions can’t be created",
    "content": "\n\n<https://github.com/code-423n4/2025-02-blend/blob/f23b3260763488f365ef6a95bfb139c95b0ed0f9/blend-contracts-v2/pool/src/auctions/bad_debt_auction.rs# L15-L139>\n\n### Finding description and impact\n\nIn a bad debt auction:\n\n* Bid token - the `dtokens` (debt) the auction winner will take on.\n* Lot token - The backstop token the pool will transfer to the auction winner.\n\nFrom block 0 to 200, the amount of lot tokens given to winner scales **upwards** and peaks at block 200.\n\nFrom block 200 to infinity, the **amount of lot tokens given to winner stays the same at the peak value**.\n\nSo the first key observation is that the lot tokens can only increase or stay the same (and throughout the auction, will **never** decrease).\n\nThe second key observation is that there is no option to remove a bad debt auction. So if a bad debt auction can’t be filled then it’ll just be stuck there. It is worth noting that if there is an existing bad debt auction, then `create_bad_debt_auction_data` will **not allow** a new bad debt auction. (Hence, resulting in the whole bad debt auction mechanism to be stuck)\n\n* The only auction that has a function to remove it is the user liquidation auction. For bad debt auctions, only after filling it and a winner is chosen, then it will be removed.\n\nThe third observation is this line in `create_bad_debt_auction_data`:\n\n* The Line: `lot_amount = pool_backstop_data.tokens.min(lot_amount)`\n* Putting this in place was with the intention to ensure that the pool has sufficient backstop tokens so that the bad debt auction can be filled and wont be stuck.\n\nHowever, combining the 3 observations, we can derive a scenario where malicious users can brick new bad debt auctions.\n\n### Sequence of Attack\n\n1. Suppose the backstop currently has `50,000e7` tokens.\n2. `Attacker` initiates withdrawal of their `9,000e7` tokens. (And a one week lock starts)\n3. Some time later:\n\n   1. A bad debt auction is created. (Looking at the third observation, at this point of time, the pool still has `50,000e7` tokens so the min capping does not affect this).\n   2. Let’s say the optimal time to fill the auction is at block B, with users taking on X amount of debt in exchange for `42,000e7` tokens.\n   3. So `victim` attempts to fill the auction at block B, however `Attacker` frontruns with `withdraw`. (and now the pool is left with `41_000e7` tokens).\n   4. Now, the pool does not have enough tokens and the attempt to fill the auction panics and reverts.\n\nAs explained in the first observation, since lot token amounts can only increase/stay the same, even if the victim continues waiting, this **bad debt auction can’t be filled**\n\nNow, leveraging on the second observation, the existing bad debt auction is stuck there, preventing new bad debt auctions from being created.\n\n### Impact and likelihood\n\nSince **new bad debt auctions can’t be created, it causes certain losses for the lenders**. (Plus, this current bad debt isn’t socialized properly as well and lenders take the damage for it eventually).\n\nThis is almost certain to happen to pools with lower backstop supply. However, the likelihood shouldn’t be downgraded because of this as even some pools in uniswap have low supply. Furthermore, the low supply part is regarding the backstop pool, which is very likely to have less stakers than the main lender pool.\n\n### Proof of Concept\n\nGo to `bad_debt_auction.rs` and paste the PoC in the mod tests struct:\n```\n\n#[test]\nfn test_withdrawal_during_auction() {\n    let e = Env::default();\n    e.mock_all_auths_allowing_non_root_auth();\n    e.cost_estimate().budget().reset_unlimited(); // setup exhausts budget\n\n    e.ledger().set(LedgerInfo {\n        timestamp: 12345,\n        protocol_version: 22,\n        sequence_number: 51,\n        network_id: Default::default(),\n        base_reserve: 10,\n        min_temp_entry_ttl: 10,\n        min_persistent_entry_ttl: 10,\n        max_entry_ttl: 3110400,\n    });\n\n    let bombadil = Address::generate(&e);\n    let samwise = Address::generate(&e);\n\n    let pool_address = create_pool(&e);\n\n    let (blnd, blnd_client) = testutils::create_blnd_token(&e, &pool_address, &bombadil);\n    let (usdc, usdc_client) = testutils::create_token_contract(&e, &bombadil);\n    let (lp_token, lp_token_client) =\n        testutils::create_comet_lp_pool(&e, &bombadil, &blnd, &usdc);\n    let (backstop_address, backstop_client) =\n        testutils::create_backstop(&e, &pool_address, &lp_token, &usdc, &blnd);\n    // mint lp tokens\n    blnd_client.mint(&samwise, &500_001_0000000);\n    blnd_client.approve(&samwise, &lp_token, &i128::MAX, &99999);\n    usdc_client.mint(&samwise, &12_501_0000000);\n    usdc_client.approve(&samwise, &lp_token, &i128::MAX, &99999);\n    lp_token_client.join_pool(\n        &50_000_0000000,\n        &vec![&e, 500_001_0000000, 12_501_0000000],\n        &samwise,\n    );\n    backstop_client.deposit(&samwise, &pool_address, &50_000_0000000);\n\n    let (underlying_0, _) = testutils::create_token_contract(&e, &bombadil);\n    let (mut reserve_config_0, mut reserve_data_0) = testutils::default_reserve_meta();\n    reserve_data_0.d_rate = 1_100_000_000_000;\n    reserve_data_0.last_time = 12345;\n    reserve_config_0.index = 0;\n    testutils::create_reserve(\n        &e,\n        &pool_address,\n        &underlying_0,\n        &reserve_config_0,\n        &reserve_data_0,\n    );\n\n    let (underlying_1, _) = testutils::create_token_contract(&e, &bombadil);\n    let (mut reserve_config_1, mut reserve_data_1) = testutils::default_reserve_meta();\n    reserve_data_1.d_rate = 1_200_000_000_000;\n    reserve_data_1.last_time = 12345;\n    reserve_config_1.index = 1;\n    testutils::create_reserve(\n        &e,\n        &pool_address,\n        &underlying_1,\n        &reserve_config_1,\n        &reserve_data_1,\n    );\n\n    let (underlying_2, _) = testutils::create_token_contract(&e, &bombadil);\n    let (mut reserve_config_2, mut reserve_data_2) = testutils::default_reserve_meta();\n    reserve_data_2.b_rate = 1_100_000_000_000;\n    reserve_data_2.last_time = 12345;\n    reserve_config_2.index = 1;\n    testutils::create_reserve(\n        &e,\n        &pool_address,\n        &underlying_2,\n        &reserve_config_2,\n        &reserve_data_2,\n    );\n    let pool_config = PoolConfig {\n        oracle: Address::generate(&e),\n        min_collateral: 1_0000000,\n        bstop_rate: 0_1000000,\n        status: 0,\n        max_positions: 4,\n    };\n    let mut auction_data = AuctionData {\n        bid: map![&e, (underlying_0, 10_0000000), (underlying_1, 2_5000000)],\n        lot: map![&e, (lp_token.clone(), 42_000_0000000)],\n        block: 51,\n    };\n    let positions: Positions = Positions {\n        collateral: map![&e],\n        liabilities: map![\n            &e,\n            (reserve_config_0.index, 10_0000000),\n            (reserve_config_1.index, 2_5000000)\n        ],\n        supply: map![&e],\n    };\n\n    e.as_contract(&pool_address, || {\n        e.mock_all_auths_allowing_non_root_auth();\n        backstop_client.queue_withdrawal(&samwise, &pool_address, &9_000_0000000);\n        e.ledger().with_mut(|ledger| {\n            ledger.timestamp += 17 * 24 * 60 * 60 //1 week\n        });\n        storage::set_auction(\n            &e,\n            &(AuctionType::BadDebtAuction as u32),\n            &backstop_address,\n            &auction_data,\n        );\n        storage::set_pool_config(&e, &pool_config);\n        storage::set_user_positions(&e, &backstop_address, &positions);\n\n        let mut pool = Pool::load(&e);\n        let mut samwise_state = User::load(&e, &samwise);\n\n        /* A withdrawal executes some time between [create and fill] */\n        backstop_client.withdraw(&samwise, &pool_address, &9_000_0000000);\n        /* */\n        fill_bad_debt_auction(&e, &mut pool, &mut auction_data, &mut samwise_state);\n    });\n}\n```\n\nRun `cargo test test_withdrawal_during_auction` and we can see that it panics during `fill_bad_debt_auction`.\n\n### Recommendation\n\nIn the `fill_bad_debt_auction` function, in the `backstop_client.draw` function, cap the `lot_amount` drawn to the current balance of the backstop pool.\n\nCapping the lot token does not cause direct loss for the auction fillers as well because the bid token (which is the debt they have to take on in exchange) goes down. If they feel it’s not worth it now, they can always wait and fill it a few blocks later where they take on less debt.\n\n**markus\\_pl10 (Script3) confirmed**\n\n**[Blend mitigated](https://github.com/code-423n4/2025-04-blend-mitigation?tab=readme-ov-file# mitigation-of-high--medium-severity-issues):**\n\n> [PR 48](https://github.com/blend-capital/blend-contracts-v2/pull/48) to block `backstop::withdraw` calls if the backstop currently holds bad debt.\n\n**Status:** Mitigation confirmed. Full details in reports from [0x007](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-44), [Testerbot](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-63), [0xAlix2](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-7), [oakcobalt](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-24) and [rscodes](https://code4rena.com/audits/2025-04-blend-v2-mitigation-review/submissions/S-81).\n\n---\n\n",
    "summary": "\nThis bug report discusses a potential issue with the bad debt auction mechanism in the Blend protocol. The report explains that the lot token amount given to the winner of the auction can only increase or stay the same, and there is no option to remove a bad debt auction. This means that if a bad debt auction cannot be filled, it will be stuck in the system, preventing new auctions from being created. The report also includes a proof of concept for how a malicious user could exploit this issue. The impact of this bug is that lenders may experience losses and the likelihood of it occurring is high. The report recommends capping the lot token amount drawn from the backstop pool to prevent this issue. The status of the bug report is that it has been mitigated by the Blend team.",
    "report_date": "2025-08-13T00:00:00.000Z",
    "contest_prize_txt": "125000",
    "contest_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "sponsor_name": "Blend",
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://code4rena.com/reports/2025-02-blend-v2-audit-certora-formal-verification",
    "github_link": "https://code4rena.com/audits/2025-02-blend-v2-audit-certora-formal-verification/submissions/F-10",
    "pdf_link": "",
    "pdf_page_from": 0,
    "contest_id": "492",
    "slug": "m-03-if-a-withdrawal-executes-after-a-bad-debt-auction-gets-created-it-could-cause-the-auction-to-be-stuck-and-further-bad-debt-auctions-cant-be-created-code4rena-blend-blend-git",
    "firm_name": "Code4rena",
    "firm_logo_square": "code4rena_square.png",
    "protocol_name": "Blend",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "rapid"
            }
        },
        {
            "wardens_warden": {
                "handle": "attentioniayn"
            }
        },
        {
            "wardens_warden": {
                "handle": "rscodes"
            }
        },
        {
            "wardens_warden": {
                "handle": "0xAlix2"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "Code4rena",
        "logo_square": "code4rena_square.png"
    },
    "protocols_protocol": {
        "name": "Blend",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}