{
    "id": 62252,
    "kind": "PDF",
    "auditfirm_id": 9,
    "impact": "HIGH",
    "finders_count": 3,
    "protocol_id": 3394,
    "title": "Insufficient fee validation leading to user contract state lock",
    "content": "## High Difficulty Data Validation Issue\n\n## Description\n\nThe liquidation fee validation logic contains a flaw that allows attackers to permanently lock user funds by triggering incomplete liquidation processes. The current implementation validates only that `msg_value` is enough to cover `enough_fee` without accounting for the additional `TON_reserve_amount` required for successful transaction completion.\n\n```solidity\nif ((min_collateral_amount > max_allowed_liquidation) | (msg_value < enough_fee)) {\n    [...]\n    ;; Refund asset\n    immediate_asset_refund(\n        [...]\n    );\n    ;; Note that we don't break execution:\n    ;; We update asset_dynamics_collection with new s/b-rates regardless\n} else {\n    raw_reserve(TON_reserve_amount, reserve::AT_MOST + 2);\n    send_message_to_evaa_user_sc(\n        BLANK_CODE(), user_version, user_code, borrower_address, ;; <- the meaning is of\n        owner_address\n        liquidate_user_message,\n        sendmode::CARRY_ALL_BALANCE,\n        subaccount_id\n    );\n}\n```\n\n*Figure 7.1: Insufficient fee validation in `contracts_internal/contracts/core/master-liquidate.fc#L54–L87`*\n\nThe actual gas requirement for successful completion is `enough_fee + TON_reserve_amount`. This creates an exploitable window where transactions can pass validation but fail during execution, leaving user contracts in a locked state.\n\nWhen a liquidation request is processed, the user contract increments its state counter to track ongoing operations:\n\n```solidity\nuser::storage::save(\n    code_version,\n    master_address, owner_address,\n    user_principals,\n    state + 1, ;; Increase ongoing liquidation count\n    user_rewards, backup_cell_1, backup_cell_2\n);\n```\n\n*Figure 7.2: State increment during liquidation in `contracts_internal/contracts/core/user-liquidate.fc#L323–L329`*\n\nThis state variable acts as a critical lock mechanism that prevents withdrawals when it is incremented:\n\n```solidity\nif (state != user_state::free) {\n    reserve_and_send_rest(\n        fee::min_tons_for_storage,\n        master_address,\n        pack_supply_withdraw_unsatisfied_message(\n            query_id, owner_address,\n            supply_asset_id, supply_amount,\n            ton_amount_for_repay_remainings, custom_response_payload, subaccount_id\n        )\n    );\n    return ();\n}\n```\n\n*Figure 7.3: Withdrawal prevention logic in `contracts_internal/contracts/core/user-supply-withdrawal.fc#L21–L32`*\n\nAn attacker can exploit this by sending liquidation requests with `TON_reserve_amount < msg_value < enough_fee + TON_reserve_amount`. The transaction passes the initial fee check and increments the user’s state, but the liquidation process fails to complete due to insufficient gas. This leaves the user contract permanently locked with `state > 0`, blocking all future withdrawal attempts indefinitely.\n\n## Exploit Scenario\n\nBob wants to attack Alice’s account and lock her funds permanently. He identifies that Alice has a liquidatable position and crafts a malicious liquidation request.\n\nBob sends a transaction with `msg_value = 0.51 TON`, which covers the `TON_reserve_amount` (0.5 TON) but falls short of the total requirement of `enough_fee + TON_reserve_amount` (0.52 TON). The master contract’s fee validation passes since `0.51 TON > enough_fee (0.02 TON)`, and the liquidation process begins.\n\nAlice’s user contract receives the liquidation message and increments its state counter from 0 to 1 to track the ongoing operation. However, when the master contract attempts to complete the liquidation process, it runs out of gas due to insufficient funds. The liquidation fails to complete, but Alice’s user contract never receives the completion message to decrement the state back to 0. As a result, Alice’s account remains permanently locked with `state = 1`, indefinitely preventing her from withdrawing any of her supplied funds.\n\n## Recommendations\n\n- **Short term**: Update the fee validation logic to include the TON reserve amount requirement.\n- **Long term**: Implement comprehensive gas estimation to prevent partial execution scenarios that could leave contracts in inconsistent states.",
    "summary": "\nThis bug report highlights a high difficulty data validation issue in the liquidation fee logic. It allows attackers to lock user funds permanently by triggering incomplete liquidation processes. The current implementation does not validate the additional TON reserve amount required for successful transaction completion, which creates a window for exploitation. When a liquidation request is processed, the user contract increments its state counter, which acts as a critical lock mechanism to prevent withdrawals. An attacker can exploit this by sending a transaction with a specific amount of TON, causing the liquidation process to fail and leaving the user contract permanently locked. To prevent this, the fee validation logic should be updated to include the TON reserve amount requirement, and long-term solutions such as comprehensive gas estimation should be implemented.",
    "report_date": "2025-08-22T00:00:00.000Z",
    "contest_prize_txt": "",
    "contest_link": "https://github.com/trailofbits/publications/blob/master/reviews/2025-08-evaafinance-securityreview.pdf",
    "sponsor_name": null,
    "sponsor_link": "",
    "quality_score": 0,
    "general_score": 0,
    "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2025-08-evaafinance-securityreview.pdf",
    "github_link": "",
    "pdf_link": "https://solodit-bucket.s3.amazonaws.com/storage/reports/trailofbits/2025-08-evaafinance-securityreview.pdf",
    "pdf_page_from": 26,
    "contest_id": "",
    "slug": "insufficient-fee-validation-leading-to-user-contract-state-lock-trailofbits-none-evaa-finance-pdf",
    "firm_name": "TrailOfBits",
    "firm_logo_square": "trailofbits_square.png",
    "protocol_name": "EVAA Finance",
    "bookmarked": false,
    "read": false,
    "issues_issue_finders": [
        {
            "wardens_warden": {
                "handle": "Kevin Valerio Trail of Bits PUBLIC"
            }
        },
        {
            "wardens_warden": {
                "handle": "Guillermo Larregay"
            }
        },
        {
            "wardens_warden": {
                "handle": "Quan Nguyen"
            }
        }
    ],
    "auditfirms_auditfirm": {
        "name": "TrailOfBits",
        "logo_square": "trailofbits_square.png"
    },
    "protocols_protocol": {
        "name": "EVAA Finance",
        "protocols_protocolcategoryscore": []
    },
    "issues_issuetagscore": []
}